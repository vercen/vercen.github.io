import{c as F,a8 as z,aJ as St,aK as xt,d as ht,aL as nt,a as N,o as k,i as C,C as R,P as E,u as w,Q as M,W as bt,_ as ft,e as It,aM as B,S as zt,aN as kt,k as it,w as U,E as Ft,aO as Mt,aj as Ct,aH as Tt,f as L,V as O,aw as ot,ax as J,a1 as Ot,af as Vt,X as Lt,aP as rt,a0 as Et,aQ as At,T as Dt,F as $t,j as Rt,m as jt}from"./DuM02_51.js";import Pt from"./wz9ci7wk.js";import Nt from"./l5tTk9Fz.js";import{h as Wt,u as Bt,a as Ut}from"./fi-0BT3Z.js";import"./3l7zLyuf.js";import"./C_gm745W.js";function ct(o,t,e){const[s={},n]=typeof t=="string"?[{},t]:[t,e],i=F(()=>z(o)),c=s.key||Wt([n,typeof i.value=="string"?i.value:"",...Jt(s)]);if(!c||typeof c!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+c);if(!o)throw new Error("[nuxt] [useFetch] request is missing.");const r=c===n?"$f"+c:c;if(!s.baseURL&&typeof i.value=="string"&&i.value[0]==="/"&&i.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:u,lazy:d,default:l,transform:m,pick:h,watch:g,immediate:f,getCachedData:a,deep:p,dedupe:v,..._}=s,I=St({...xt,..._,cache:typeof s.cache=="boolean"?void 0:s.cache}),T={server:u,lazy:d,default:l,transform:m,pick:h,immediate:f,getCachedData:a,deep:p,dedupe:v,watch:g===!1?[]:[I,i,...g||[]]};let y;return Bt(r,()=>{var st;(st=y==null?void 0:y.abort)==null||st.call(y,"Request aborted as another request to the same endpoint was initiated."),y=typeof AbortController<"u"?new AbortController:{};const b=z(s.timeout);let $;return b&&($=setTimeout(()=>y.abort("Request aborted due to timeout."),b),y.signal.onabort=()=>clearTimeout($)),(s.$fetch||globalThis.$fetch)(i.value,{signal:y.signal,...I}).finally(()=>{clearTimeout($)})},T)}function Jt(o){var e;const t=[((e=z(o.method))==null?void 0:e.toUpperCase())||"GET",z(o.baseURL)];for(const s of[o.params||o.query]){const n=z(s);if(!n)continue;const i={};for(const[c,r]of Object.entries(n))i[z(c)]=z(r);t.push(i)}return t}const qt=["innerHTML"],Qt=["innerHTML"],Kt=ht({__name:"SearchItem",props:{title:{},content:{},titles:{},id:{},terms:{},queryTerms:{},score:{},match:{}},setup(o){const t=o,e=F(()=>[...t.titles??[],t.title].join(" > ")),s=F(()=>{var r;return(r=t.titles)==null?void 0:r.length}),n=F(()=>{var r;return((r=t.queryTerms)==null?void 0:r[0])??""}),i=F(()=>nt(e.value,n.value)),c=F(()=>nt(t.content??"",n.value));return(r,u)=>{const d=Pt,l=bt;return k(),N(l,{to:r.id,class:"search-item"},{default:C(()=>[R("h2",null,[w(s)?E("",!0):(k(),N(d,{key:0,round:""},{default:C(()=>u[0]||(u[0]=[M(" 文章 ")])),_:1})),R("span",{innerHTML:w(i)},null,8,qt)]),R("p",{class:"content",innerHTML:w(c)},null,8,Qt)]),_:1},8,["to"])}}}),Ht=ft(Kt,[["__scopeId","data-v-3622524a"]]),Gt="ENTRIES",mt="KEYS",gt="VALUES",S="";class q{constructor(t,e){const s=t._tree,n=Array.from(s.keys());this.set=t,this._type=e,this._path=n.length>0?[{node:s,keys:n}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:e}=D(this._path);if(D(e)===S)return{done:!1,value:this.result()};const s=t.get(D(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=D(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>D(t)).filter(t=>t!==S).join("")}value(){return D(this._path).node.get(S)}result(){switch(this._type){case gt:return this.value();case mt:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const D=o=>o[o.length-1],Zt=(o,t,e)=>{const s=new Map;if(t===void 0)return s;const n=t.length+1,i=n+e,c=new Uint8Array(i*n).fill(e+1);for(let r=0;r<n;++r)c[r]=r;for(let r=1;r<i;++r)c[r*n]=r;return pt(o,t,e,s,c,1,n,""),s},pt=(o,t,e,s,n,i,c,r)=>{const u=i*c;t:for(const d of o.keys())if(d===S){const l=n[u-1];l<=e&&s.set(r,[o.get(d),l])}else{let l=i;for(let m=0;m<d.length;++m,++l){const h=d[m],g=c*l,f=g-c;let a=n[g];const p=Math.max(0,l-e-1),v=Math.min(c-1,l+e);for(let _=p;_<v;++_){const I=h!==t[_],T=n[f+_]+ +I,y=n[f+_+1]+1,x=n[g+_]+1,b=n[g+_+1]=Math.min(T,y,x);b<a&&(a=b)}if(a>e)continue t}pt(o.get(d),t,e,s,n,l,c,r+d)}};class V{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=W(this._tree,t.slice(this._prefix.length));if(e===void 0){const[n,i]=tt(s);for(const c of n.keys())if(c!==S&&c.startsWith(i)){const r=new Map;return r.set(c.slice(i.length),n.get(c)),new V(r,t)}}return new V(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,Yt(this._tree,t)}entries(){return new q(this,Gt)}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return Zt(this._tree,t,e)}get(t){const e=Z(this._tree,t);return e!==void 0?e.get(S):void 0}has(t){const e=Z(this._tree,t);return e!==void 0&&e.has(S)}keys(){return new q(this,mt)}set(t,e){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,Q(this._tree,t).set(S,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Q(this._tree,t);return s.set(S,e(s.get(S))),this}fetch(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Q(this._tree,t);let n=s.get(S);return n===void 0&&s.set(S,n=e()),n}values(){return new q(this,gt)}[Symbol.iterator](){return this.entries()}static from(t){const e=new V;for(const[s,n]of t)e.set(s,n);return e}static fromObject(t){return V.from(Object.entries(t))}}const W=(o,t,e=[])=>{if(t.length===0||o==null)return[o,e];for(const s of o.keys())if(s!==S&&t.startsWith(s))return e.push([o,s]),W(o.get(s),t.slice(s.length),e);return e.push([o,t]),W(void 0,"",e)},Z=(o,t)=>{if(t.length===0||o==null)return o;for(const e of o.keys())if(e!==S&&t.startsWith(e))return Z(o.get(e),t.slice(e.length))},Q=(o,t)=>{const e=t.length;t:for(let s=0;o&&s<e;){for(const i of o.keys())if(i!==S&&t[s]===i[0]){const c=Math.min(e-s,i.length);let r=1;for(;r<c&&t[s+r]===i[r];)++r;const u=o.get(i);if(r===i.length)o=u;else{const d=new Map;d.set(i.slice(r),u),o.set(t.slice(s,s+r),d),o.delete(i),o=d}s+=r;continue t}const n=new Map;return o.set(t.slice(s),n),n}return o},Yt=(o,t)=>{const[e,s]=W(o,t);if(e!==void 0){if(e.delete(S),e.size===0)_t(s);else if(e.size===1){const[n,i]=e.entries().next().value;wt(s,n,i)}}},_t=o=>{if(o.length===0)return;const[t,e]=tt(o);if(t.delete(e),t.size===0)_t(o.slice(0,-1));else if(t.size===1){const[s,n]=t.entries().next().value;s!==S&&wt(o.slice(0,-1),s,n)}},wt=(o,t,e)=>{if(o.length===0)return;const[s,n]=tt(o);s.set(n+t,e),s.delete(n)},tt=o=>o[o.length-1],et="or",vt="and",Xt="and_not";class A{constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('MiniSearch: option "fields" must be provided');const e=t.autoVacuum==null||t.autoVacuum===!0?G:t.autoVacuum;this._options={...H,...t,autoVacuum:e,searchOptions:{...at,...t.searchOptions||{}},autoSuggestOptions:{...ie,...t.autoSuggestOptions||{}}},this._index=new V,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=X,this.addFields(this._options.fields)}add(t){const{extractField:e,tokenize:s,processTerm:n,fields:i,idField:c}=this._options,r=e(t,c);if(r==null)throw new Error(`MiniSearch: document does not have ID field "${c}"`);if(this._idToShortId.has(r))throw new Error(`MiniSearch: duplicate ID ${r}`);const u=this.addDocumentId(r);this.saveStoredFields(u,t);for(const d of i){const l=e(t,d);if(l==null)continue;const m=s(l.toString(),d),h=this._fieldIds[d],g=new Set(m).size;this.addFieldLength(u,h,this._documentCount-1,g);for(const f of m){const a=n(f,d);if(Array.isArray(a))for(const p of a)this.addTerm(h,u,p);else a&&this.addTerm(h,u,a)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,n={chunk:[],promise:Promise.resolve()},{chunk:i,promise:c}=t.reduce(({chunk:r,promise:u},d,l)=>(r.push(d),(l+1)%s===0?{chunk:[],promise:u.then(()=>new Promise(m=>setTimeout(m,0))).then(()=>this.addAll(r))}:{chunk:r,promise:u}),n);return c.then(()=>this.addAll(i))}remove(t){const{tokenize:e,processTerm:s,extractField:n,fields:i,idField:c}=this._options,r=n(t,c);if(r==null)throw new Error(`MiniSearch: document does not have ID field "${c}"`);const u=this._idToShortId.get(r);if(u==null)throw new Error(`MiniSearch: cannot remove document with ID ${r}: it is not in the index`);for(const d of i){const l=n(t,d);if(l==null)continue;const m=e(l.toString(),d),h=this._fieldIds[d],g=new Set(m).size;this.removeFieldLength(u,h,this._documentCount,g);for(const f of m){const a=s(f,d);if(Array.isArray(a))for(const p of a)this.removeTerm(h,u,p);else a&&this.removeTerm(h,u,a)}}this._storedFields.delete(u),this._documentIds.delete(u),this._idToShortId.delete(r),this._fieldLength.delete(u),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new V,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(e==null)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((s,n)=>{this.removeFieldLength(e,n,this._documentCount,s)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:n}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:n},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of t)this.discard(s)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,n=s(t,e);this.discard(n),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=X,this.performVacuuming(t,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const s=this._dirtCount;if(this.vacuumConditionsMet(e)){const n=t.batchSize||Y.batchSize,i=t.batchWait||Y.batchWait;let c=1;for(const[r,u]of this._index){for(const[d,l]of u)for(const[m]of l)this._documentIds.has(m)||(l.size<=1?u.delete(d):l.delete(m));this._index.get(r).size===0&&this._index.delete(r),c%n===0&&await new Promise(d=>setTimeout(d,i)),c+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(t==null)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||G.minDirtCount,s=s||G.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,n={...s,...e},i=this.executeQuery(t,e),c=[];for(const[r,{score:u,terms:d,match:l}]of i){const m=d.length||1,h={id:this._documentIds.get(r),score:u*m,terms:Object.keys(l),queryTerms:d,match:l};Object.assign(h,this._storedFields.get(r)),(n.filter==null||n.filter(h))&&c.push(h)}return t===A.wildcard&&n.boostDocument==null||c.sort(dt),c}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const s=new Map;for(const{score:i,terms:c}of this.search(t,e)){const r=c.join(" "),u=s.get(r);u!=null?(u.score+=i,u.count+=1):s.set(r,{score:i,terms:c,count:1})}const n=[];for(const[i,{score:c,terms:r,count:u}]of s)n.push({suggestion:i,terms:r,score:c/u});return n.sort(dt),n}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(H.hasOwnProperty(t))return K(H,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:n,fieldLength:i,storedFields:c,serializationVersion:r}=t,u=this.instantiateMiniSearch(t,e);u._documentIds=j(n),u._fieldLength=j(i),u._storedFields=j(c);for(const[d,l]of u._documentIds)u._idToShortId.set(l,d);for(const[d,l]of s){const m=new Map;for(const h of Object.keys(l)){let g=l[h];r===1&&(g=g.ds),m.set(parseInt(h,10),j(g))}u._index.set(d,m)}return u}static async loadJSAsync(t,e){const{index:s,documentIds:n,fieldLength:i,storedFields:c,serializationVersion:r}=t,u=this.instantiateMiniSearch(t,e);u._documentIds=await P(n),u._fieldLength=await P(i),u._storedFields=await P(c);for(const[l,m]of u._documentIds)u._idToShortId.set(m,l);let d=0;for(const[l,m]of s){const h=new Map;for(const g of Object.keys(m)){let f=m[g];r===1&&(f=f.ds),h.set(parseInt(g,10),await P(f))}++d%1e3===0&&await yt(0),u._index.set(l,h)}return u}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:n,fieldIds:i,averageFieldLength:c,dirtCount:r,serializationVersion:u}=t;if(u!==1&&u!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const d=new A(e);return d._documentCount=s,d._nextId=n,d._idToShortId=new Map,d._fieldIds=i,d._avgFieldLength=c,d._dirtCount=r||0,d._index=new V,d}executeQuery(t,e={}){if(t===A.wildcard)return this.executeWildcardQuery(e);if(typeof t!="string"){const h={...e,...t,queries:void 0},g=t.queries.map(f=>this.executeQuery(f,h));return this.combineResults(g,h.combineWith)}const{tokenize:s,processTerm:n,searchOptions:i}=this._options,c={tokenize:s,processTerm:n,...i,...e},{tokenize:r,processTerm:u}=c,m=r(t).flatMap(h=>u(h)).filter(h=>!!h).map(ne(c)).map(h=>this.executeQuerySpec(h,c));return this.combineResults(m,c.combineWith)}executeQuerySpec(t,e){const s={...this._options.searchOptions,...e},n=(s.fields||this._options.fields).reduce((a,p)=>({...a,[p]:K(s.boost,p)||1}),{}),{boostDocument:i,weights:c,maxFuzzy:r,bm25:u}=s,{fuzzy:d,prefix:l}={...at.weights,...c},m=this._index.get(t.term),h=this.termResults(t.term,t.term,1,t.termBoost,m,n,i,u);let g,f;if(t.prefix&&(g=this._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,p=a<1?Math.min(r,Math.round(t.term.length*a)):a;p&&(f=this._index.fuzzyGet(t.term,p))}if(g)for(const[a,p]of g){const v=a.length-t.term.length;if(!v)continue;f==null||f.delete(a);const _=l*a.length/(a.length+.3*v);this.termResults(t.term,a,_,t.termBoost,p,n,i,u,h)}if(f)for(const a of f.keys()){const[p,v]=f.get(a);if(!v)continue;const _=d*a.length/(a.length+v);this.termResults(t.term,a,_,t.termBoost,p,n,i,u,h)}return h}executeWildcardQuery(t){const e=new Map,s={...this._options.searchOptions,...t};for(const[n,i]of this._documentIds){const c=s.boostDocument?s.boostDocument(i,"",this._storedFields.get(n)):1;e.set(n,{score:c,terms:[],match:{}})}return e}combineResults(t,e=et){if(t.length===0)return new Map;const s=e.toLowerCase(),n=te[s];if(!n)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(n)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const n={};for(const[i,c]of s)n[i]=Object.fromEntries(c);t.push([e,n])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,n,i,c,r,u,d=new Map){if(i==null)return d;for(const l of Object.keys(c)){const m=c[l],h=this._fieldIds[l],g=i.get(h);if(g==null)continue;let f=g.size;const a=this._avgFieldLength[h];for(const p of g.keys()){if(!this._documentIds.has(p)){this.removeTerm(h,p,e),f-=1;continue}const v=r?r(this._documentIds.get(p),e,this._storedFields.get(p)):1;if(!v)continue;const _=g.get(p),I=this._fieldLength.get(p)[h],T=se(_,f,this._documentCount,I,a,u),y=s*n*m*v*T,x=d.get(p);if(x){x.score+=y,oe(x.terms,t);const b=K(x.match,e);b?b.push(l):x.match[e]=[l]}else d.set(p,{score:y,terms:[t],match:{[e]:[l]}})}}return d}addTerm(t,e,s){const n=this._index.fetch(s,lt);let i=n.get(t);if(i==null)i=new Map,i.set(e,1),n.set(t,i);else{const c=i.get(e);i.set(e,(c||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s)){this.warnDocumentChanged(e,t,s);return}const n=this._index.fetch(s,lt),i=n.get(t);i==null||i.get(e)==null?this.warnDocumentChanged(e,t,s):i.get(e)<=1?i.size<=1?n.delete(t):i.delete(e):i.set(e,i.get(e)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const n of Object.keys(this._fieldIds))if(this._fieldIds[n]===e){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${n}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,n){let i=this._fieldLength.get(t);i==null&&this._fieldLength.set(t,i=[]),i[e]=n;const r=(this._avgFieldLength[e]||0)*s+n;this._avgFieldLength[e]=r/(s+1)}removeFieldLength(t,e,s,n){if(s===1){this._avgFieldLength[e]=0;return}const i=this._avgFieldLength[e]*s-n;this._avgFieldLength[e]=i/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:n}=this._options;if(s==null||s.length===0)return;let i=this._storedFields.get(t);i==null&&this._storedFields.set(t,i={});for(const c of s){const r=n(e,c);r!==void 0&&(i[c]=r)}}}A.wildcard=Symbol("*");const K=(o,t)=>Object.prototype.hasOwnProperty.call(o,t)?o[t]:void 0,te={[et]:(o,t)=>{for(const e of t.keys()){const s=o.get(e);if(s==null)o.set(e,t.get(e));else{const{score:n,terms:i,match:c}=t.get(e);s.score=s.score+n,s.match=Object.assign(s.match,c),ut(s.terms,i)}}return o},[vt]:(o,t)=>{const e=new Map;for(const s of t.keys()){const n=o.get(s);if(n==null)continue;const{score:i,terms:c,match:r}=t.get(s);ut(n.terms,c),e.set(s,{score:n.score+i,terms:n.terms,match:Object.assign(n.match,r)})}return e},[Xt]:(o,t)=>{for(const e of t.keys())o.delete(e);return o}},ee={k:1.2,b:.7,d:.5},se=(o,t,e,s,n,i)=>{const{k:c,b:r,d:u}=i;return Math.log(1+(e-t+.5)/(t+.5))*(u+o*(c+1)/(o+c*(1-r+r*s/n)))},ne=o=>(t,e,s)=>{const n=typeof o.fuzzy=="function"?o.fuzzy(t,e,s):o.fuzzy||!1,i=typeof o.prefix=="function"?o.prefix(t,e,s):o.prefix===!0,c=typeof o.boostTerm=="function"?o.boostTerm(t,e,s):1;return{term:t,fuzzy:n,prefix:i,termBoost:c}},H={idField:"id",extractField:(o,t)=>o[t],tokenize:o=>o.split(re),processTerm:o=>o.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(o,t)=>{typeof(console==null?void 0:console[o])=="function"&&console[o](t)},autoVacuum:!0},at={combineWith:et,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:ee},ie={combineWith:vt,prefix:(o,t,e)=>t===e.length-1},Y={batchSize:1e3,batchWait:10},X={minDirtFactor:.1,minDirtCount:20},G={...Y,...X},oe=(o,t)=>{o.includes(t)||o.push(t)},ut=(o,t)=>{for(const e of t)o.includes(e)||o.push(e)},dt=({score:o},{score:t})=>t-o,lt=()=>new Map,j=o=>{const t=new Map;for(const e of Object.keys(o))t.set(parseInt(e,10),o[e]);return t},P=async o=>{const t=new Map;let e=0;for(const s of Object.keys(o))t.set(parseInt(s,10),o[s]),++e%1e3===0&&await yt(0);return t},yt=o=>new Promise(t=>setTimeout(t,o)),re=/[\n\r\p{Z}\p{P}]+/u,ce=async(o,t={})=>{const e=It(),{content:s}=e.public,{integrity:n,api:{baseURL:i},search:c}=s,{indexed:r}=c||{},u=`${i}/search${n?"-"+n:""}`;if(r){const{options:m}=c||{},{data:h}=await ct(u,{responseType:"text"},"$FfFMhtdBwd");if(!h.value)throw B({statusCode:500,message:"Missing search data"});return ae(o,h,m)}if(!t.miniSearch)throw B({statusCode:500,message:"Missing miniSearch options"});const{data:d}=await ct(u,"$h9PIItTUx0");if(!d.value)throw B({statusCode:500,message:"Missing search data"});return ue(o,d,t.miniSearch)},ae=(o,t,e)=>{const s=F(()=>A.loadJSON(z(t),z(e)));return F(()=>s.value.search(z(o)))},ue=function(o,t,e){const s=F(()=>new A(z(e)));return s.value.addAll(z(t)),F(()=>s.value.search(z(o)))},de={class:"z-search"},le={key:0,id:"z-search"},he={key:0,class:"no-result"},fe={key:1,ref:"list-result",class:"scrollcheck-y search-result"},me=ht({__name:"Search",props:{isOpening:{type:Boolean}},setup(o){const t=o,e=zt(),s=kt(),n=it();U(()=>t.isOpening,async f=>{var a;await Ft(),f&&((a=n.value)==null||a.select())});const{word:i,result:c}=Mt(s),r=it(0),u=Ct("list-result"),{data:d,execute:l,status:m}=Ut(i.value,()=>ce(i.value),{immediate:!1,transform:f=>f.value});Tt(i,()=>{r.value=0,i.value&&l()},{debounce:300}),U(()=>d.value,f=>{c.value=f}),U(r,(f,a)=>{var p,v;(p=c.value)!=null&&p.length&&(f<0||f>=((v=c.value)==null?void 0:v.length))&&(r.value=a)});function h(){var f;((f=u.value)==null?void 0:f.children[r.value]).scrollIntoView({behavior:"smooth",block:"nearest"})}function g(){var a;((a=u.value)==null?void 0:a.children[r.value]).dispatchEvent(new Event("click"))}return(f,a)=>{const p=Lt,v=Ht,_=Nt;return k(),L("div",de,[O(ot,null,{default:C(()=>[f.isOpening?(k(),L("div",{key:0,id:"z-search-bgmask",onClick:a[0]||(a[0]=I=>w(e).toggle("search"))})):E("",!0)]),_:1}),O(ot,{name:"float-in"},{default:C(()=>[f.isOpening?(k(),L("div",le,[R("form",{class:Ot(["input",{searching:w(m)==="pending"}]),onSubmit:a[5]||(a[5]=J(()=>{},["prevent"]))},[O(p,{name:"ph:magnifying-glass-bold"}),Vt(R("input",{ref_key:"searchInput",ref:n,"onUpdate:modelValue":a[1]||(a[1]=I=>Et(i)?i.value=I:null),class:"search-input",placeholder:"键入开始搜索",onKeydown:[a[2]||(a[2]=rt(J(()=>{},["prevent"]),["up"])),a[3]||(a[3]=rt(J(()=>{},["prevent"]),["down"]))]},null,544),[[At,w(i)]]),w(i)?(k(),N(p,{key:0,class:"close",name:"ph:x-bold",onClick:a[4]||(a[4]=I=>i.value="")})):E("",!0)],34),O(Dt,{name:"expand"},{default:C(()=>{var I,T,y;return[w(i)&&w(m)==="success"&&!((I=w(c))!=null&&I.length)?(k(),L("div",he," 无结果 ")):E("",!0),w(i)&&((T=w(c))!=null&&T.length)?(k(),L("ol",fe,[(k(!0),L($t,null,Rt(w(c),(x,b)=>(k(),N(v,jt({key:x.id,ref_for:!0},x,{class:{active:w(r)===b},onClick:a[6]||(a[6]=$=>w(e).toggle("search")),onMouseover:$=>r.value=b}),null,16,["class","onMouseover"]))),128))],512)):E("",!0),w(i)&&((y=w(c))!=null&&y.length)?(k(),L("div",{key:2,class:"tip",onClick:a[10]||(a[10]=x=>{var b;return(b=w(n))==null?void 0:b.focus()})},[O(_,{code:"arrowup",onPress:a[7]||(a[7]=x=>(r.value--,h()))},{default:C(()=>a[11]||(a[11]=[M(" ↑ ")])),_:1}),a[15]||(a[15]=M()),O(_,{code:"arrowdown",onPress:a[8]||(a[8]=x=>(r.value++,h()))},{default:C(()=>a[12]||(a[12]=[M(" ↓ ")])),_:1}),a[16]||(a[16]=M(" 切换  ")),O(_,{code:"enter",onPress:g},{default:C(()=>a[13]||(a[13]=[M(" Enter ")])),_:1}),a[17]||(a[17]=M(" 选择  ")),O(_,{code:"escape",onPress:a[9]||(a[9]=x=>w(e).toggle("search"))},{default:C(()=>a[14]||(a[14]=[M(" Esc ")])),_:1}),a[18]||(a[18]=M(" 关闭 "))])):E("",!0)]}),_:1})])):E("",!0)]),_:1})])}}}),xe=ft(me,[["__scopeId","data-v-3e2b4e2c"]]);export{xe as default};
