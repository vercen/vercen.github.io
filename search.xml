<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器常用操作整理</title>
      <link href="/2023/08/25/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/08/25/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="非侵入式的微服务"><a href="#非侵入式的微服务" class="headerlink" title="非侵入式的微服务"></a>非侵入式的微服务</h1><h1 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h1><ol><li>了解非侵入式以及侵入式微服务的概念</li><li>了解k8s相关的知识</li><li>了解istio的相关知识</li></ol><h1 id="预习内容"><a href="#预习内容" class="headerlink" title="预习内容"></a>预习内容</h1><ul><li>Spring Cloud <a href="http://c.biancheng.net/springcloud/micro-service.html">http://c.biancheng.net/springcloud/micro-service.html</a></li><li>k8s: <a href="https://www.kubernetes.org.cn/doc-11">https://www.kubernetes.org.cn/doc-11</a></li><li>istio <a href="https://istio.io/latest/zh/docs/">https://istio.io/latest/zh/docs/</a></li></ul><h1 id="上课准备"><a href="#上课准备" class="headerlink" title="上课准备"></a>上课准备</h1><p>git地址： <a href="http://120.92.88.48/luanmengjun/weifuwuday4">http://120.92.88.48/luanmengjun/weifuwuday4</a></p><h1 id="3-非侵入式的微服务"><a href="#3-非侵入式的微服务" class="headerlink" title="3.非侵入式的微服务"></a>3.非侵入式的微服务</h1><h2 id="3-1-代码的侵入式跟非侵入式的介绍"><a href="#3-1-代码的侵入式跟非侵入式的介绍" class="headerlink" title="3.1 代码的侵入式跟非侵入式的介绍"></a>3.1 代码的侵入式跟非侵入式的介绍</h2><p>​      侵入式和非侵入式是两种不同的设计思想，通常用来描述软件框架或者组件对应用程序的影响程度。</p><p>​      从代码的角度来说，侵入性强指的是耦合太强了，大多数代码表现为对框架类的继承，这样固然会可以利用框架的便利带来便利的功能，但是，重构就会带来非常痛苦的体验。非侵入式，主要是指未引入框架，这样的好处是可以提现高内聚，低耦合，但是在框架类提供的便利方法也无法实现。以下我们来具体看看两者在代码方面的区别。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NDlmNjlhNDJmMGM5YTk2ZjY0OTUyYjExYjAwYmVjMjNfSkk3d29NVmtjUVY3MTNmMkdGMmRTWnNWVkNSRWp4MFpfVG9rZW46UFpKZ2IzSkxIb2ZOcjR4QWFyR2MzT2p4bkZiXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><ul><li><strong>侵入式的设计</strong></li></ul><p>​      侵入式的设计，就是设计者将框架或者组件的功能“推”给应用程序，要求应用程序必须遵循框架或者组件的规范，修改或者依赖应用程序的代码，才能使用框架或者组件的功能。例如，Java 中的继承，必须显示地表明要继承哪个接口，才能拥有接口的一些功能。</p><p>​      Struts1代码实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> //该RegisterAction是由Struts1来调用，Struts1会调用它的execute方法处理请求</span><br><span class="line">public class RegisterAction extends Action &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request,</span><br><span class="line">                        HttpServletResponse response) throws Exception &#123;</span><br><span class="line">                RegisterFormBean registerForm = (RegisterFormBean) request.getAttribute(&quot;registerForm&quot;);</span><br><span class="line">                String username = registerForm.getUsername();</span><br><span class="line">                String password = registerForm.getPassword();</span><br><span class="line">                String email = registerForm.getEmail();</span><br><span class="line">                try &#123;</span><br><span class="line">                        System.out.println(&quot;向数据库中注册&quot; + username + &quot;用户&quot;);</span><br><span class="line">                        request.setAttribute(&quot;message&quot;, &quot;注册成功！！&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                        request.setAttribute(&quot;message&quot;, &quot;注册失败！！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                return mapping.findForward(&quot;message&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  参考资料：<a href="https://struts.apache.org/getting-started/">https://struts.apache.org/getting-started/</a></p><ul><li><strong>非侵入式的设计</strong></li></ul><p>​      非侵入式的设计，就是设计者将应用程序的功能“拿”到框架或者组件中用，不要求应用程序修改或者依赖框架或者组件的代码，而是通过反射、代理、注解等技术，实现对应用程序的增强或者隔离。例如，Go 中的接口，不需要显示地继承接口，只需要实现接口的所有方法就叫实现了该接口，即便该接口删掉了，也不会影响应用程序。</p><p>​      我们可以对比一下java跟go的接口的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (k *KceOpenapi) CreateCluster(ctx context.Context, req interface&#123;&#125;) (res *dto.CreateClusterRes, err error) &#123;</span><br><span class="line">   resp, err := k.doRequest(ctx, consts.CreateCluster, req)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return nil, err</span><br><span class="line">   &#125;</span><br><span class="line">   if err = gconv.Struct(resp.ReadAll(), &amp;res); err != nil &#123;</span><br><span class="line">      return nil, err</span><br><span class="line">   &#125;</span><br><span class="line">   return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go的interface参考资料：<a href="https://blog.csdn.net/yuqiang870/article/details/124746693">https://blog.csdn.net/yuqiang870/article/details/124746693</a></p><ul><li><strong>侵入式的优缺点</strong></li></ul><p>优点：通过侵入代码与你的代码结合可以更好的利用侵入代码提供给的功能。 缺点：框架外代码就不能使用了，不利于代码复用。依赖太多重构代码太痛苦了。</p><ul><li><strong>非侵入式的优缺点</strong></li></ul><p>优点：代码可复用，方便移植。非侵入式也体现了代码的设计原则：高内聚，低耦合。 缺点：无法复用框架提供的代码和功能。</p><p><strong>微服务从侵入式到非侵入式</strong></p><p>​       在前面我们从代码的角度的去探究了侵入式与非侵入式，现在我们从微服务的角度来看看，什么是侵入式的微服务，什么是非侵入式的。</p><p>​       目前主流的微服务框架如springCloud，基本都要求开发者在微服务框架本身的代码上进行开发，代码非常依赖框架，导致如果更换框架，就需要修改代码，并且，微服务之间的耦合度较高，这种就属于侵入式的框架，导致其可移植性以及可维护性都很低。随着云原生技术的发展，服务网格的概念兴起了，这是一种侵入式的框架，开发者在这个框架下不需要再引入框架代码，同时只需进行简单的配置就可以实现微服务的注册、发现、通信和治理等基本功能。大大提高了代码的可移植性，并与云原生技术紧密结合，可以轻松的在云上进行部署，是未来微服务的发展方向。</p><h2 id="3-2-主流侵入式微服务框架的介绍"><a href="#3-2-主流侵入式微服务框架的介绍" class="headerlink" title="3.2 主流侵入式微服务框架的介绍"></a>3.2 主流侵入式微服务框架的介绍</h2><p>​      侵入式设计，就是设计者将框架功能“推”给客户端，要求客户端的代码“知道”框架的代码，表现为客户端代码需要继承或引用框架提供的类或接口。目前主流的侵入式框架主要有springCloud、Dobbo以及Apache ServiceComb，以下为一一对其进行介绍：</p><h3 id="3-2-1-Spring-Cloud"><a href="#3-2-1-Spring-Cloud" class="headerlink" title="3.2.1 Spring Cloud"></a>3.2.1 <strong>Spring Cloud</strong></h3><p>​      Spring Cloud是一个基于Spring Boot的微服务开发框架，提供了一系列的工具和组件，用于快速构建分布式系统中的常见模式，例如配置管理、服务发现、断路器、智能路由、微代理、控制总线等。</p><p>​      Spring Cloud的核心特点是提供了统一的配置中心、注册中心和网关等基础设施，使得微服务之间可以轻松地进行通信和协作，同时也提供了分布式锁、领导选举、分布式会话、集群状态等高级功能。</p><p>​      Spring Cloud支持多种主流的微服务框架，例如Spring Cloud Netflix、Spring Cloud Alibaba、Spring Cloud Kubernetes等。其优势在于提供了成熟和完善的微服务开发和运维方案，支持多语言和多运行时，有丰富的社区和文档支持。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM0NWU0NmVjMGRhOGQ4OWIwY2VkNmVlYWMyZjRmMGZfSTdUOWZJR2pNY0ppSWZSZDJlTFN4bDE1dW85d2VYaTFfVG9rZW46UFBtQmJVWGtNbzNoNG14NmQ4eWNydWcwbkhmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​     </p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ5NGVlNTgyZDRmMmNmNjc3ZGE0ZmFjY2ZkMmRjZDlfR09EUGtTVmVDMDZMUjFNOHdjWkxHdDBPWHVtTFlVNE1fVG9rZW46Uzl2RGJZMG8zb0ROY0V4MVk5Z2NPb3ZqbkVjXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>bootAdmin：<a href="https://blog.csdn.net/zouliping123456/article/details/121977792">https://blog.csdn.net/zouliping123456/article/details/121977792</a></p><p>turbine：<a href="https://blog.csdn.net/weixin_30783629/article/details/95431381">https://blog.csdn.net/weixin_30783629/article/details/95431381</a></p><p>sleuth：<a href="https://www.cnblogs.com/qdhxhz/p/14781887.html">https://www.cnblogs.com/qdhxhz/p/14781887.html</a></p><p>Cloud stream：<a href="https://blog.csdn.net/Dhjie_king/article/details/117416359">https://blog.csdn.net/Dhjie_king/article/details/117416359</a></p><p>zipkin：<a href="https://blog.csdn.net/qq924862077/article/details/80285536">https://blog.csdn.net/qq924862077/article/details/80285536</a></p><p>cloudTask：<a href="https://blog.51cto.com/u_15326439/5911294">https://blog.51cto.com/u_15326439/5911294</a></p><p>ELK：<strong>Elasticsearch, Logstash, Kibana</strong></p><p>​    Spring Cloud的主要特点有如下几个方面：</p><ul><li>Spring Cloud拥有强大的社区支持和丰富的教程资源。</li><li>Spring Cloud采用了 Spring Boot 的约定优于配置的理念，简化了开发和配置的复杂度，提高了开发效率和可维护性。</li><li>Spring Cloud集成了多种 Netflix OSS 和 Alibaba Cloud 的开源组件，提供了服务注册与发现、配置中心、服务网关、负载均衡、熔断降级、分布式事务、分布式消息等功能，覆盖了微服务架构的各个方面。</li><li>Spring Cloud支持多种编程语言和存储技术，可以实现跨平台的服务通信和数据交互。</li><li>Spring Cloud适应了互联网时代需求，可以实现快速迭代、持续交付、动态扩缩容等能力，提高了系统的可用性和可靠性。</li></ul><h3 id="3-2-2-spring-cloud-侵入性"><a href="#3-2-2-spring-cloud-侵入性" class="headerlink" title="3.2.2 spring cloud 侵入性"></a>3.2.2 spring cloud 侵入性</h3><p>​       在介绍了spring cloud之后，我们以一个非常简单的微服务为例来看看，springCloud的侵入性主要体现在那些方面：</p><p>​     </p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZiY2Y2ODdkMmM1Nzg2YzNhNTU2NjcwN2ZkODM3MDlfenJhRzFydHE2Z0RRVHdWUUVydjUyUWFIVjlxVzFpN1lfVG9rZW46UmtsdGIyckVCbzlYbzh4R3d3a2M2c1NBbk1nXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>consumer代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TestController</span><span class="params">(RestTemplate restTemplate)</span> &#123;<span class="built_in">this</span>.restTemplate = restTemplate;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@RequestMapping(value = &quot;/echo/&#123;str&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">echo</span><span class="params">(<span class="meta">@PathVariable</span> String str)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://service-provider/echo/&quot;</span> + str, String.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>  provide代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EchoController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(value = &quot;/echo/&#123;string&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">echo</span><span class="params">(<span class="meta">@PathVariable</span> String string)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;receive msg: &#123;&#125;&quot;</span>, string);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello Discovery &quot;</span> + string;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>侵入性的体现</strong></li></ul><p>​     1.spring Cloud 是通过maven依赖的方式引入的，在打包时，会依赖对应的库，需要程序员考虑maven包之间的依赖以及版本匹配问题。</p><p>​     2.业务代码与非业务代码在项目里时融合在一起的，很难进行完整的区分，导致业务可能因为非业务代码的原因出现问题。</p><p>​     3.使用不同语言进行微服务开发时，需要针对不同的情况进行适配以及修改。</p><ul><li><strong>侵入式引发的问题</strong></li></ul><p>​     1.语言的问题：springCloud 主要使用java语言，当微服务中其他服务使用其他语言时，会提高整体微服务的学习成本，如何将其他服务融入当前框架中。</p><p>​    2.组件的使用：虽然springCloud提供了非常多很好用的组件，但是这些组件都是通过maven仓库依赖的方式引入的，这些组件的升级以及跟微服务的版本的匹配问题会同时引入到项目中，成为程序员在业务代码逻辑之外需要考虑的额外问题。</p><p>​    3.学习成本的问题：springCloud全家桶的功能虽然十分全面，但是，如果想具体用好每一个功能，都需要进行学习以及配置，对于应该专注与业务的程序员来说，学习成本还是偏高。</p><h2 id="3-3-侵入式微服务框架的优缺点"><a href="#3-3-侵入式微服务框架的优缺点" class="headerlink" title="3.3 侵入式微服务框架的优缺点"></a>3.3 <strong>侵入式微服务框架的优缺点</strong></h2><p>​       传统的侵入式微服务框架是指那些需要在业务代码中引入相关依赖或注解，或者需要遵循特定的编程模型或规范的微服务框架。例如，Spring Cloud、Dubbo、brpc等都属于侵入式微服务框架。它们的特点和优缺点如下：</p><ul><li>特点：<ul><li>提供了丰富的功能和组件，如服务发现、配置中心、负载均衡、熔断器、网关等</li><li>有成熟的社区和文档支持，易于学习和使用</li><li>有较高的性能和稳定性，适合高并发场景</li></ul></li><li>优点：<ul><li>降低了微服务开发的复杂度，提高了开发效率</li><li>规范和统一了微服务间的调用方式，方便了服务治理</li><li>有利于代码重用和复用，减少了冗余代码</li></ul></li><li>缺点：<ul><li>增加了业务代码的耦合度，降低了灵活性和可移植性</li><li>需要适应框架的约束和限制，不能随意更换或升级框架</li><li>难以适应云原生技术的变化和发展，需要额外的适配和对接</li></ul></li></ul><h2 id="3-4-非侵入式微服务框架的演化以及概念"><a href="#3-4-非侵入式微服务框架的演化以及概念" class="headerlink" title="3.4 非侵入式微服务框架的演化以及概念"></a>3.4 非侵入式微服务框架的演化以及概念</h2><p>​     非侵入的微服务框架是指不需要对现有的服务代码做任何修改，就可以实现微服务的注册、发现、调用等功能的框架。比如，将服务注册和服务调用从现有服务中抽离出来，形成一个服务代理。这样可以降低微服务的开发和维护成本，提高微服务的可扩展性和可靠性。</p><h3 id="3-4-1-非侵入式框架的设计原理"><a href="#3-4-1-非侵入式框架的设计原理" class="headerlink" title="3.4.1 非侵入式框架的设计原理"></a>3.4.1 <strong>非侵入式框架的设计原理</strong></h3><p>非侵入式设计是一种编程方式，它采用组合或实现的方式使类和类之间弱耦合，从而提高灵活性。非侵入式设计，就是设计者将客户端的功能“拿”到框架中用，不需要客户端的代码引入或继承框架的代码，表现为客户端代码只需要实现框架提供的接口。</p><h3 id="3-4-2-微服务框架的演变"><a href="#3-4-2-微服务框架的演变" class="headerlink" title="3.4.2 微服务框架的演变"></a>3.4.2 <strong>微服务框架的演变</strong></h3><h4 id="3-4-2-1-小型机时代"><a href="#3-4-2-1-小型机时代" class="headerlink" title="3.4.2.1 小型机时代"></a><strong>3.4.2.1 小型机时代</strong></h4><p>第一个计算机网络诞生于1969年，也就是美军的阿帕网，阿帕网能够实现与其它计算机进行联机操作，但是早期仅仅是为了军事目的而服务</p><p>2000年初，中国的网民大约890万，很多人都不知道互联网为何物，因此大多数服务业务单一且简单，采用典型的单机+数据库模式，所有的功能都写在一个应用里并进行集中部署</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjY4YjI0MzczZGExMjQzNTg5YzVmODM2MmU4Nzc4NzBfa0hiVTU1ekdmZk1mM0xTaDdFdXZ1ekJENG9SbmVVU0JfVG9rZW46WDU3UmJ5SXM0b3lqR3d4cTlaRGNBWExrbkNmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​       最古早的架构，简单的单机+数据库模型，所有功能全部在一个应用里面。</p><h4 id="3-4-2-2-垂直拆分"><a href="#3-4-2-2-垂直拆分" class="headerlink" title="3.4.2.2 垂直拆分"></a><strong>3.4.2.2 垂直拆分</strong></h4><p>随着应用的日益复杂与多样化，开发者对系统的容灾，伸缩以及业务响应能力有了更高的要求，如果小型机和数据库中任何一个出现故障，整个系统都会崩溃，若某个板块的功能需要更新，那么整个系统都需要重新发布，显然，对于业务迅速发展的万物互联网时代是不允许的。</p><p>如何保障可用性的同时快速响应业务的变化，需要将系统进行拆分，将上面的应用拆分出多个子应用。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=OTIzYzI4ZDZiNzY1ZjU5MWVkZTc2MmFiNzIyOTM5ZGJfQ2hBNlZpdGhseFIwZDRORjJhNG5uZWNlSEpFaWRGdFdfVG9rZW46WkJzM2JDcUZxb2l0M1p4MjNuc2NCZEZKbkJmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p> 优点：应用跟应用解耦，系统容错提高了，也解决了独立应用发布的问题</p><p> 应用垂直拆分解决了应用发布的问题，但是随着用户数量的增加，单机的计算能力依旧是杯水车薪、</p><h4 id="3-4-2-3-集群化负载均衡架构"><a href="#3-4-2-3-集群化负载均衡架构" class="headerlink" title="3.4.2.3 集群化负载均衡架构"></a><strong>3.4.2.3 集群化负载均衡架构</strong></h4><p>用户量越来越大，就意味着需要更多的小型机，但是小型机价格昂贵，操作维护成本高。</p><p>此时更优的选择是采用多台PC机部署同一个应用的方案，但是此时就需要对这些应用做负载均衡，因为客户端不知道请求会落到哪一个后端PC应用上的。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUyNDVhNmRiN2M1N2Q5MDUzZGRkZDZkZWRlZDRhZjhfaWJlYUtKbERIMWF6RDZDaE9jbW1kZkdPbms5SUYzU1VfVG9rZW46RkM3ZWJKNGZ6b1NCN1J4SGV0WmNwQmVLbm5jXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>负载均衡的思想：对外暴露一个统一的接口，根据用户的请求进行对应规则转发，同时负载均衡还可以做限流等等</p><p>有了负载均衡之后，后端的应用可以根据流量的大小进行动态扩容，我们称为”水平扩展”</p><p>优点：应用跟应用解耦，系统容错提高了，也解决了独立应用发布的问题，同时可以水平扩展来提供应用的并发量</p><h4 id="3-4-2-4-服务化改造架构"><a href="#3-4-2-4-服务化改造架构" class="headerlink" title="3.4.2.4 服务化改造架构"></a><strong>3.4.2.4 服务化改造架构</strong></h4><p>虽然系统经过了垂直拆分，但是拆分之后发现在论坛和聊天室中有重复的功能，比如，用户注册、发邮件等等，一旦项目大了，集群部署多了，这些重复的功能无疑会造成资源浪费，所以会把重复功能抽取出来，名字叫”XX服务（Service）”</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY4NTEzZTRjM2NlMWQ4ODE1NmIxYzc3OTU2YzYyZTZfZnpBTVRiVHRKTW1idlhHamcxMVBjRTNHZVVIdlFwdmpfVG9rZW46SmkzdGJQOFdWb3pidWZ4WllSTWNLWGF0bjg1XzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>为了解决服务跟服务如何相互调用，需要一个程序之间的通信协议，所以就有了远程过程调用（RPC），作用就是让服务之间的程序调用变得像本地调用一样的简单</p><p>优点：在前面的架构之上解决了业务重用的问题</p><h4 id="3-4-2-5-服务治理与微服务架构"><a href="#3-4-2-5-服务治理与微服务架构" class="headerlink" title="3.4.2.5 服务治理与微服务架构"></a><strong>3.4.2.5 服务治理与微服务架构</strong></h4><p>服务治理要求：</p><p> 1、当我们服务节点数几十上百的时候，需要对服务有动态的感知，引入了注册中心</p><p> 2、当服务链路调用很长的时候如何实现链路的监控</p><p> 3、单个服务的异常，如何能避免整条链路的异常（雪崩），需要考虑熔断、降级、限流</p><p> 4、服务高可用：负载均衡</p><ul><li><strong>微服务时代：</strong></li></ul><p>​     </p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MzVlODBhNWVjZjAwMjhiODJjMWI5ZjFlNmY5MGQ1Y2FfRGZzNVlzcEFFZHhzbGRKM0pyZUVZUHB2QWs5bUh1U0VfVG9rZW46VGhjRGJRTGlZb1Y3alR4ZlNoY2NBS1hwbnhmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​     微服务是在2012年提出的概念，微服务的希望的重点是一个服务只负责一个独立的功能。</p><p>拆分原则，任何一个需求不会因为发布或者维护而影响到不相关的服务，一切可以做到独立部署运维。</p><p>比如传统的“用户中心”服务，对于微服务来说，需要根据业务再次拆分，可能需要拆分成“买家服务”、“卖家服务”、“商家服务”等。</p><p>​      典型代表：Spring Cloud，相对于传统分布式架构，SpringCloud使用的是HTTP作为RPC远程调用，配合上注册中心Eureka和API网关Zuul，可以做到细分内部服务的同时又可以对外暴露统一的接口，让外部对系统内部架构无感，此外Spring Cloud的config组件还可以把配置统一管理。</p><ul><li><strong>微服务时代的问题</strong></li></ul><p>（1）最初是为了业务而写代码，比如登录功能、支付功能等，到后面会发现要解决网络通信的问题，虽然有 Spring Cloud里面的组件帮我们解决了，但是细想一下它是怎么解决的？在业务代码里面加上spring cloud maven依赖，加上spring cloud组件注解，写配置，打成jar的时候还必须要把非业务的代码也要融合在一起，称为“侵入式框架”； </p><p>（2）微服务中的服务支持不同语言开发，也需要维护不同语言和非业务代码的成本； </p><p>（3）业务代码开发者应该把更多的精力投入到业务熟悉度上，而不应该是非业务上，Spring Cloud虽然能解决微服务领域的很多问题，但是学习成本还是较大的；  </p><p>（4）互联网公司产品的版本升级是非常频繁的，为了维护各个版本的兼容性、权限、流量等，因为Spring </p><p>Cloud是“代码侵入式的框架”，这时候版本的升级就注定要让非业务代码一起，一旦出现问题，再加上多语言之间的调用，工程师会非常痛苦； </p><p>（5）其实我们到目前为止应该感觉到了，服务拆分的越细，只是感觉上轻量级解耦了，但是维护成本却越高了，那么怎么 办呢？</p><h4 id="3-4-2-6-新时代的非侵入式服务网格架构"><a href="#3-4-2-6-新时代的非侵入式服务网格架构" class="headerlink" title="3.4.2.6 新时代的非侵入式服务网格架构"></a>3.4.2.6 新时代的非侵入式服务网格架构</h4><p>​    服务网格：指的是微服务网络应用之间的交互，随着规模和复杂性增加，服务跟服务调用错综复杂</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MzZhZWYyOTY3YWViNWU4ZDZhMjQyYmU0OGU5ZTI1ODlfV3NXUnRkbU9LYjM2YUNvNXRQaHNQTlZubnd2NVpZbnFfVG9rZW46WGFESmJsZVRqb3ZzSDh4eXl6OGMzTWszbjJmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​      特点：</p><p> 基础设施：服务网格是一种处理服务之间通信的基础设施层。</p><p> 支撑云原生：服务网格尤其适用于在云原生场景下帮助应用程序在复杂的服务间可靠地传递请求。</p><p> 网络代理：在实际使用中，服务网格一般是通过一组轻量级网络代理来执行治理逻辑的。</p><p> 对应用透明：轻量网络代理与应用程序部署在一起，但应用感知不到代理的存在，还是使用原来的方式工作。</p><h3 id="3-4-3-非侵入式微服务框架的优缺点"><a href="#3-4-3-非侵入式微服务框架的优缺点" class="headerlink" title="3.4.3 非侵入式微服务框架的优缺点"></a>3.4.3 <strong>非侵入式微服务框架的优缺点</strong></h3><p>​      非侵入式微服务架构是指那些不需要在业务代码中引入相关依赖或注解，或者不需要遵循特定的编程模型或规范的微服务架构。例如，Service Mesh、Cilium等都属于非侵入式微服务架构。它们的特点和优缺点如下：</p><ul><li>特点：<ul><li>提供了代码无侵入、代理透明、开发运维分离等优势</li><li>有利于提高微服务的灵活性和可移植性</li><li>有利于适应云原生技术的变化和发展</li></ul></li><li>优点：<ul><li>降低了微服务开发的复杂度，减少了代码耦合</li><li>规范和统一了微服务间的调用方式，方便了服务治理</li><li>有利于提高微服务的性能和稳定性，减少资源消耗</li></ul></li><li>缺点：<ul><li>增加了微服务部署和管理的难度，需要额外的工具和平台支持</li><li>需要适应新的技术栈和架构模式，有一定的学习成本</li><li>难以保证微服务间的数据一致性和事务性</li></ul></li></ul><h2 id="3-5-主流非侵入式微服务框架简介"><a href="#3-5-主流非侵入式微服务框架简介" class="headerlink" title="3.5 主流非侵入式微服务框架简介"></a>3.5 主流非侵入式微服务框架简介</h2><p>非侵入式的微服务框架跟云原生结合比较紧密，由于无论什么项目，都需要落地在云原生上，因此，为了更好的适合云原生，很多基于云原生的非侵入式框架都发展出来了，以下会为大家介绍一些目前主流的非侵入式的框架</p><h3 id="3-5-1-Service-Mesh-的背景"><a href="#3-5-1-Service-Mesh-的背景" class="headerlink" title="3.5.1 Service Mesh 的背景"></a>3.5.1 <strong>Service Mesh 的背景</strong></h3><p>​     Service Mesh的思想是将服务间通信的处理从应用层下沉到基础设施层，通过一组轻量级的网络代理（Sidecar）来实现服务间的可靠、安全、可观测的通信，而不需要应用感知。Service Mesh可以为微服务架构提供流量控制、策略、网络安全和可观测性等功能，并解决传统微服务框架的侵入性、多语言支持和老旧系统维护等问题。Service Mesh是一种适应云原生应用的新一代微服务架构。</p><p>​     想要了解Service mesh，必须了解其是如何演化的，这里参考<a href="https://link.zhihu.com/?target=http://philcalcado.com/">Phil Calçado</a>的文章<a href="https://link.zhihu.com/?target=http://philcalcado.com/2017/08/03/pattern_service_mesh.html">《Pattern: Service Mesh》</a>让大家可以更好的理解，下面我们将从服务间通讯的角度来说明，服务网格为何需要出现：</p><p>​    太初之时：不同的服务之间互相通信，抽象如下</p><p>​    </p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=YTY4NDRjMTlhMzYwZDZkNWY5YmU0ZDIzMGUxMjM5MTdfZVppcTRYMk96NnloYW9ZeVY1NXFONEEzbThubG94M2tfVG9rZW46R1ZFZmJ1R0Npb1doOWt4bUlYTGNCSTFlbnZnXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p><strong>原始时代</strong>：然而现实远比想象的复杂，在实际情况中，通信需要底层能够传输字节码和电子信号的物理层来完成，在TCP协议出现之前，服务需要自己处理网络通信所面临的丢包、乱序、重试等一系列流控问题，因此服务实现中，除了业务逻辑外，还夹杂着对网络传输问题的处理逻辑。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWY5YTIzNDZhMDY4MTgyY2UxMTEwMDhkNjU3MWFhYTVfVTJMZ1g5UG5pd0tWQ2VzY3QxZWpiMmlTa0xCU3RXYXBfVG9rZW46WUZXVGJYTmw4bzRqVG14aXNhTmNxd0lZbm9mXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>   <strong>Tcp时代</strong>：为了避免每个服务都需要自己实现一套相似的网络传输处理逻辑，TCP协议出现了，它解决了网络传输中通用的流量控制问题，将技术栈下移，从服务的实现中抽离出来，成为操作系统网络层的一部分。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM2MmFmMDMyODAxOWY5YjFkNzZlNTczZGUwNjI0N2JfbXQwck1NdHMwQllOMjJ3SE1oT3NWeVVWODRobDVBUnlfVG9rZW46SGRHVmJkbVhwb0RqTW94NzFtd2NMQXpZblFiXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​      </p><p>网络七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p> <strong>第一代微服务时代</strong>：在TCP出现之后，机器之间的网络通信不再是一个难题，这时分布式系统的微服务架构出现了。同时，为了解决分布式特有的通信问题，如熔断策略、负载均衡、服务发现、认证和授权、quota限制、trace和监控等等，微服务需要统一一套自己的通信语义，这样就产生了面向服务的微服务开发框架，如springcloud，这些框架实现了分布式系统通信需要的各种通用语义功能：如负载均衡和服务发现等，因此一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NmMxZWY4NDQ3OTAzN2IxMmMwMzNjNWRiM2EzNzM3MGVfZDBNTWJyeEs2TzczN0dvdEZzUTNpQ3BZWDZ2amc4S0pfVG9rZW46VjYweWJKelZlb1BCbjB4TWNlR2N4T2xpbmNoXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p> <strong>第二代微服务时代：</strong>为了避免每个服务都需要自己实现一套分布式系统通信的语义功能，随着技术的发展，一些面向微服务架构的开发框架出现了，如Twitter的<a href="https://link.zhihu.com/?target=https://finagle.github.io/">Finagle</a>、Facebook的<a href="https://link.zhihu.com/?target=https://code.facebook.com/posts/1503205539947302">Proxygen</a>以及Spring Cloud等等，这些框架实现了分布式系统通信需要的各种通用语义功能：如负载均衡和服务发现等，因此一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY4Njk0Yzc2NTIzZjU5ZDJjNDg2NjFlOTFiMGUxMmNfdkg0NVc5V0x1RzU1R245ekdoWHZmQmJaUXNtZ3RKSUFfVG9rZW46TVZyTmIwY3N0b3RaMkN4eFF4emNTdU1UbkliXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p><strong>第一代服务网格时代</strong>：微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：</p><ul><li>其一，虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但开发者却要花更多精力去掌握和管理复杂的框架本身，在实际应用中，去追踪和解决框架出现的问题也绝非易事；</li><li>其二，开发框架通常只支持一种或几种特定的语言，回过头来看文章最开始对微服务的定义，一个重要的特性就是语言无关，但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系，想因地制宜的用多种语言实现架构体系中的不同模块也很难做到；</li><li>其三，框架以lib库的形式和服务联编，复杂项目依赖时的库版本兼容问题非常棘手，同时，框架库的升级也无法对服务透明，服务会因为和业务无关的lib库升级而被迫升级；</li></ul><p>​     因此以<strong>Linkerd，Envoy，NginxMesh</strong>为代表的代理模式（边车模式）应运而生，这就是第一代Service Mesh，它将分布式服务的通信抽象为单独一层，在这一层中实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能，作为一个和服务对等的代理服务，和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求，这样上边所说的三个问题也迎刃而解。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWUxNWFjMmVhNWNhZTY1ODJkYjIwZTE1NDAwYzNmZWZfUDI2bXduUmtzeER3UUJTeW9HdkVkZklPR1NaY2psRGZfVG9rZW46UHVDcWJmYTRhb2ZaWnB4VThIeGNBMTk2bmNnXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>如果我们从一个全局视角来看，就会得到如下部署图：</p><p>​     </p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M5OWExN2I3NmM3NDI0YTdiMjBjZDQzOGQ3MDY0MWVfRWtCUkt1bjJlTzIzcXlMcmFhVnJYdlNOdVI0Q2VPRWhfVG9rZW46TFRIMGJBZWIzb0hpbnd4dWY4RWNETlRqbnljXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><ul><li><strong>边车模式设计思想</strong></li></ul><p>​    边车（Sidecar）模式设计思想的核心是将控制和逻辑分离，常用于我们在分布式架构中的逻辑和控制分离设计。迁移到我们的分布式架构中就是：我们不需要在服务中实现控制面上的东西，如监视、日志记录、限流、熔断、服务注册、协议适配转换等这些属于控制面上的东西，而只需要专注地做好和业务逻辑相关的代码，然后，由“边车”来实现这些与业务逻辑没有关系的控制功能。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWU0ODRmZDlkM2MwYjRmMTE5YTk4NDIyZGUxZWY2NjBfNDhIWXROd1lMYjdEdmNFekhHTHh1Yk05dU9vUHpTUG5fVG9rZW46QVJNT2JtUHVEb1ZWYlV4UU1kN2NlbDhNbkZmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NjgwMDA4ODNiYTBmN2E2OTA3MmZiZTA4ODZiMWIxNWFfTndQVFNqTHVMRDZLMUFGdG1tNU1vTzFMSWx1THRtenpfVG9rZW46SVBBaGJGcE5nb0xhS1R4ZzhSc2NCRTVibmxmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​    </p><p>​      同样，sidecar独立运行的单机代理服务彼此建相对独立，缺乏一个对其进行统一管理的平台，也无法准确的监控不同sidecar的运行情况，因此，为了解决以上问题，出现了集中化的控制面板，所有的单机代理组件通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报。</p><h4 id="Linkerd设计思想"><a href="#Linkerd设计思想" class="headerlink" title="Linkerd设计思想"></a><strong>Linkerd设计思想</strong></h4><p>​      </p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNmMmZlZGI4YWFkY2U4YmM3MWQ2ODdlYjIzOGE3MjlfMjduMnM4VjlHUmo1VUN4dlF6ZjJqcVZYMUdvdHRoaFpfVG9rZW46UUJqdGJ1eEg2bzBhUld4ZDdGc2MyTUlPblFnXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​      </p><p>​     跟我们前面sidecar很类似，以前的调用方式都是服务来调用服务，在Linkerd思想要求所有的流量都走sidecar，Linkerd帮业务人员屏蔽了通信细节，通信不需要侵入到业务代码内部了，这样业务开发者就专注于业务开发的本身。Linkerd在面世之后，迅速获得用户的关注，并在多个用户的生产环境上成功部署、运行。2017年，Linkerd加入<a href="https://www.cncf.io/">CNCF</a>，随后宣布完成对千亿次生产环境请求的处理，紧接着发布了1.0版本，并且具备一定数量的商业用户，一时间风光无限，一直持续到Istio横空出世。</p><p><strong>问题:</strong> 在早期的时候又要部署服务，又要部署sidecar，对于运维人员来说比较困难的，所以没有得到很好的发展，其实主要的 问题是Linkerd只是实现了数据层面的问题，但没有对其进行很好的管理。 </p><ul><li><strong>第二代Service Mesh</strong></li></ul><p>​       第一代Service Mesh由一系列独立运行的单机代理服务构成，为了提供统一的上层运维入口，演化出了集中式的控制面板，所有的单机代理组件通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报。这就是以Istio为代表的第二代Service Mesh。</p><p>​     引入数据层面管理：</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=YTgyMGVkM2FmYmUxYmYyNTZmMjk1NzdhNmM0Mjc1YmVfa3FoQWlFdEZtMDNWMUVoUllBRXpDaVQzMFNUbExqVWZfVG9rZW46UXd1dGJUeWJLb1FSUnZ4aWxlUGMzc2JJbldlXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​     只看单机代理组件(数据面板)和控制面板的Service Mesh全局部署视图如下：</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=OWRiOTc4MDA1MGNhN2U3YTJiMjczZDE0YjFiNjFmNWJfc3Z2ZXB1RDdnb1JwdnJHYnlqZGUya3JleFFHd2hnRkJfVG9rZW46WE9tV2JXWTdCb2pKcFV4UWROVWNmOTZBbmljXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​      相信大家看过上面的技术演变后，一定能对服务网格（service mesh）有一个比较全面的了解，我们可以以其发明者Buoyant的CEO William Morgan对服务网格的概念做一个定义，也即是服务网格是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证请求在这些拓扑中可靠地穿梭。在实际应用当中，服务网格通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起，但对应用程序透明。 </p><p>​     总结一下，Service Mesh具有如下优点：</p><ul><li>屏蔽分布式系统通信的复杂性(负载均衡、服务发现、认证授权、监控追踪、流量控制等等)，服务只用关注业务逻辑；</li><li>真正的语言无关，服务可以用任何语言编写，只需和Service Mesh通信即可；</li><li>对应用透明，Service Mesh组件可以单独升级；</li></ul><p>当然，Service Mesh目前也面临一些挑战：</p><ul><li>Service Mesh组件以代理模式计算并转发请求，一定程度上会降低通信系统性能，并增加系统资源开销；</li><li>Service Mesh组件接管了网络流量，因此服务的整体稳定性依赖于Service Mesh，同时额外引入的大量Service Mesh服务实例的运维和管理也是一个挑战；</li></ul><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/61901608">https://zhuanlan.zhihu.com/p/61901608</a></p><h4 id="CNCF云原生组织发展跟介绍"><a href="#CNCF云原生组织发展跟介绍" class="headerlink" title="CNCF云原生组织发展跟介绍"></a>CNCF云原生组织发展跟介绍</h4><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNlNjY5YThhNjU3YWEzNmUyYzhkYjc1YWEwZGJiNmVfMThsc2VuNzJ1dzRFZ0RkWkN0Qnl6ajRZMkQwNWRocHZfVG9rZW46QVVuc2IydDFJb1JYaWp4Y0hNbWNrUnRubnliXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><ul><li>CNCF</li></ul><p>​     CNCF 是一个开源软件基金会，致力于使云原生计算具有普遍性和可持续性。 云原生计算使用开源软件技术栈将应用程序部署为微服务，将每个部分打包到自己的容器中，并动态编排这些容器以优化资源利用率。 云原生技术使软件开发人员能够更快地构建出色的产品。</p><ul><li>Kubernetes</li></ul><p>​    从2014年6月由Google宣布开源，到2015年7月发布1.0这个正式版本并进入CNCF基金会，再到2018年3月从CNCF基金会正式毕业，迅速成为容器编排领域的标准，是开源历史上发展最快的项目之一。也是世界上最受欢迎的容器编排平台也是第一个 CNCF 项目。</p><ul><li>Linkerd</li></ul><p>Scala语言编写，运行在JVM中，Service Mesh名词的创造者 </p><p>2016年01月15号，0.0.7发布 </p><p>2017年01月23号，加入CNCF组织 </p><p>2017年04月25号，1.0版本发布</p><ul><li>Istio</li></ul><p>Google、IBM、Lyft发布0.1版本</p><p>Istio是开源的微服务管理、保护和监控框架。Istio为希腊语，意思是”起航“。</p><ul><li>Prometheus</li></ul><p>Prometheus 为云原生应用程序提供实时监控、警报包括强大的查询和可视化能力，并与许多流行的开源数据导入、导出工具集成。</p><ul><li>Jaeger</li></ul><p> Jaeger 是由 Uber 开发的分布式追踪系统，用于监控其大型微服务环境。 Jaeger 被设计为具有高度可扩展性和可用性，它具有现代 UI，旨在与云原生系统（如 OpenTracing、Kubernetes 和 Prometheus）集成。</p><p>参考资料：<a href="https://www.cncf.io/">https://www.cncf.io/</a></p><h3 id="3-5-2-K8s"><a href="#3-5-2-K8s" class="headerlink" title="3.5.2 K8s"></a>3.5.2 K8s</h3><p>​     istio依托于k8s这个基础平台，因此在讲解istio之前，让我们一起简单了解一下什么是k8s。</p><p>​     k8s 通常被描述为一个容器编排（container orchestration）平台。</p><ul><li><strong>容器</strong></li></ul><p>​     容器提供了一个轻量级的机制来隔离应用程序的环境。对于一个给定的应用程序，我们可以指定其配置和所需要安装的依赖，而不用担心其与同一台物理机上其他的应用程序发生冲突。我们将每个应用程序封装在容器镜像（container image）中，容器镜像可以可靠地运行在任何机器（只要机器有能力运行容器镜像）上，能够提供可移植的能力，即支持应用开发到部署的平滑过渡。此外，因为每个应用是独立的，不用担心环境冲突，所以在同一台物理机上可以部署多个容器，实现更高的资源（内存和 CPU）利用率，最终降低成本。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MTJlYjdmOTlkNzE5YjkwYTUzMTBlNzljNWRhYjliYTlfRk1zSVpsQk1ITU1RTnJweHBHZEhWQUg2T2hRQW1MUUpfVG9rZW46WktMemJ5UDhrb0RFaTJ4d2owWWNNTjRHbkpYXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MzRiMmMwNWE5Y2Y5MzMyNGE2OTM0ZjhkYmMyZjA1MTRfUG1WOWdCQ0QxcXg4UzVadmJuQTN5dnQ0cDdETVlvRXZfVG9rZW46SzBQNmJnV0Nab3dNQ1N4UFJVaGNNbnhIbkdiXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2VlNzA0Mzk5YTExZDBhYWQzMjU3NWEzMjI0N2NiNWJfdVlNZWg4dEtadU45d1lKWnh6TU4xRU1laGdVa2VnYXNfVG9rZW46R0xXbmJSVDBCb3pYV0Z4Vnc5VmNFblRtbk1hXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>参考资料：<a href="https://blog.csdn.net/baidu_28340727/article/details/128430351">https://blog.csdn.net/baidu_28340727/article/details/128430351</a></p><ul><li><strong>容器中的问题</strong></li></ul><p>​     比如，你的容器挂掉了会发生什么？或者更糟糕，容器发生错误，又或者机器运行容器失败会发生什么？要知道，容器是没有容错（fault tolerance）的能力。或者你有多个容器需要通信，如何在容器之间建立通信网络？当你启动、终止单个容器时，这种情况会发生什么变化？容器网络很容易变成一团混乱。最后，假设你的生产环境有多个机器，你将如何抉择使用哪个机器运行你的容器？</p><p>​     k8s 管理着每个容器的全生命周期，如根据需要启动或停止容器。如果一个容器意外关闭，k8s 将会运行另一个容器快速代替它。除此之外，k8s 提供一种机制，可以让应用程序相互通信，即使在底层单个容器正在被创建或正在被销毁的时候。最后，给定要运行的一组容器和集群上的一组机器，k8s 检查每个容器并调度应用程序到最佳机器上。</p><ul><li><strong>k8s的基本架构</strong></li></ul><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ODhhZDQzNDVhZDk0OWJiMTUwNjkyOTc5ZmNjYWY0NDBfYnZjRXJrTnNoVXZGdGFRMXQ5bVFDMkQ4c0FjbXpMSGJfVG9rZW46QnRhcGJaMlJ0bzJ5RjN4SFJFZGN2MTlHbjhMXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><ul><li><strong>控制节点Master</strong></li></ul><p>​     K8S中的Master是集群控制节点，负责整个集群的管理和控制</p><p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制，其他模块通过API Server查询或修改数据，只有API Server才直接和etcd进行交互；</p><p><strong>Scheduler</strong> : 负责集群资源调度，通过API Server的Watch接口监听新建Pod副本信息，按照预定的调度策略将Pod调度到相应的node节点上；</p><p><strong>ControllerManager</strong> : K8S里所有资源对象的自动化控制中心，通过 api-server 提供的 restful 接口实时监控集群内每个资源对象的状态，发生故障时，导致资源对象的工作状态发生变化，就进行干预，尝试将资源对象从当前状态恢复为预期的工作状态，常见的 controller 有 Namespace Controller、Node Controller、Service Controller、ServiceAccount Controller、Token Controller、ResourceQuote Controller、Replication Controller等；</p><p><strong>Etcd</strong> ： 是Kubernetes的存储状态的数据库（所有master的持续状态都存在etcd的一个实例中）</p><ul><li><strong>工作节点Node</strong></li></ul><p>​     Node是K8S集群中的工作负载节点，每个Node都会被Master分配一些工作负载，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上</p><p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，控制Pod 的创建、启动、监控、重启、销毁等工作，处理Master节点下发到本节点的任务；</p><p><strong>KubeProxy</strong> : 负责制定数据包的转发策略，并以守护进程的模式对各个节点的pod信息实时监控并更新转发规则，service收到请求后会根据kube-proxy制定好的策略来进行请求的转发，从而实现负载均衡，总的来说，负责为Service提供cluster内部的服务发现和负载均衡；</p><p><strong>Docker</strong> : 负责节点上容器的各种操作；</p><h3 id="3-5-3-K8s的核心组成"><a href="#3-5-3-K8s的核心组成" class="headerlink" title="3.5.3 K8s的核心组成"></a><strong>3.5.3 K8s的核心组成</strong></h3><p>学习kubernetes的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源进行操作</p><p><strong>Pod</strong>： kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p><p><strong>Controller</strong>： 控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p><p><strong>Service</strong>： pod对外服务的统一入口，下面可以维护者同一类的多个pod</p><p><strong>Label</strong>： 标签，用于对pod进行分类，同一类pod会拥有相同的标签</p><p><strong>NameSpace</strong>： 命名空间，用来隔离pod的运行环境</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MGVhYWIwZjhjOWFmNjRlMmM0MWY2YjhmNWFlMzRkNDVfWk5UNmtHSGZPYlhqN3RmR2NtT1JwaGU2Yncwc0h6YzdfVG9rZW46SGxyRWJlSm1Bb1FJeVV4cEpIOWNQT0NKbk5oXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><ul><li><strong>K8s基本对象</strong></li></ul><p><strong>Pod</strong></p><p>Pod 对象是 k8s 中基础对象，由一个或多个（紧密相关）容器组成，并且这些容器共享网络和文件系统。类似于容器，Pod 被设计成拥有短暂的生命周期，不会期望特定的 Pod 长期存在。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NTdjMjU2YWEzNWUzZTBiZTljNjk0ZmRkYTU5YTA2ZjdfanN0RGhUTHN1aEFnbVd5YzNLMlRqQ0ZWYkxqRnU1QzVfVG9rZW46S1NZc2J2dEFPb0REdGV4Qzl0cWMyUjU1bkRjXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>通常你不会显示地通过清单文件创建 Pod 对象，因为使用更高级的对象管理 Pod 对象通常更简单。</p><p><strong>Deployment</strong></p><p>Deployment 对象包含由模板和副本数（要运行的模板数量）定义的 Pod 集合。你可以设置具体的副本数，也可以使用单独的 k8s 资源（如 HPA），基于系统性能指标如 CPU 使用率来控制副本数。</p><p>注意，Deployment 对象的控制器实际上会在背后创建 ReplicaSet 对象。然而，这对作为用户的你来说是抽象的。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NGU2N2Y2N2NlYTZjYmFlNmM2YTJmNWVkZDU1NmQ1ZWFfMW5vdDc0cm5yY21HVmYwRzBKMTBPU29DWXEzWEFjeEJfVG9rZW46UVl6cGJCTkdJb0twRE14ck9kRWNVWGxHbmliXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>虽然你不能依赖任何单一 Pod 永远的保持运行，但你可以依赖这样一个事实：集群总是能保证 n 个 Pod 运行中（其中 n 是你定义的副本数）。如果我们有一个 Deployment，其副本数为 10，并且其中 3 个 Pod 由于机器故障而崩溃，这 3 个 Pod 将会在集群中的其他机器上被调度运行起来。因此，Deployment 是最适合无状态应用程序使用，Pod 能够随时被替换而不破坏其他东西。</p><p>Deployment 还允许我们指定在拥有新的容器镜像时，我们希望如何进行更新。这篇<a href="https://link.zhihu.com/?target=https://blog.container-solutions.com/kubernetes-deployment-strategies">文章</a>很好地概述了不同操作选项。如果我们想覆盖默认值，我们可以在 Deployment 对象 <code>spec</code> 下附加一个 <code>strategy</code> 字段。 k8s 将确保优雅地关闭正在运行中的旧容器镜像的 Pod 并启动运行新容器镜像的新 Pod。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=M2QzNTVkMTM3N2JkN2JiMWYyZDcxZTFhZDExNTRkYzRfa29UYzQ3aExNWXF3QWhsUGM4VEN4QUE0ZWR0eEkwU3lfVG9rZW46Qkg1T2J0Q2pUb3ExUW54RXdSWmN4MG5lbjhmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>下面 的 YAML 文件提供了一个带有注释的示例，展示了如何定义 Deployment 对象。</p><p><strong>为了让 k8s 知道应用程序大概的负载，我们还应该在 Pod 模板清单中提供<strong><strong>资源限制</strong></strong>参数。</strong></p><ul><li><strong>deployment文件详解</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1  # 指定api版本，此值必须在kubectl api-versions中  </span><br><span class="line">kind: Deployment  # 指定创建资源的角色/类型   </span><br><span class="line">metadata:  # 资源的元数据/属性 </span><br><span class="line">  name: demo  # 资源的名字，在同一个namespace中必须唯一</span><br><span class="line">  namespace: <span class="keyword">default</span> # 部署在哪个namespace中</span><br><span class="line">  labels:  # 设定资源的标签</span><br><span class="line">    app: demo</span><br><span class="line">    version: stable</span><br><span class="line">spec: # 资源规范字段</span><br><span class="line">  replicas: <span class="number">1</span> # 声明副本数目</span><br><span class="line">  revisionHistoryLimit: <span class="number">3</span> # 保留历史版本</span><br><span class="line">  selector: # 选择器</span><br><span class="line">    matchLabels: # 匹配标签</span><br><span class="line">      app: demo</span><br><span class="line">      version: stable</span><br><span class="line">  strategy: # 策略</span><br><span class="line">    rollingUpdate: # 滚动更新</span><br><span class="line">      maxSurge: <span class="number">30</span>% # 最大额外可以存在的副本数，可以为百分比，也可以为整数</span><br><span class="line">      maxUnavailable: <span class="number">30</span>% # 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br><span class="line">    type: RollingUpdate # 滚动更新策略</span><br><span class="line">  template: # 模版</span><br><span class="line">    metadata: # 资源的元数据/属性 </span><br><span class="line">      annotations: # 自定义注解列表</span><br><span class="line">        sidecar.istio.io/inject: <span class="string">&quot;false&quot;</span> # 自定义注解名字</span><br><span class="line">      labels: # 设定资源的标签</span><br><span class="line">        app: demo</span><br><span class="line">        version: stable</span><br><span class="line">    spec: # 资源规范字段</span><br><span class="line">      containers:</span><br><span class="line">      - name: demo # 容器的名字   </span><br><span class="line">        image: demo:v1 # 容器使用的镜像地址   </span><br><span class="line">        imagePullPolicy: IfNotPresent # 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span><br><span class="line">                                      # Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取 </span><br><span class="line">        resources: # 资源管理</span><br><span class="line">          limits: # 最大使用</span><br><span class="line">            cpu: 300m # CPU，<span class="number">1</span>核心 = 1000m</span><br><span class="line">            memory: 500Mi # 内存，1G = 1024Mi</span><br><span class="line">          requests:  # 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">        livenessProbe: # pod 内部健康检查的设置</span><br><span class="line">          httpGet: # 通过httpget检查健康，返回<span class="number">200</span>-<span class="number">399</span>之间，则认为容器正常</span><br><span class="line">            path: /healthCheck # URI地址</span><br><span class="line">            port: <span class="number">8080</span> # 端口</span><br><span class="line">            scheme: HTTP # 协议</span><br><span class="line">            # host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> # 主机地址</span><br><span class="line">          initialDelaySeconds: <span class="number">30</span> # 表明第一次检测在容器启动后多长时间后开始</span><br><span class="line">          timeoutSeconds: <span class="number">5</span> # 检测的超时时间</span><br><span class="line">          periodSeconds: <span class="number">30</span> # 检查间隔时间</span><br><span class="line">          successThreshold: <span class="number">1</span> # 成功门槛</span><br><span class="line">          failureThreshold: <span class="number">5</span> # 失败门槛，连接失败<span class="number">5</span>次，pod杀掉，重启一个新的pod</span><br><span class="line">        readinessProbe: # Pod 准备服务健康检查设置</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthCheck</span><br><span class="line">            port: <span class="number">8080</span></span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: <span class="number">30</span></span><br><span class="line">          timeoutSeconds: <span class="number">5</span></span><br><span class="line">          periodSeconds: <span class="number">10</span></span><br><span class="line">          successThreshold: <span class="number">1</span></span><br><span class="line">          failureThreshold: <span class="number">5</span></span><br><span class="line">        #也可以用这种方法   </span><br><span class="line">        #exec: 执行命令的方法进行监测，如果其退出码不为<span class="number">0</span>，则认为容器正常   </span><br><span class="line">        #  command:   </span><br><span class="line">        #    - cat   </span><br><span class="line">        #    - /tmp/health   </span><br><span class="line">        #也可以用这种方法   </span><br><span class="line">        #tcpSocket: # 通过tcpSocket检查健康  </span><br><span class="line">        #  port: number </span><br><span class="line">        ports:</span><br><span class="line">          - name: http # 名称</span><br><span class="line">            containerPort: <span class="number">8080</span> # 容器开发对外的端口 </span><br><span class="line">            protocol: TCP # 协议</span><br><span class="line">      imagePullSecrets: # 镜像仓库拉取**</span><br><span class="line">        - name: harbor-certification</span><br><span class="line">      affinity: # 亲和性调试</span><br><span class="line">        nodeAffinity: # 节点亲和力</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution: # pod 必须部署到满足条件的节点上</span><br><span class="line">            nodeSelectorTerms: # 节点满足任何一个条件就可以</span><br><span class="line">            - matchExpressions: # 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span><br><span class="line">              - key: beta.kubernetes.io/arch</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - amd64</span><br></pre></td></tr></table></figure><p><strong>Service</strong></p><p>k8s 为每个 Pod 都分配了一个唯一的 IP 地址，可以使用这个 IP 来通信。但是，由于 Pod 的生命周期是短暂的，所以很难把流量发送到指定的容器上。例如，让我们考虑上面提到的 Deployment，有 10 个 Pod 运行，为机器学习模型提供 REST 接口服务。作为 Deployment 的一部分，这些运行的 Pod 可以随时更改，我们如何与服务器可靠地通信？这时 Service 对象映入眼帘。k8s 的 Service 提供了一个稳定的端点（endpoint），它可以用来将流量定向到所需的 Pod 上，即使底层 Pod 由于更新、扩展和故障而发生变化。Service 基于我们在 Pod 清单文件中元数据（metadata）中定义的标签（是键值对）知道应该向哪些 Pod 发送流量。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ODUxNGMwNTE0MWIxMGI4MzEwYTFiZWQ0MDFmMTdiNzNfWW9KNm9CcXl1Rlk3R0taWXNFOFZINWV3MWIzQ252aURfVG9rZW46Sk1MQWIwd25kb3pGRUx4SVM0dmNIMXE1bnBoXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>上图展示了 Service 通过 app&#x3D;ml-model 标签将流量打到所有健康的 Pod 上。</p><p>以下 YAML 文件提供了一个示例，展示了我们如何根据早期的 Deployment 示例包装成 Service。</p><ul><li><strong>service的详解</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1 # 指定api版本，此值必须在kubectl api-versions中 </span><br><span class="line">kind: Service # 指定创建资源的角色/类型 </span><br><span class="line">metadata: # 资源的元数据/属性</span><br><span class="line">  name: demo # 资源的名字，在同一个namespace中必须唯一</span><br><span class="line">  namespace: <span class="keyword">default</span> # 部署在哪个namespace中</span><br><span class="line">  labels: # 设定资源的标签</span><br><span class="line">    app: demo</span><br><span class="line">spec: # 资源规范字段</span><br><span class="line">  type: ClusterIP # ClusterIP 类型</span><br><span class="line">  ports:</span><br><span class="line">    - port: <span class="number">8080</span> # service 端口</span><br><span class="line">      targetPort: http # 容器暴露的端口</span><br><span class="line">      protocol: TCP # 协议</span><br><span class="line">      name: http # 端口名称</span><br><span class="line">  selector: # 选择器</span><br><span class="line">    app: demo</span><br></pre></td></tr></table></figure><p>   参考资料：<a href="https://kubernetes.io/zh-cn/docs/home/">https://kubernetes.io/zh-cn/docs/home/</a></p><p>​     简单部署一个Nginx</p><p>​     配置示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">apiVersion<span class="punctuation">:</span> v1</span><br><span class="line">kind<span class="punctuation">:</span> Service</span><br><span class="line">metadata<span class="punctuation">:</span></span><br><span class="line">  labels<span class="punctuation">:</span></span><br><span class="line">    app<span class="punctuation">:</span> nginx-test</span><br><span class="line">  name<span class="punctuation">:</span> nginx-test</span><br><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  ports<span class="punctuation">:</span></span><br><span class="line">  - name<span class="punctuation">:</span> http</span><br><span class="line">    port<span class="punctuation">:</span> <span class="number">80</span></span><br><span class="line">    protocol<span class="punctuation">:</span> TCP</span><br><span class="line">    targetPort<span class="punctuation">:</span> <span class="number">80</span></span><br><span class="line">  selector<span class="punctuation">:</span></span><br><span class="line">    app<span class="punctuation">:</span> nginx-test</span><br><span class="line">  type<span class="punctuation">:</span> ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion<span class="punctuation">:</span> apps/v1</span><br><span class="line">kind<span class="punctuation">:</span> Deployment</span><br><span class="line">metadata<span class="punctuation">:</span></span><br><span class="line">  generation<span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">  labels<span class="punctuation">:</span></span><br><span class="line">    app<span class="punctuation">:</span> nginx-test</span><br><span class="line">    app.kubernetes.io/instance<span class="punctuation">:</span> release-name</span><br><span class="line">    app.kubernetes.io/managed-by<span class="punctuation">:</span> Tiller</span><br><span class="line">    app.kubernetes.io/name<span class="punctuation">:</span> nginx-test</span><br><span class="line">    helm.sh/chart<span class="punctuation">:</span> nginx<span class="number">-0.1</span><span class="number">.0</span></span><br><span class="line">    version<span class="punctuation">:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">  name<span class="punctuation">:</span> nginx-test</span><br><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  progressDeadlineSeconds<span class="punctuation">:</span> <span class="number">600</span></span><br><span class="line">  replicas<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  revisionHistoryLimit<span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">  selector<span class="punctuation">:</span></span><br><span class="line">    matchLabels<span class="punctuation">:</span></span><br><span class="line">      app<span class="punctuation">:</span> nginx-test</span><br><span class="line">      app.kubernetes.io/name<span class="punctuation">:</span> nginx-test</span><br><span class="line">  strategy<span class="punctuation">:</span></span><br><span class="line">    rollingUpdate<span class="punctuation">:</span></span><br><span class="line">      maxSurge<span class="punctuation">:</span> <span class="number">25</span>%</span><br><span class="line">      maxUnavailable<span class="punctuation">:</span> <span class="number">25</span>%</span><br><span class="line">    type<span class="punctuation">:</span> RollingUpdate</span><br><span class="line">  template<span class="punctuation">:</span></span><br><span class="line">    metadata<span class="punctuation">:</span></span><br><span class="line">      annotations<span class="punctuation">:</span></span><br><span class="line">        kmse.jekins.build<span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">      creationTimestamp<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">      labels<span class="punctuation">:</span></span><br><span class="line">        app<span class="punctuation">:</span> nginx-test</span><br><span class="line">        app.kubernetes.io/instance<span class="punctuation">:</span> release-name</span><br><span class="line">        app.kubernetes.io/name<span class="punctuation">:</span> nginx-test</span><br><span class="line">        version<span class="punctuation">:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    spec<span class="punctuation">:</span></span><br><span class="line">      containers<span class="punctuation">:</span></span><br><span class="line">      - image<span class="punctuation">:</span> hub.kce.ksyun.com/ksyun-public/nginx<span class="punctuation">:</span>latest</span><br><span class="line">        imagePullPolicy<span class="punctuation">:</span> Always</span><br><span class="line">        name<span class="punctuation">:</span> kce-nginx</span><br><span class="line">        resources<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        securityContext<span class="punctuation">:</span></span><br><span class="line">          privileged<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        terminationMessagePath<span class="punctuation">:</span> /dev/termination-log</span><br><span class="line">        terminationMessagePolicy<span class="punctuation">:</span> File</span><br><span class="line">      dnsPolicy<span class="punctuation">:</span> ClusterFirst</span><br><span class="line">      imagePullSecrets<span class="punctuation">:</span></span><br><span class="line">      - name<span class="punctuation">:</span> ksyunregistrykey</span><br><span class="line">      restartPolicy<span class="punctuation">:</span> Always</span><br><span class="line">      schedulerName<span class="punctuation">:</span> default-scheduler</span><br><span class="line">      securityContext<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">      terminationGracePeriodSeconds<span class="punctuation">:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><ul><li><strong>pod的创建流程</strong></li></ul><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZlZDE4MmY2MDRhOTY5Y2VmMTA0NmY5MThkOWM1ZDlfM3RPVnpWZWFjbmRNejV5a0JrSzF1RHJFandyWG1RVGVfVG9rZW46RlVvSGJQSUhYb1NlbE94N1RFa2NSMXVDbnloXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>1、客户端提交创建请求，可以通过API Server的Restful API，也可以使用kubectl命令行工具。支持的数据类型包括JSON和YAML。</p><p>2、API Server处理用户请求，存储Pod数据到etcd。</p><p>3、调度器通过API Server查看未绑定的Pod。尝试为Pod分配主机。</p><p>4、过滤主机 (调度预选)：调度器用一组规则过滤掉不符合要求的主机。比如Pod指定了所需要的资源量，那么可用资源比Pod需要的资源量少的主机会被过滤掉。</p><p>5、主机打分(调度优选)：对第一步筛选出的符合要求的主机进行打分，在主机打分阶段，调度器会考虑一些整体优化策略，比如把容一个Replication Controller的副本分布到不同的主机上，使用最低负载的主机等。</p><p>6、选择主机：选择打分最高的主机，进行binding操作，结果存储到etcd中。</p><p>7、kubelet根据调度结果执行Pod创建操作： 绑定成功后，scheduler会调用APIServer的API在etcd中创建一个boundpod对象，描述在一个工作节点上绑定运行的所有pod信息。运行在每个工作节点上的kubelet也会定期与etcd同步boundpod信息，一旦发现应该在该工作节点上运行的boundpod对象没有更新，则调用Docker API创建并启动pod内的容器。</p><p>​     在整个生命周期中，Pod会出现5种状态（相位），分别如下：</p><p>挂起(Pending): apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</p><p>运行中(Running): pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</p><p>成功(Succeeded): pod中的所有容器都已经成功终止并且不会被重启</p><p>失败(Failed): 所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</p><p>未知(Unknown): apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</p><ul><li><strong>应用持久化存储（pv 以及 pvc）</strong></li></ul><p>​       而Persistent Volume则是一个K8S资源对象，它是独立于Pod的，能单独创建。Persistent Volume 不与Pod发生直接关系，而是通过 Persistent Volume Claim(PVC) 来与Pod绑定关系。在定义Pod时，为Pod指定一个PVC，Pod在创建时会根据PVC要求，从现有集群的PV中，选择一个合适的PV绑定，或动态建立一个新的PV，再与其进行绑定。</p><p><strong>Persistent Volume(PV)：</strong>用于定义各种存储资源的配置信息，一个PV对应一个volume，定义一个PV内容包括了 存储类型、存储大小和访问模式等。</p><p><strong>Persistent Volume Claim(PVC)：</strong>描述对PV的一个请求。请求信息包含存储大小、访问模式等。PVC只会选择符合自己要求的PV进行绑定，然后在定义pod时指定使用哪个PVC就可以了。</p><ul><li><strong>pvc以及pv的绑定原理</strong></li></ul><p>​      PVC和PV的设计，其实跟面向对象的思想完全一致，PVC是面向对象编程中的接口，PV是接口具体的实现。</p><p>用户只需通过PVC来声明自己的存储需求，比如存储大小、可读写权限等，类似于调用接口函数并传入属性参数，而不用关心后端存储实现细节，这些都交由运维人员统一管理即可。</p><p>​      Pod是直接与PVC绑定关系，再根据PVC存储需求，去找到对应PV。PVC只有绑定了PV之后才能被Pod使用。</p><p>PersistentVolume Controller 会不断地查看当前每一个PVC，是不是已经处于Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的PV，并尝试将其与这个PVC进行绑定。这样，Kubernetes就可以保证用户提交的每一个PVC，只要有合适的PV出现，它就能够很快进入绑定状态。</p><p>​       在提交PVC后，是如何找到对应的PV：先根据PVC的accessModes匹配出PV列表，再根据PVC的Capacity、StorageClassName、Label Selector进一步筛选PV。如果满足条件的PV有多个，选择PV的size最小的，accessmodes列表最短的PV，也即最小适合原则。</p><p>pvc跟pv的绑定规则：</p><p>VolumeMode：被消费PV的VolumeMode需要和PVC一致。</p><p>AccessMode：被消费PV的AccessMode需要和PVC一致。</p><p>StorageClassName：如果PVC定义了此字段，则PV也必须有对应字段才能进行绑定。</p><p>LabelSelector：通过标签（labels）匹配的方式从PV列表中选择合适的PV绑定。</p><p>Size：被消费PV的capacity必须大于或等于PVC的存储容量需求才能被绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv2</span><br><span class="line">spec:</span><br><span class="line">  nfs: # 存储类型，与底层真正存储对应</span><br><span class="line">  capacity:  # 存储能力，目前只支持存储空间的设置</span><br><span class="line">    storage: 2Gi</span><br><span class="line">  accessModes:  # 访问模式</span><br><span class="line">  storageClassName: # 存储类别</span><br><span class="line">  persistentVolumeReclaimPolicy: # 回收策略</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  accessModes: # 访问模式</span><br><span class="line">  selector: # 采用标签对PV选择</span><br><span class="line">  storageClassName: # 存储类别</span><br><span class="line">  resources: # 请求空间</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/qq_19676401/article/details/121145651">https://blog.csdn.net/qq_19676401/article/details/121145651</a></p><ul><li><strong>kubect相关命令</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove -y  kubectl #卸载kubectl</span><br><span class="line">传入 kubectl 文件</span><br><span class="line">chmod +x ./kubectl</span><br><span class="line">mv ./kubectl /usr/local/bin/kubectl</span><br></pre></td></tr></table></figure><p>kubectl的安装：<a href="https://www.kancloud.cn/zatko/kubernetes_k8s/2290707">https://www.kancloud.cn/zatko/kubernetes_k8s/2290707</a></p><p>kubectl 命令的语法如下：</p><p><strong>kubectl [command] [TYPE] [NAME] [flags]</strong></p><p>kubectl命令中，指定执行什么操作（command，如create,delete,describe ,get ,apply 等）指定什么类型资源对象（type）指定此类型的资源对象名称（name）指定可选参数（flags）</p><p><strong>查看pod，nodee，service，endpoints，secret等信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get 组件名      #例如kubectl get pod</span><br></pre></td></tr></table></figure><p><strong>查看资源状态，比如有一组deployment内的pod没起来，一般用于pod调度过程出现的问题排查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod pod名    #先用kubectl get pod查看</span><br></pre></td></tr></table></figure><p><strong>查看node节点或者是pod资源（<strong><strong>cpu</strong></strong>，内存资源）使用情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl top 组件名     #例如kubectl top node  kubectl top pod</span><br></pre></td></tr></table></figure><p><strong>进入pod内部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -ti pod名 /bin/bash   #先用kubectl get pod查看</span><br></pre></td></tr></table></figure><p><strong>删除pod</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod -n</span><br></pre></td></tr></table></figure><p><strong>查看集群健康状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cs</span><br></pre></td></tr></table></figure><p><strong>基于 pod.yaml 定义的名称删除指定资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f pod.yaml</span><br></pre></td></tr></table></figure><p><strong>查看容器的日志</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs -f &lt;pod-name&gt; # 实时查看日志</span><br></pre></td></tr></table></figure><p><strong>创建资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f ./my-manifest.yaml </span><br></pre></td></tr></table></figure><p><strong>批量删除异常pod</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n  namespace | grep OutOfcpu | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs kubectl delete pod -n  namespace</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/langzi6/article/details/125139698">https://blog.csdn.net/langzi6/article/details/125139698</a></p><ul><li><strong>演示挂载nginx的index文件</strong></li></ul><p><strong>使用docker直接挂载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 找到对应的容器</span><br></pre></td></tr></table></figure><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUyNjM3YmYwOTA5YTJiZWZhYzcyYWQyYzA5YWIxYTBfcHo4Q1VwTEY2Q0REOWFMMDU0UUVqbVc2ZzJiTG1PNjhfVG9rZW46TW5IVWJ3OFBhb203ZUJ4b0dBZWNnc0libmdQXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp index.html 178888c944e8:/root/index.html #docker cp 命令将文件传入</span><br><span class="line">kubectl exec -it nginx-test-57df77cb76-pg4db /bin/bash #进入pod中查看是否挂载到对应目录</span><br></pre></td></tr></table></figure><p><strong>直接挂载本地节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-test</span><br><span class="line">  name: nginx-test</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: <span class="number">80</span></span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: <span class="number">80</span></span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-test</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  generation: <span class="number">4</span></span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-test</span><br><span class="line">    app.kubernetes.io/instance: release-name</span><br><span class="line">    app.kubernetes.io/managed-by: Tiller</span><br><span class="line">    app.kubernetes.io/name: nginx-test</span><br><span class="line">    helm.sh/chart: nginx-<span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    version: <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">  name: nginx-test</span><br><span class="line">spec:</span><br><span class="line">  progressDeadlineSeconds: <span class="number">600</span></span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  revisionHistoryLimit: <span class="number">10</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-test</span><br><span class="line">      app.kubernetes.io/name: nginx-test</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: <span class="number">25</span>%</span><br><span class="line">      maxUnavailable: <span class="number">25</span>%</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      annotations:</span><br><span class="line">        kmse.jekins.build: <span class="string">&quot;1&quot;</span></span><br><span class="line">      creationTimestamp: <span class="literal">null</span></span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-test</span><br><span class="line">        app.kubernetes.io/instance: release-name</span><br><span class="line">        app.kubernetes.io/name: nginx-test</span><br><span class="line">        version: <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">      - name: index</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /root/campus/index/index.html</span><br><span class="line">      nodeName: <span class="number">10.0</span><span class="number">.0</span><span class="number">.188</span></span><br><span class="line">      containers:</span><br><span class="line">      - image: hub.kce.ksyun.com/ksyun-<span class="keyword">public</span>/nginx:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: kce-nginx</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: <span class="literal">false</span></span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: index</span><br><span class="line">          mountPath: /usr/share/nginx/html/index.html</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">      - name: ksyunregistrykey</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      schedulerName: <span class="keyword">default</span>-scheduler</span><br><span class="line">      securityContext: &#123;&#125;</span><br><span class="line">      terminationGracePeriodSeconds: <span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>使用<strong><strong>pvc</strong></strong>、pv进行挂载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes.io/pv-protection</span><br><span class="line">  labels:</span><br><span class="line">    type: local</span><br><span class="line">  name: nginx-pv</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Gi</span><br><span class="line">  hostPath:</span><br><span class="line">    path: /root/campus/index</span><br><span class="line">    type: <span class="string">&quot;&quot;</span></span><br><span class="line">  nodeAffinity:</span><br><span class="line">    required:</span><br><span class="line">      nodeSelectorTerms:</span><br><span class="line">      - matchExpressions:</span><br><span class="line">        - key: usedFor</span><br><span class="line">          operator: In</span><br><span class="line">          values:</span><br><span class="line">          - nginx</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  storageClassName: manual</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes.io/pvc-protection</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/managed-by: Helm</span><br><span class="line">  name: nginx-pvc</span><br><span class="line">  namespace: nginx</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 8Gi</span><br><span class="line">  storageClassName: manual</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  volumeName: nginx-pv</span><br><span class="line">  </span><br><span class="line">  apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-test</span><br><span class="line">  name: nginx-test</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: <span class="number">80</span></span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: <span class="number">80</span></span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-test</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  generation: <span class="number">4</span></span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-test</span><br><span class="line">    app.kubernetes.io/instance: release-name</span><br><span class="line">    app.kubernetes.io/managed-by: Tiller</span><br><span class="line">    app.kubernetes.io/name: nginx-test</span><br><span class="line">    helm.sh/chart: nginx-<span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    version: <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">  name: nginx-test</span><br><span class="line">spec:</span><br><span class="line">  progressDeadlineSeconds: <span class="number">600</span></span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  revisionHistoryLimit: <span class="number">10</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-test</span><br><span class="line">      app.kubernetes.io/name: nginx-test</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: <span class="number">25</span>%</span><br><span class="line">      maxUnavailable: <span class="number">25</span>%</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      annotations:</span><br><span class="line">        kmse.jekins.build: <span class="string">&quot;1&quot;</span></span><br><span class="line">      creationTimestamp: <span class="literal">null</span></span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-test</span><br><span class="line">        app.kubernetes.io/instance: release-name</span><br><span class="line">        app.kubernetes.io/name: nginx-test</span><br><span class="line">        version: <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">      - name: index</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: nginx-pvc</span><br><span class="line">      containers:</span><br><span class="line">      - image: hub.kce.ksyun.com/ksyun-<span class="keyword">public</span>/nginx:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: kce-nginx</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: <span class="literal">false</span></span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /root</span><br><span class="line">          name: index</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">      - name: ksyunregistrykey</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      schedulerName: <span class="keyword">default</span>-scheduler</span><br><span class="line">      securityContext: &#123;&#125;</span><br><span class="line">      terminationGracePeriodSeconds: <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="3-5-4-k8s与Istio"><a href="#3-5-4-k8s与Istio" class="headerlink" title="3.5.4 k8s与Istio"></a>3.5.4 k8s与Istio</h3><ul><li><strong>Istio是Kubernetes的好帮手</strong></li></ul><p>​    </p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NGU0NzBlYTAwMjNhNjcwNzA1NzBlNGY3ZDU5MGFkNmRfbWN0eXgyWE9oTDlqMDl3UVNIeEhXWm9CaWRVUWVmRG1fVG9rZW46TWVnMmJNcTVtb1ZwbFB4dzI3dmN0ZngzblJjXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​     从场景来看，Kubernetes已经提供了非常强大的应用负载的部署、升级、扩容等运行管理能力。Kubernetes 中的 Service 机制也已经可以做服务注册、服务发现和负载均衡，支持通过服务名访问到服务实例。</p><p>​     从微服务的工具集观点来看，Kubernetes本身是支持微服务的架构，在Pod中部署微服务很合适，也已经解决了微服务的互访互通问题，但对服务间访问的管理如服务的熔断、限流、动态路由、调用链追踪等都不在Kubernetes的能力范围内。因此，istio横空出世，完成了这个任务</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MzMwMzEzMDZkNWUwMWQ3MDU1N2VkNGViNjhlM2NiMzBfbnhFOGNkVG93NEZUOTVEeGRHdDEzNXA3czZWb0NPWFhfVG9rZW46UmRxb2I5VXZob1JRMWN4enQ5NGN2T1BrbnNCXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><ul><li><strong>k8s为istio提供地基</strong></li></ul><p>​      1.提供统一的数据面</p><p>​      数据面Sidecar运行在Kubernetes的Pod里，作为一个Proxy和业务容器部署在一起。在服务网格的定义中要求应用程序在运行的时感知不到Sidecar的存在。而基于Kubernetes的一个 Pod 多个容器的优秀设计使得部署运维。对用户透明，用户甚至感知不到部署 Sidecar的过程。用户还是用原有的方式创建负载，通过 Istio 的自动注入服务，可以自动给指定的负载注入Proxy。如果在另一种环境下部署和使用Proxy，则不会有这样的便利。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MGE1MDc2YzQxNDZhNmIzYTI5MDdlNGVhNTRmN2E3MWZfMXZYcGpZblZLUTAzd0FlTHBJdDVBdFo2bGREWEZMUU5fVG9rZW46TG93ZWJzeHd0b3k0aXB4M2c3VGNFUWUzbjlmXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​    2.提供域名访问机制，省去类似Eureka的注册中心</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=OGM3ZWRmZjY4YTY1ODhiNTYwMGNmMmNlMDAwNjA4NzNfRktPQ3Brc2lReWJCMFcycmJEMVkwREh6WGwxVFZCdFVfVG9rZW46UzAyY2JzYkV0b0pwa2J4eXJJemNZMVBlbm1iXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>   3.基于Kubernetes CRD描述规则</p><p>   Istio的所有路由规则和控制策略都是通过 Kubernetes CRD实现的，因此各种规则策略对应的数据也被存储在 Kube-apiserver 中，不需要另外一个单独的 APIServer 和后端的配置管理。所以，可以说Istio的APIServer就是Kubernetes的APIServer，数据也自然地被存在了对应Kubernetes的etcd中。</p><p>Kubernetes CRD:CRD 本身是一种 Kubernetes 内置的资源类型，即自定义资源的定义，用于描述用户定义的资源是什么样子。</p><h3 id="3-5-5-Istio"><a href="#3-5-5-Istio" class="headerlink" title="3.5.5 Istio"></a>3.5.5 Istio</h3><p>​    Istio是一个提供连接、保护、控制以及观测功能的开放平台，通过提供完整的非侵入式的微服务治理解决方案，能够很好的解决云原生服务的管理、网络连接以及安全管理等服务网络治理问题。Istio 的架构从逻辑上分为数据平面和控制平面。数据平面由一组智能代理（Envoy）组成，被部署为 Sidecar。这些代理负责协调和控制微服务之间的所有网络通信。它们还收集和报告所有网格流量的遥测数据。控制平面管理并配置代理来进行流量路由。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNhY2ZjY2UzYzVjNDFiY2E5YWM3ODY2YjMwZGYxNTVfdUFCYkRsbUZhU3pHTnB3TVAzYWhKUFEwektRaXE2QnVfVG9rZW46TUNCR2JNVkU3b3YyWWd4bldXUmNvY1hsbk1oXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​    下面我们来看一下istio的架构</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=OTcxOWQ2NDhmMzljYmQwMGRiZDg3MzFkYTgyOWEyMmJfa2pPMTFYV0ZZM0prWm9SaVluWmFyNXp5aXdpTHZOT3VfVG9rZW46TEs3bWJYTEpab2VkMFJ4c0Z5eWNES2xQbkpnXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​      其主要数据平面以及控制平面组成</p><ul><li>数据平面：以一组Sidecar的方式部署的Evnoy组成，所有进入和流出服务的流量都会被Envoy拦截，并与控制面进行交互，根据配置执行相应的通信功能。Envoy之所以称之为智能，是因为Envoy相对于其他代理来说有着更丰富的治理能力和灵活的配置方式，并且支持各种插件可用于扩展流量治理能力，并生成遥测数据。</li><li>控制平面：Pilot、Citadel、Galley组成的一个单进程、多模块的istiod组成了istio的控制平面。其中Pilot组件负责提供服务发现、智能路由（如金丝雀发布）和弹性功能（如超时、重试）；Citadel负责安全，管理密钥和证书；Galley负责对配置的验证和处理等功能。Istiod作为一种全新的设计，构建了一套标准的控制面规范，主要提供服务发现、规则配置和证书管理等功能，并向数据平面传递这些信息。</li><li><strong>istio的特征</strong></li><li><strong>连接</strong>：对网格内部的服务之间的调用所产生的流量进行智能管理，并以此为基础，为微服务的部署、测试和升级等操作提供有力保障。</li></ul><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=OTJjYWVjMTQ3ZGY5ZmJjYzZhN2Y2OTM5MjAyOWMwODFfeHdDUEUwRm4zbW5JdEJnaHhWWEQzdDd3NHhGekNHa0xfVG9rZW46WkVvSmJqVDRpb3Q5T3N4NDJWZGM1bUR4bnBnXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><ul><li><strong>安全</strong>：为网格内部的服务之间的调用提供认证、加密和鉴权支持，在不侵入代码的情况下，加固现有服务，提高其安全性。</li></ul><p>安全提供网格内部的安全保障，就应具备服务通信加密、服务身份认证和服务访问控制（授权和鉴权）功能。</p><p>上述功能通常需要数字证书的支持，这就隐藏了对CA的需求，即需要完成证书的签发、传播和更新业务。</p><p>除了上述核心要求，还存在对认证失败的处理、外部证书（统一 CA）的接入等相关支撑内容。</p><ul><li><strong>策略</strong>：在控制平面定制策略，并在服务中实施。</li></ul><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MmMyYjA4YjAzMzAyNTNjODc3YTE2MDY4MjY4Y2IwMWJfS2NTR1dWalNnMDhTeDNFY2RHRnFBQm5yTlllS2J2YlBfVG9rZW46Wko4S2JhaGxLb1BqNjF4SFdqZGNRZHdDbkdIXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>Istio 通过可动态插拔、可扩展的策略实现访问控制、速率限制、配额管理等功能使得资源在消费者之间公平分配</p><ul><li><strong>观察</strong>：对服务之间的调用进行跟踪和测量，获取服务的状态信息。</li></ul><p>动态获取服务运行数据和输出，提供强大的调用链、监控和调用日志收集输出的能力。配合可视化工具，可方便运维人员了解服务的运行状况，发现并解决问题。</p><h3 id="3-5-6-Istio架构详解"><a href="#3-5-6-Istio架构详解" class="headerlink" title="3.5.6 Istio架构详解"></a>3.5.6 Istio架构详解</h3><p>Istio的架构，分为控制平面和数据面平两部分。</p><ul><li>数据平面：由一组智能代理（[Envoy]）组成，被部署为 sidecar。这些代理通过一个通用的策略和遥测中心传递和控制微服务之间的所有网络通信。</li><li>控制平面：管理并配置代理来进行流量路由。此外，控制平面配置 Mixer 来执行策略和收集遥测数据。</li></ul><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=OTMyMTU4ODY0NTczNjY0ZmRlZjkzNWMyM2UyMDk5ZGVfY1lZbDVKU1Y2ekU5eGRybDNRZmh6RkNNdUJibFhiQXFfVG9rZW46V2FueWJGTTdQb0huR0R4bzdzM2NrRDRvbnNoXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>Pilot：提供服务发现功能和路由规则</p><p>Mixer：策略控制，比如：服务调用速率限制</p><p>Citadel：起到安全作用，比如：服务跟服务通信的加密</p><p>Sidecar&#x2F;Envoy: 代理，处理服务的流量</p><p>（1）<strong>自动注入</strong>：（由架构图得知前端服务跟后端服务都有envoy,我们这里以前端服务envoy为例说明）指在创建应用程序时自动注入 Sidecar代理。那什么情况下会自动注入你？在 Kubernetes场景下创建 Pod时，Kube-apiserver调用管理平面组件的 Sidecar-Injector服务，然后会自动修改应用程序的描述信息并注入Sidecar。在真正创建Pod时，在创建业务容器的同时在Pod中创建Sidecar容器。</p><p>总结：会在pod里面自动生产一个代理，业务服务无感知</p><p>（2）<strong>流量拦截</strong>：在 Pod 初始化时设置 iptables 规则，当有流量到来时，基于配置的iptables规则拦截业务容器的入口流量和出口流量到Sidecar上。但是我们的应用程序感知不到Sidecar的存在，还以原本的方式进行互相访问。在架构图中，流出前端服务的流量会被 前端服务侧的 Envoy拦截，而当流量到达后台服务时，入口流量被后台服务V1&#x2F;V2版本的Envoy拦截。</p><p>总结：Pilot提供了服务发现功能，调用方需要到Pilot组件获取提供者服务信息</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ODgwMWI5OGMzZGI0MTExMjRjMjhlNTRlYmM3M2RlZDlfeFpTMDQ5b0xIVlBKNjBrZ1oyUm9PUEZBb05WemNDWlpfVG9rZW46SUJyWGJwR002b3NYbWV4TUQ1ZGNpanFUbjRjXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>（3）<strong>服务发现</strong>：前端服务怎么知道后端服务的服务信息呢？这个时候就需要服务发现了，所以服务发起方的 Envoy 调用控制面组件 Pilot 的服务发现接口获取目标服务的实例列表。在架构图中，前端服务内的 Envoy 通过 控制平面Pilot 的服务发现接口得到后台服务各个实例的地址，为访问做准备。</p><p>总结：Pilot提供了服务发现功能，调用方需要到Pilot组件获取提供者服务信息</p><p>（4）<strong>负载均衡</strong>：数据面的各个Envoy从Pilot中获取后台服务的负载均衡衡配置，并执行负载均衡动作，服务发起方的Envoy（前端服务envoy）根据配置的负载均衡策略选择服务实例，并连接对应的实例地址。</p><p>总结：Pilot也提供了负载均衡功能，调用方根据配置的负载均衡策略选择服务实例</p><p>（5）<strong>流量治理</strong>：Envoy 从 Pilot 中获取配置的流量规则，在拦截到 入口 流量和出口 流量时执行治理逻辑。比如说，在架构图中，前端服务的 Envoy 从 Pilot 中获取流量治理规则，并根据该流量治理规则将不同特征的流量分发到后台服务的v1或v2版本。当然，这只是Istio流量治理的一个场景，Istio支持更丰富的流量治理能力。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGYyOTU2NTM2OTc0ZTJjNzMzOGQ2YTFiNzQwZjE0N2RfS3lUWFZWd3VOblljcDBIc3E0emJ5QjZMeDFHSFllb29fVG9rZW46UHdHa2JYb09Lb25hSGl4TmRDV2NQRmlrbjJlXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>总结：Pilot也提供了路由转发规则</p><p>（6）<strong>访问安全</strong>：在服务间访问时通过双方的Envoy进行双向认证和通道加密，并基于服务的身份进行授权管理。在架构图中，Pilot下发安全相关配置，在前端模块服务和后端服务的Envoy上自动加载证书和密钥来实现双向认证，其中的证书和密钥由另一个控制平面组件Citadel维护。</p><p>总结：Citadel维护了服务代理通信需要的证书和密钥</p><p>（7）<strong>服务遥测</strong>：在服务间通信时，通信双方的Envoy都会连接控制平面组件Mixer上报访问数据，并通过Mixer将数据转发给对应的监控后端。比如说，在架构图中，前端模块服务对后端服务的访问监控指标、日志和调用链都可以通过Mixer收集到对应的监控后端。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZjZDJiM2QzYjNlNzQ2ODNiOTNjMDQxOWE5NjZkZmVfOXNhY3BWbGttS0RZQW5xeGtuYTQySnoxOG5FSUEyQlBfVG9rZW46RmtvT2JobWJnb0k5ZVp4YjhPMWNRenJvblVoXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>总结：Mixer组件可以收集各个服务上的日志，从而可以进行监控</p><p>（8）<strong>策略执行</strong>：在进行服务访问时，通过Mixer连接后端服务来控制服务间的访问，判断对访问是放行还是拒绝。在架构图中，数据面在转发服务的请求前调用Mixer接口检查是否允许访问，Mixer 会做对应检查，给代理（Envoy）返回允许访问还是拒绝, 比如：可以对前端模块服务到后台服务的访问进行速率控制。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJiOTEwYmJhMTc2NTdiMjU4ZDNmMmQ2ZDk3NjM3MmRfUmUxcHU2WFg2ZmtGb1VVOHduQnF5Tlk0VWZHdDdYN2xfVG9rZW46UmhwR2JxYlBQb0lUSmx4NU5kUGNUV2x1bkdkXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>总结：Mixer组件可以对服务速率进行控制（也就是限流）</p><p>（9）<strong>外部访问</strong>：在架构图中，外部服务通过Gateway访问入口将流量转发到服务前端服务内的Envoy组件，对前端服务的负载均衡和一些流量治理策略都在这个Gateway上执行。</p><p><strong>总结：</strong>这里总结在以上过程中涉及的动作和动作主体，可以将其中的每个过程都抽象成一句话：服务调用双方的Envoy代理拦截流量，并根据控制平面的相关配置执行相应的服务治理动作，这也是Istio的数据平面和控制平面的配合方式。</p><h3 id="3-5-7-Sidecar的注入方式"><a href="#3-5-7-Sidecar的注入方式" class="headerlink" title="3.5.7 Sidecar的注入方式"></a>3.5.7 Sidecar的注入方式</h3><p>​      sidecar的注入方式分为手动注入以及自动注入：</p><p>​      手动注入：使用istioctl命令即可进行手动注入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istioctl kube-inject -f samples/sleep/sleep.yaml | kubectl apply -f -</span><br></pre></td></tr></table></figure><p>​      自动注入：在命名空间上设置<code>istio-injection = enabled</code>标签并且启用了注入Webhook时，在该名称空间中创建的所有新容器都将自动添加一个sidecar。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label ns default istio-injection=enabled</span><br></pre></td></tr></table></figure><p>​      自动注入原理：在 Kubernetes环境下，根据自动注入配置，Kube-apiserver在拦截到 Pod创建的请求时，会调用自动注入服务 istio-sidecar-injector 生成 Sidecar 容器的描述并将其插入原 Pod的定义中，这样，在创建的 Pod 内, 除了包括业务容器，还包括 Sidecar容器。这个注入过程对用户透明，用户使用原方式创建工作负载。</p><ul><li><strong>Envoy</strong></li></ul><p>​       Envoy是Lyft开源的一个C++实现的代理（Proxy），和Nginx及HAProxy类似，可代理L3&#x2F;L4层和L7层。代理是它最核心和基础的功能，它也是服务网格框架的Sidecar。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZmMjNiZDc4ZDdmMjMwMWY2MzkyNzJlOWI0ZjEwOTBfUGlKcUh2RDNNWk1zc2JVWUR4UEZqV1JYUTRXalZJNElfVG9rZW46WUcxd2JEbVVJb3pOVll4ZzFpSGNzQ2FCbkNiXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​    </p><p>如上图所示，Envoy 作为 Sidecar 使用时，需要和服务部署在同一台机器或者 Pod 中，用户访问其他服务时，流量会被自动劫持到 Envoy 中。</p><p>下面结合一个具体的例子来讲解。下图是 Productpage 服务通过 HTTP 协议，调用 review 服务的过程。</p><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQzZjlhNjMyN2FkZjI0NGNjMTAwNGNmNDBiMDNlMTJfMWZIeWdyNWl1VHIwUkc1TndnOTdvWnQwS2VWZUtHVWRfVG9rZW46VDRZU2JTdlNWb3doVE54V1pjV2NUUm1abktnXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>​      通过 Iptables 对流量进行劫持，将 Productpage 访问 Reviews 的流量转发到 Envoy 的出流量 15001 端口上。Envoy 先根据 virtual_hosts 进行匹配，再通过路由匹配，发现路由对应的 Cluster，通过服务发现找到 Cluster 对应的 EndPoint，将流量转发到 10.40.0.15:9080 的 Pod 上。Reviews 的 Pod 通过 Iptables 对流量进行劫持，将流量劫持到 Envoy 的入流量端口 15006 上。Envoy 将本地流量转发到对应的本地地址 127.0.0.1:9080，这里不需要对流量进行识别，因为流量被转发到入流量端口 15006 上，这个端口的配置用于本地流量的转发。</p><p>到这里整个 Sidecar 的流量出入过程就结束了。出入流量都经由 Envoy，最终被正确的转发到了 Reviews 的 Pod 上面。</p><p>参考资料：<a href="https://www.cnblogs.com/muzinan110/p/17060326.html">https://www.cnblogs.com/muzinan110/p/17060326.html</a></p><h3 id="3-5-8-Istio的Ingress-Gateway"><a href="#3-5-8-Istio的Ingress-Gateway" class="headerlink" title="3.5.8 Istio的Ingress Gateway"></a>3.5.8 Istio的Ingress Gateway</h3><p>​      ingressgateway 就是入口处的 Gateway，从网格外访问网格内的服务就是通过这个Gateway进行的。ingressgateway比较特别，是一个Loadbalancer类型的Service，不同于其他服务组件只有一两个端口，ingressgateway 开放了一组端口，这些就是网格内服务的外部访问端口。</p><ul><li>istio ingressgateway是通过一个Gateway资源来配置的，它可以指定暴露的端口、协议、主机等信息，但不包含任何流量路由配置。</li><li>istio ingressgateway的流量路由配置是通过一个VirtualService资源来实现的，它可以指定匹配的条件和目标服务，以及一些高级的功能，如故障注入、重试、超时等。</li><li>istio ingressgateway可以利用istio的其他功能，如安全、可观察性、流量控制等。 例如，istio ingressgateway可以实现TLS终止、JWT认证、指标收集、分布式追踪等。</li></ul><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFjYzIzMDkwYTMzYWZhNTNjY2U1NTEwNmQ0ZmZiYWVfVXI4bnc4eWl5Rzg2MVdUd3RybHJ0ZXlEbzFXZXc0czZfVG9rZW46SG1pMWJDbDNMb2E4ZG94M0tScGNFTHdnblNkXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>由于gateway暴露了一个端口，外部的请求就可以根据这个端口把请求发给gateway了然后由gateway把请求分发给网格内部的pod上     </p><p>ingressgateway的配置示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># gw和vs配置</span><br><span class="line">apiVersion<span class="punctuation">:</span> networking.istio.io/v1alpha3</span><br><span class="line">kind<span class="punctuation">:</span> Gateway</span><br><span class="line">metadata<span class="punctuation">:</span></span><br><span class="line">  name<span class="punctuation">:</span> bookinfo-gateway</span><br><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  selector<span class="punctuation">:</span></span><br><span class="line">    istio<span class="punctuation">:</span> ingressgateway # use istio default controller</span><br><span class="line">  servers<span class="punctuation">:</span></span><br><span class="line">  - port<span class="punctuation">:</span></span><br><span class="line">      number<span class="punctuation">:</span> <span class="number">443</span>            # 使用gw-ingress的<span class="number">443</span>端口</span><br><span class="line">      name<span class="punctuation">:</span> https_test_name  # 这个名称可以随意写</span><br><span class="line">      protocol<span class="punctuation">:</span> HTTPS</span><br><span class="line">    hosts<span class="punctuation">:</span></span><br><span class="line">    - <span class="string">&quot;bookinfo.com&quot;</span></span><br><span class="line">    tls<span class="punctuation">:</span></span><br><span class="line">      mode<span class="punctuation">:</span> SIMPLE</span><br><span class="line">      serverCertificate<span class="punctuation">:</span> /etc/istio/ingressgateway-certs/tls.crt</span><br><span class="line">      privateKey<span class="punctuation">:</span> /etc/istio/ingressgateway-certs/tls.key</span><br><span class="line">---</span><br><span class="line">apiVersion<span class="punctuation">:</span> networking.istio.io/v1alpha3</span><br><span class="line">kind<span class="punctuation">:</span> VirtualService</span><br><span class="line">metadata<span class="punctuation">:</span></span><br><span class="line">  name<span class="punctuation">:</span> bookinfo</span><br><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  hosts<span class="punctuation">:</span></span><br><span class="line">  - <span class="string">&quot;*&quot;</span></span><br><span class="line">  gateways<span class="punctuation">:</span></span><br><span class="line">  - bookinfo-gateway</span><br><span class="line">  http<span class="punctuation">:</span></span><br><span class="line">  - match<span class="punctuation">:</span></span><br><span class="line">    - uri<span class="punctuation">:</span></span><br><span class="line">        exact<span class="punctuation">:</span> /productpage</span><br><span class="line">    - uri<span class="punctuation">:</span></span><br><span class="line">        prefix<span class="punctuation">:</span> /static</span><br><span class="line">    - uri<span class="punctuation">:</span></span><br><span class="line">        exact<span class="punctuation">:</span> /login</span><br><span class="line">    - uri<span class="punctuation">:</span></span><br><span class="line">        exact<span class="punctuation">:</span> /logout</span><br><span class="line">    - uri<span class="punctuation">:</span></span><br><span class="line">        prefix<span class="punctuation">:</span> /api/v1/products</span><br><span class="line">    route<span class="punctuation">:</span></span><br><span class="line">    - destination<span class="punctuation">:</span></span><br><span class="line">        host<span class="punctuation">:</span> productpage.istio.svc.cluster.local</span><br><span class="line">        port<span class="punctuation">:</span></span><br><span class="line">          number<span class="punctuation">:</span> <span class="number">9080</span></span><br></pre></td></tr></table></figure><h3 id="3-5-9-Istio网关Gateway概述"><a href="#3-5-9-Istio网关Gateway概述" class="headerlink" title="3.5.9 Istio网关Gateway概述"></a>3.5.9 <strong>Istio网关Gateway概述</strong></h3><p>​      Istio网关Gateway是一个负责处理南北向流量的组件，它通常会暴露服务网格内部的服务，以便外部的请求能够访问到服务网格中的服务。Istio网关Gateway支持多种协议，包括HTTP、HTTPS和GRPC等。</p><p>​      在Istio网关Gateway中，每个服务器都包含一个或多个端口，每个端口都定义了一种协议和相应的配置。Istio网关Gateway还可以定义多个TLS证书，以便对传输的数据进行加密和解密。</p><p>​      在配置Istio网关Gateway时，我们需要指定其所使用的负载均衡算法和服务发现机制。Istio网关Gateway支持多种服务发现机制，包括Kubernetes服务发现、Consul服务发现和Eureka服务发现等。</p><p>​      gateway 配置示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion<span class="punctuation">:</span> networking.istio.io/v1alpha3</span><br><span class="line">kind<span class="punctuation">:</span> Gateway</span><br><span class="line">metadata<span class="punctuation">:</span></span><br><span class="line">  generation<span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">  name<span class="punctuation">:</span> my-gateway</span><br><span class="line">  namespace<span class="punctuation">:</span> test</span><br><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  selector<span class="punctuation">:</span></span><br><span class="line">    istio<span class="punctuation">:</span> ingressgateway</span><br><span class="line">  servers<span class="punctuation">:</span></span><br><span class="line">  - hosts<span class="punctuation">:</span></span><br><span class="line">    - my.gateway.com</span><br><span class="line">    port<span class="punctuation">:</span></span><br><span class="line">      name<span class="punctuation">:</span> http</span><br><span class="line">      number<span class="punctuation">:</span> <span class="number">9080</span></span><br><span class="line">      protocol<span class="punctuation">:</span> HTTP</span><br></pre></td></tr></table></figure><h3 id="3-5-10-Istio-虚拟服务（Virtual-service"><a href="#3-5-10-Istio-虚拟服务（Virtual-service" class="headerlink" title="3.5.10 Istio 虚拟服务（Virtual service)"></a>3.5.10 Istio 虚拟服务（Virtual service)</h3><p>​       在istion中，虚拟服务（Virtual service）和目标规则（destination rule）是流量路由功能的关键组成部分。在Istio所提供的基本连接和发现基础上，通过虚拟服务，能够将请求路由到Istio网格中的特定服务。每个虚拟服务由一组路由规则组成，这些路由规则使Istio能够将虚拟服务的每个给定请求匹配到网格内特定的目标地址。</p><p>​     virtual service 配置示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion<span class="punctuation">:</span> networking.istio.io/v1beta1</span><br><span class="line">kind<span class="punctuation">:</span> VirtualService</span><br><span class="line">metadata<span class="punctuation">:</span></span><br><span class="line">  name<span class="punctuation">:</span> my-virtualService</span><br><span class="line">  namespace<span class="punctuation">:</span> test</span><br><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  gateways<span class="punctuation">:</span></span><br><span class="line">  - my-gateway</span><br><span class="line">  hosts<span class="punctuation">:</span></span><br><span class="line">  - my.gateway.com</span><br><span class="line">  http<span class="punctuation">:</span></span><br><span class="line">  - match<span class="punctuation">:</span></span><br><span class="line">    - uri<span class="punctuation">:</span></span><br><span class="line">        prefix<span class="punctuation">:</span> /</span><br><span class="line">    route<span class="punctuation">:</span></span><br><span class="line">    - destination<span class="punctuation">:</span></span><br><span class="line">        host<span class="punctuation">:</span> nginx-test</span><br><span class="line">        port<span class="punctuation">:</span></span><br><span class="line">          number<span class="punctuation">:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>演示配置流量分发并通过公网访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  generation: <span class="number">3</span></span><br><span class="line">  name: nginx-gateway</span><br><span class="line">  namespace: nginx</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: ingressgateway</span><br><span class="line">  servers:</span><br><span class="line">  - hosts:</span><br><span class="line">    - my.gateway.com</span><br><span class="line">    port:</span><br><span class="line">      name: http</span><br><span class="line">      number: <span class="number">80</span></span><br><span class="line">      protocol: HTTP</span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-vs</span><br><span class="line">  namespace: nginx</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - nginx-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - my.gateway.com</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: /</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: nginx-test.<span class="keyword">default</span>.svc.cluster.local</span><br><span class="line">        port:</span><br><span class="line">          number: <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="3-5-11-Istio-目的规则（DestinationRule"><a href="#3-5-11-Istio-目的规则（DestinationRule" class="headerlink" title="3.5.11 Istio 目的规则（DestinationRule)"></a>3.5.11 Istio 目的规则（DestinationRule)</h3><p>​      DestinationRule，根据字面意思即目标规则，我们可以理解VirtualService为流量的路由，那么DestinationRule则为流量路由之后的去处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: DestinationRule</span><br><span class="line">metadata:</span><br><span class="line">  name: bookinfo-ratings</span><br><span class="line">spec:</span><br><span class="line">  # 含义同VirtualService中destination的host字段一致。</span><br><span class="line">  host: ratings.prod.svc.cluster.local</span><br><span class="line">  # 流量策略，包括负载均衡、连接池策略、异常点检查等</span><br><span class="line">  trafficPolicy:</span><br><span class="line">    # 负载均衡策略，支持随机负载均衡 /按权重负载均衡 /最少请求负载均衡 / hash轮训等</span><br><span class="line">    loadBalancer:</span><br><span class="line">      simple: LEAST_CONN</span><br><span class="line">    # 连接池策略</span><br><span class="line">    connectionPool:</span><br><span class="line">      # tcp连接池设置</span><br><span class="line">      tcp:</span><br><span class="line">        maxConnections: <span class="number">100</span></span><br><span class="line">        connectTimeout: 30ms</span><br><span class="line">        tcpKeepalive:</span><br><span class="line">          time: 7200s</span><br><span class="line">          interval: 75s</span><br><span class="line">      http:</span><br><span class="line">        http2MaxRequests: <span class="number">1000</span></span><br><span class="line">        maxRequestsPerConnection: <span class="number">10</span></span><br><span class="line">    # 异常点检查</span><br><span class="line">    outlierDetection:</span><br><span class="line">      consecutiveErrors: <span class="number">7</span></span><br><span class="line">      interval: 5m</span><br><span class="line">      baseEjectionTime: 15m</span><br><span class="line">    # tls设置</span><br><span class="line">    tls:</span><br><span class="line">      mode: MUTUAL</span><br><span class="line">      clientCertificate: /etc/certs/myclientcert.pem</span><br><span class="line">      privateKey: /etc/certs/client_private_key.pem</span><br><span class="line">      caCertificates: /etc/certs/rootcacerts.pem</span><br><span class="line">  # 服务端点集合</span><br><span class="line">  subsets:</span><br><span class="line">  # subset名称可以用于路由规则中的流量拆分，与virtualService的subset的引用</span><br><span class="line">  - name: testversion</span><br><span class="line">  # 使用标签对服务注册表中的服务端点进行筛选</span><br><span class="line">    labels:</span><br><span class="line">      version: v3</span><br><span class="line">    trafficPolicy:</span><br><span class="line">      loadBalancer:</span><br><span class="line">        simple: ROUND_ROBIN</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/360592235?utm_id=0">https://zhuanlan.zhihu.com/p/360592235?utm_id=0</a></p><ul><li><strong>如何将nginx的端口通过istioEngress转发到公网</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-vs</span><br><span class="line">  namespace: nginx</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - nginx-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - my.gateway.com</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: /</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: nginx-test.<span class="keyword">default</span>.svc.cluster.local</span><br><span class="line">        port:</span><br><span class="line">          number: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  generation: <span class="number">3</span></span><br><span class="line">  name: nginx-gateway</span><br><span class="line">  namespace: nginx</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: ingressgateway</span><br><span class="line">  servers:</span><br><span class="line">  - hosts:</span><br><span class="line">    - my.gateway.com</span><br><span class="line">    port:</span><br><span class="line">      name: http</span><br><span class="line">      number: <span class="number">80</span></span><br><span class="line">      protocol: HTTP</span><br></pre></td></tr></table></figure><h3 id="3-5-12-Istio的总结"><a href="#3-5-12-Istio的总结" class="headerlink" title="3.5.12 Istio的总结"></a>3.5.12 Istio的总结</h3><p><img src="https://kingsoft-cloud.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWY4ZGIxNzRlYmFmMjAzMzIxMjZmYzljZmIwNWNmY2NfWkZFbEx0VkhOY1pVbHlEeEs2cTJLT3VHUTdWQ3dXaWdfVG9rZW46RXJhdWJCU1dZb3V2MXh4c3BZdGNWdm5VbndlXzE2OTI2NzA5OTE6MTY5MjY3NDU5MV9WNA" alt="img"></p><p>优点：</p><ul><li>Istio 是一个开源的服务网格平台，提供了安全、连接和监控微服务的统一方法。</li><li>Istio 得到了 IBM、Google 和 Lyft 等行业领军者的支持，拥有活跃的社区和众多的落地案例。</li><li>Istio 是 Kubernetes 的一等公民，被设计成模块化、平台无关的系统。</li><li>Istio 提供了强大的流量管理、安全性和可观察性功能，可以轻松实现 A&#x2F;B 测试、金丝雀发布、故障注入等。</li></ul><p>缺点：</p><ul><li>Istio 对非 Kubernetes 环境的支持有限，可能需要根据旧有基础设施进行适配才能正常工作。</li><li>Istio 只有 HTTP 协议是一等公民，对私有协议的支持不够完善，可能导致一些功能的缺失。</li><li>Istio 扩展的成本并不低，可能需要修改多个复杂的代码库，并且面临与社区割裂的风险。</li><li>Istio 在集群规模较大时的性能问题，可能导致 Envoy 的内存开销、Istio 的 CPU 开销、XDS 的下发时效性等问题。</li><li>Istio 缺乏成熟的产品生态，可能需要研发基于 Istio 的上层产品来满足可视化界面、权限和账号系统对接等需求。</li><li>Istio 目前解决的问题域还很有限，还有一些分布式系统的复杂语义和功能并未纳入到 Istio 的 Sidecar 运行时之中。</li><li>Istio 技术架构的成熟度还没有达到预期，经历了多次重大变动，导致升级更新带来不兼容性问题。</li></ul><p>参考资料：<a href="https://istio.io/latest/zh/">https://istio.io/latest/zh/</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOINC — 为科研事业贡献闲置的算力</title>
      <link href="/2023/04/25/BOINC%20%E2%80%94%20%E4%B8%BA%E7%A7%91%E7%A0%94%E4%BA%8B%E4%B8%9A%E8%B4%A1%E7%8C%AE%E9%97%B2%E7%BD%AE%E7%9A%84%E7%AE%97%E5%8A%9B/"/>
      <url>/2023/04/25/BOINC%20%E2%80%94%20%E4%B8%BA%E7%A7%91%E7%A0%94%E4%BA%8B%E4%B8%9A%E8%B4%A1%E7%8C%AE%E9%97%B2%E7%BD%AE%E7%9A%84%E7%AE%97%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BOINC-—-为科研事业贡献闲置的算力"><a href="#BOINC-—-为科研事业贡献闲置的算力" class="headerlink" title="BOINC — 为科研事业贡献闲置的算力"></a>BOINC — 为科研事业贡献闲置的算力</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>闲置的服务器，或者服务器长期性能过剩。这种情况应该常见于个人博主，一台服务器仅仅部署一个博客通常无法充分利用服务器的计算资源。</li><li>其它闲置的计算机，比如淘汰掉的笔记本，只要能联网就可以。</li></ul><h2 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h2><p>BOINC 可以分为两部分，一部分是客户端，用于执行具体的计算。另一部分为管理端，可以管理多个客户端，比如指定具体的科研项目，设置 CPU 使用率上限等。</p><p>本文将提供 Docker 部署客户端的方法。你可以直接运行下面的命令来启动客户端。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name boinc \</span><br><span class="line">  --net=host \</span><br><span class="line">  --pid=host \</span><br><span class="line">  -v /opt/appdata/boinc:/var/lib/boinc \</span><br><span class="line">  -e BOINC_GUI_RPC_PASSWORD=<span class="string">&quot;123&quot;</span> \</span><br><span class="line">  -e BOINC_CMD_LINE_OPTIONS=<span class="string">&quot;--allow_remote_gui_rpc&quot;</span> \</span><br><span class="line">  boinc/client</span><br></pre></td></tr></table></figure><p>嘘</p><p>复制</p><ul><li><code>/var/lib/boinc</code>：计算时所使用的数据目录，作为用户无需关心，只需要挂载到宿主机上妥善保存即可。</li><li><code>BOINC_GUI_RPC_PASSWORD</code>：管理端连接客户端时所使用的密码。</li><li><code>BOINC_CMD_LINE_OPTIONS</code>：运行客户端时的参数，<code>--allow_remote_gui_rpc</code> 表示允许管理端远程控制。</li></ul><p>然后打开客户端所在机器的 TCP 31416 端口，这个端口将用于与管理端通信。</p><p>BOINC 客户端还有针对特定平台的优化版本，更多详情见 <a href="https://hub.docker.com/r/boinc/client">boinc&#x2F;client</a>。</p><h2 id="管理端安装"><a href="#管理端安装" class="headerlink" title="管理端安装"></a>管理端安装</h2><p>你可以在 <a href="https://boinc.berkeley.edu/download_all.php">https://boinc.berkeley.edu/download_all.php</a> 下载对应平台的软件。</p><p>以 Windows 为例，安装完打开应该是这样的。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101728249.webp" alt="img"></p><p>BOINC 初始界面</p><p>依次点击：视图 –&gt; 高级视图。会出现下面的界面</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101728235.webp" alt="img"></p><p>BOINC 高级视图</p><p>依次点击：文件 –&gt; 选择计算机。会出现下面的界面</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101728638.webp" alt="img"></p><p>BOINC 客户端选择框</p><p>在主机名框内输入你的客户端的 IP 地址或者域名，密码框内输入部署客户端时的密码，最后点击确定。</p><p>如果连接成功则右下角会出现提示，如下图所示。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101728668.webp" alt="img"></p><p>BOINC 成功连接客户端</p><p>依次点击：工具 –&gt; 添加项目。选择一个你喜欢的项目，按照提示操作即可。</p><h2 id="添加项目或者使用账号管理器时卡死无响应"><a href="#添加项目或者使用账号管理器时卡死无响应" class="headerlink" title="添加项目或者使用账号管理器时卡死无响应"></a>添加项目或者使用账号管理器时卡死无响应</h2><p>Windows 10 系统可能会出现这个问题。</p><p>解决方法：右键点击任务栏的输入法图标 –&gt; 设置 –&gt; 常规 –&gt; 使用以前版本的微软拼音输入法。</p><p>解决方法参考自<a href="https://tieba.baidu.com/p/6408249475">有关添加项目或者使用账号管理器时卡死无响应的问题【boinc吧】_百度贴吧</a>第 13 楼。</p><h2 id="无法连接客户端"><a href="#无法连接客户端" class="headerlink" title="无法连接客户端"></a>无法连接客户端</h2><p>此时观察 BOINC 的日志会发现这么一段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来自不允许的地址 xyzq 的 GUI RPC 请求</span><br></pre></td></tr></table></figure><p>此时要将日志中提到的 IP 地址添加到 BOINC 数据目录下的 <code>remote_hosts.cfg</code> 中，重新连接就行了。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li>BOINC 官网：<a href="https://boinc.berkeley.edu/%E3%80%82">https://boinc.berkeley.edu/。</a></li><li>BOINC – 中国分布式计算总站：<a href="https://www.equn.com/wiki/BOINC%E3%80%82">https://www.equn.com/wiki/BOINC。</a></li><li>中国分布式计算论坛：<a href="http://www.equn.com/forum/%E3%80%82">http://www.equn.com/forum/。</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人搜集的GPT及语言模型相关信息资源</title>
      <link href="/2023/04/12/%5B%E4%B8%AA%E4%BA%BA%E6%90%9C%E9%9B%86%E7%9A%84GPT%E5%8F%8A%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%B5%84%E6%BA%90%5D/"/>
      <url>/2023/04/12/%5B%E4%B8%AA%E4%BA%BA%E6%90%9C%E9%9B%86%E7%9A%84GPT%E5%8F%8A%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%B5%84%E6%BA%90%5D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="个人搜集的GPT及语言模型相关信息资源"><a href="#个人搜集的GPT及语言模型相关信息资源" class="headerlink" title="[个人搜集的GPT及语言模型相关信息资源]"></a>[个人搜集的GPT及语言模型相关信息资源]</h1><p>steamship免费GPT4 <a href="https://www.steamship.com/plugins/gpt-4?tab=Demo">https://www.steamship.com/plugins/gpt-4?tab=Demo</a></p><p>免费GPT4和3.5(需FQ) <a href="https://chat.forefront.ai/">https://chat.forefront.ai/</a></p><p>基于GPT3.5对上传的 无限文档 回答问题且免费 askwise.ai</p><p>ChatGPT导航：<a href="https://lzw.me/x/chatgpt-sites/">https://lzw.me/x/chatgpt-sites/</a></p><p>AI研究所导航 <a href="http://www.aiyjs.com/">http://www.aiyjs.com/</a></p><p>AI工具集导航 <a href="https://ai-bot.cn/">https://ai-bot.cn/</a></p><p>全球AI导航 <a href="https://www.futurepedia.io/">https://www.futurepedia.io/</a></p><p>AIGC之家导航 <a href="https://dczyk.com/">https://dczyk.com/</a></p><p>欢迎大家也把自己了解到的相关资源信息 从评论与大家分享出来，打破信息垄断~</p><p>(^-^)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中Synchronized的优化原理</title>
      <link href="/2023/04/02/Java%E4%B8%ADSynchronized%E7%9A%84%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/02/Java%E4%B8%ADSynchronized%E7%9A%84%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们知道，从 JDK1.6 开始，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。那么就让我们来看看，它究竟是如何优化的。</p><h2 id="原本的问题"><a href="#原本的问题" class="headerlink" title="原本的问题"></a>原本的问题</h2><p><code>Synchronized</code>是基于底层操作系统的 Mutex Lock 实现的，每次获取锁和释放锁的操作都会带来<code>用户态</code>和<code>内核态</code>的切换，从而增加系统性能开销。</p><p>因此，在锁竞争激烈的情况下，<code>Synchronized</code>同步锁在性能上就表现得非常糟糕，它也常被大家称为<code>重量级锁</code>。</p><p>到了 JDK1.5 版本，并发包中新增了 Lock 接口来实现锁功能，它提供了与 Synchronized 关键字类似的同步功能，只是在使用时需要显示获取锁和释放锁。</p><p>在单个线程重复申请锁的情况下，JDK1.5 版本的 Lock 性能要比 Synchronized 锁的性能好很多，也就是当时的 Synchronized 并不具备<code>可重入锁</code>的功能。</p><p>那么当时的 Synchronized 是怎么实现的？又为什么不具备可重入的功能呢？</p><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p>JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。</p><p>当多个线程同时访问一段同步代码时，多个线程会先被存放在<code>EntryList集合</code>（也可称为<code>阻塞队列</code>）中，处于<code>BLOCKED</code>状态的线程，都会被加入到该列表。</p><p>接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。</p><p>如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入<code>WaitSet集合</code>（也可称为<code>等待队列</code>）中，等待下一次被唤醒。此时线程会处于<code>WAITING</code>或者<code>TIMEDWAITING</code>状态，</p><p>如果当前线程顺利执行完方法，也将释放 Mutex。</p><p>总的来说，就是同步锁在这种实现方式中，因 Monitor 是依赖于底层的操作系统实现，存在<code>用户态</code>与<code>内核态</code>之间的切换(可以理解为<code>上下文切换</code>)，所以增加了性能开销。</p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的<code>Java对象头</code>实现了<code>锁升级</code>功能。</p><p>所谓<code>锁升级</code>，就是指</p><blockquote><p>Synchronized 同步锁初始为<code>偏向锁</code>，随着线程竞争越来越激烈，<code>偏向锁</code>升级到<code>轻量级锁</code>，最终升级到<code>重量级锁</code>。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><code>偏向锁</code>主要用来优化同一线程多次申请同一个锁的竞争，也就是现在的<code>Synchronized锁</code>实际已经拥有了可重入锁的功能。</p><p>为什么要有<code>偏向锁</code>？因为在我们的应用中，可能大部分时间是同一个线程竞争锁资源（比如单线程操作一个线程安全的容器），如果这个线程每次都要获取锁和释放锁，那么就在不断的从<code>内核态</code>与<code>用户态</code>之间切换。</p><p>那么有了<code>偏向锁</code>，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头中去判断一下是否当前线程是否持有该偏向锁就可以了。</p><p>一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待<code>全局安全点</code>(JVM的<code>stop the world</code>)，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换对象头中的线程 ID 为自己的 ID，该锁会保持<code>偏向锁</code>状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为<code>轻量级锁</code>。</p><p><code>轻量级锁</code>适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。</p><p>轻量级锁也支持<code>自旋</code>，因此其他线程再次争抢时，如果<code>CAS</code>失败，将不再会进入<code>阻塞状态</code>，而是不断自旋。</p><p>之所以自旋更好，是因为之前说了，默认线程持有锁的时间都不会太长，如果线程被挂起阻塞可能代价会更高。</p><p>如果自旋锁重试之后抢锁依然失败，那么同步锁就会升级至<code>重量级锁</code>。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在<code>WaitSet集合</code>中，也就变成了优化之前的<code>Synchronized锁</code>。</p><h2 id="JVM参数优化"><a href="#JVM参数优化" class="headerlink" title="JVM参数优化"></a>JVM参数优化</h2><p><code>偏向锁</code>升级为<code>轻量级锁</code>时，会发生<code>stop the world</code>，如果系统常常是多线程竞争，那么禁止偏向锁也许是更好的选择，可以通过以下<code>JVM参数</code>进行优化：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 关闭偏向锁（默认打开）</span><br><span class="line">-XX:-UseBiasedLocking</span><br><span class="line">// 设置重量级锁</span><br><span class="line">-XX:+UseHeavyMonitors</span><br></pre></td></tr></table></figure><p><code>轻量级锁</code>拥有<code>自旋锁</code>的功能，那么如果线程持有锁的时间很长，那么竞争的线程也会常常处于自旋状态，占用系统 CPU ，增加系统开销，那么此时关闭自旋锁的优化可以更好一些：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseSpinning</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是 Java 中针对 Synchronized 锁的优化，也正是因为这个优化，ConcurrentHashMap 在 JDK1.8 之后，再次采用 Synchronized 锁。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么需要 “API 网关”？</title>
      <link href="/2023/03/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20%E2%80%9CAPI%20%E7%BD%91%E5%85%B3%E2%80%9D%EF%BC%9F/"/>
      <url>/2023/03/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20%E2%80%9CAPI%20%E7%BD%91%E5%85%B3%E2%80%9D%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么需要-“API-网关”？"><a href="#为什么需要-“API-网关”？" class="headerlink" title="为什么需要 “API 网关”？"></a>为什么需要 “API 网关”？</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>假如我们开发一个短视频服务，我们可以将服务简单地划分为下列几个部分。</p><ul><li>视频服务：视频的上传和下载。</li><li>社交服务：关注、私信和评论等传统的社交服务。</li><li>商品服务：周边商品和增值服务，比如会员服务。</li><li>评价服务：点赞视频、收藏视频、点赞评论等。</li></ul><p>我们不可能只让用户再网页上刷视频，要支持很多个平台，简单地可以分为下面两个。</p><ul><li>WEB 服务（网页）</li><li>APP 服务（手机上的软件）</li></ul><p>如果我们要部署这四类服务，肯定不能将其部署在同一个机器或者机房里，原因如下。</p><ul><li>单个机器的能提供的服务量有限，大量的用户使用时无法及时处理。</li><li>一旦机房出现意外，所有的服务都会失效，容错性太低。</li></ul><p>所以我们就把这四种服务部署在物理位置距离适当的四个机房中。真实情况要比这个复杂得多，比如我可能会在许多个机房中部署同一个服务，防止某个机房出现意外时对应的服务失效，但这对本文来说不重要。</p><p>现在我们部署好了全部的服务，可以让 APP 和网页调用我们服务来让用户刷视频了。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101718229.webp" alt="img"></p><p>看起来是不是没什么问题？以 WEB 端为例，存在下列问题。</p><ul><li>需要调用四类完全不同的服务，而且通常它们的调用方式无法保证一致，加大了开发难度。WEB 开发者需要写四套调用代码，而服务的开发者需要为两个平台提供两套接口。前后端代码的耦合性不可避免地提高，提升维护难度。</li><li>用户的一次操作可能多调用多个服务，意味着发起多次网络请求，如果这些请求还必须按照确定的顺序执行，响应时间会很长，降低用户体验。</li></ul><p>实践中，服务的划分可能更多，对应的调用方式会更加复杂，必须做出改变。</p><h2 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h2><p>上面的例子中，我们发现出现问题的原因是我们总是不可避免地需要同时用到多种服务，那么有什么解决办法呢？</p><p>很容易想到如果把这四类服务合并为一类服务是不是就可以了？其实这回引入更多的问题。</p><ul><li>不同的服务对硬件的需求不同，例如视频服务不需要很高的硬件配置，但带宽已经要足够；社交和评价服务通常涉及到复杂的数据查询，需要强大的计算和 I&#x2F;O 性能；商品服务需要极高可靠性，其服务器的部署方式可能都比较特殊，同时对性能也有较高的要求。</li><li>软件层面就是代码的耦合问题，简单来说就是大幅度提高开发和维护成本。</li></ul><p>既然合并服务不可行，那么把服务的调用合并起来怎么样呢？听起来不错，这就是 API 网关的作用了。</p><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p>如果你有计算机网络的理论基础，你肯定知道 “网关” 这个概念，在 OSI 模型的网络层中，网关通常指路由器，因为它可以实现局域网间的数据互通。API 网关的作用也类似，即接受客户端的请求，转发客户端的请求，转发服务端的响应给客户端。</p><p>那么这和客户端直接请求有什么区别呢？一大区别就是 API 网关可以将不同服务的接口聚合成一个接口，客户端只要请求一次，API 网关就可以根据请求向若干个服务发起请求，等到请求完成后，一起返回给客户端。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101718987.webp" alt="img"></p><p>如图所示，这样做有下列优点。</p><ul><li>API 网关屏蔽了不同服务之间调用差异，统一了调用方式，降低开发和维护成本。</li><li>无需发起多次网络请求，提升了响应时间，保证用户体验。</li><li>API 网关层面可以进行更多的操作，比如安全检查，前后端只需要专注于业务逻辑即可。</li></ul><p>那么有什么缺点呢？缺点就是 API 网关一定要十分可靠，否则一旦它出现故障，所有的服务就算正常运行，客户端也无法调用它们。</p><p>可靠既包含性能保证，也要有容灾保证。为了保证这两点，我们通常不会只部署一个节点的网关，而是部署很多个节点，这样既能保证性能，又有容灾能力。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币的协议</title>
      <link href="/2023/03/26/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/03/26/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="比特币的协议"><a href="#比特币的协议" class="headerlink" title="比特币的协议"></a>比特币的协议</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Block 的结构</li><li>节点类型</li><li>谁可以发布比特币</li><li>如何验证交易的有效性（分布式共识）</li></ul><h2 id="Block-的结构"><a href="#Block-的结构" class="headerlink" title="Block 的结构"></a>Block 的结构</h2><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><ul><li>version</li><li>hash of previours block header</li><li>merkle root hash</li><li>target</li><li>nonce</li></ul><p>挖矿的过程就是寻找一个 nonce 使得<br>$$<br>Hash(Header) \leq target<br>$$</p><h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><ul><li>交易清单</li></ul><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><h3 id="全节点"><a href="#全节点" class="headerlink" title="全节点"></a>全节点</h3><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存中维护 UTXO 集合以便快速检测交易的合法性</li><li>监听比特币网络上的交易信息并验证每笔交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块并验证其合法性</li><li>挖矿<ul><li>决定沿着哪条链挖下去</li><li>当出现等长的分叉时选择哪一个分叉（缺省状态下选择先监听到的分叉）</li></ul></li></ul><h3 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h3><ul><li>无需一直在线</li><li>不保存整个区块链而只保存每个区块的 Header</li><li>不保存全部的交易而只保存与自己相关的交易</li><li>无法检验大多数交易的合法性而只能检验和自己相关的交易的合法性</li><li>无法检测系统中发布的区块的正确性</li><li>可以验证挖矿难度</li><li>只能检测哪个是最长链而不知道哪个是最长合法链</li></ul><h2 id="谁可以发布比特币"><a href="#谁可以发布比特币" class="headerlink" title="谁可以发布比特币"></a>谁可以发布比特币</h2><p>比特币系统中<strong>唯一</strong>可以发布比特币的途径就是区块被接受后获得的奖励。奖励初始为 (50BTC)，每接受21万个区块后奖励减半。<br>当奖励已经很少的时候获取BTC主要是靠交易的手续费。</p><h2 id="如何验证交易的有效性（分布式共识）"><a href="#如何验证交易的有效性（分布式共识）" class="headerlink" title="如何验证交易的有效性（分布式共识）"></a>如何验证交易的有效性（分布式共识）</h2><h3 id="获取记账权"><a href="#获取记账权" class="headerlink" title="获取记账权"></a>获取记账权</h3><p>挖矿的过程就是寻找一个 nonce 使得<br>$$<br>Hash(Header) \leq target<br>$$<br>，优先完成这个工作的节点就获得了这个区块的记账权。节点无法欺骗其它节点说自己完成了工作，因为其它节点可以轻松地验证上述条件是否成立。</p><h3 id="接受区块-gt"><a href="#接受区块-gt" class="headerlink" title="接受区块&gt;"></a>接受区块&gt;</h3><ol><li>验证区块的信息，如难度是否正确，交易信息是否没有篡改等。</li><li>通过查看 Header 确定当前区块是否在扩展最长链，如果是扩展最长链则接受该区块，反之则不接受。</li><li>下列情况下可能会导致几乎同时出现两个最长的链<ul><li>两个人几乎同时取得了记账权。</li><li>由于网络等原因一部分节点接受了一个区块，另一部分节点接受了另一个区块，以及类似的情况。</li><li>其它情况。</li></ul></li><li>出现这种情况的时候接受哪条链实际上是这些链各个对应的矿工的算力比拼，如果其中一条链的矿工的算力可以让该链最快地扩展，则最终该链会被其它节点接受成为最长链。</li></ol><h3 id="激励机制"><a href="#激励机制" class="headerlink" title="激励机制"></a>激励机制</h3><p>那么凭什么让矿工来拿出算力来维持这个共识？</p><ul><li>一旦一个区块被接受，则拥有者可以获得奖励。奖励初始为50 BTC ，每接受 21 万个区块后奖励减半。这在奖励比较多的时候可以大大激发矿工的挖矿热情。</li><li>一个区块是可以记账的，每当一笔交易被记录到一个区块内的时候，区块的拥有者就可以收取一定手续费。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1Vt411X7JF">北京大学肖臻老师《区块链技术与应用》公开课</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是分库分表</title>
      <link href="/2023/03/15/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2023/03/15/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分库分表，是企业里面毕竟常见的针对高并发、数据量大的场景下的一种技术优化方案，也是一个非常高频的面试题。但是，因为很多人其实并没有非常丰富的分库分表的经验，所以能把这个问题回答的比较好的人其实还挺少的。</p><p>那么，本文就来试图把关于分库分表的事情，一次性的讲个清楚。</p><h3 id="分库，分表，分库分表"><a href="#分库，分表，分库分表" class="headerlink" title="分库，分表，分库分表"></a>分库，分表，分库分表</h3><p>首先，我们需要知道所谓”分库分表”，根本就不是一件事儿，而是三件事儿，他们要解决的问题也都不一样。</p><p>这三个事儿分别是”只分库不分表”、”只分表不分库”、以及”既分库又分表”。</p><h4 id="什么时候分库"><a href="#什么时候分库" class="headerlink" title="什么时候分库?"></a>什么时候分库?</h4><p>其实，分库主要解决的是并发量大的问题。因为并发量一旦上来了，那么数据库就可能会成为瓶颈，因为数据库的连接数是有限的，虽然可以调整，但是也不是无限调整的。</p><p>所以，当当你的数据库的读或者写的QPS过高，导致你的数据库连接数不足了的时候，就需要考虑分库了，通过增加数据库实例的方式来提供更多的可用数据库链接，从而提升系统的并发度。</p><p>比较典型的分库的场景就是我们在做微服务拆分的时候，就会按照业务边界，把各个业务的数据从一个单一的数据库中拆分开，分表把订单、物流、商品、会员等单独放到单独的数据库中。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071137051.jpeg" alt="img"></p><p>还有就是有的时候可能会需要把历史订单挪到历史库里面去。这也是分库的一种具体做法。</p><h4 id="什么时候分表"><a href="#什么时候分表" class="headerlink" title="什么时候分表?"></a>什么时候分表?</h4><p>分库主要解决的是并发量大的问题，那分表其实主要解决的是数据量大的问题。</p><p>假如你的单表数据量非常大，因为并发不高，数据量连接可能还够，但是存储和查询的性能遇到了瓶颈了，你做了很多优化之后还是无法提升效率的时候，就需要考虑做分表了。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071137133.jpeg" alt="img"></p><p>通过将数据拆分到多张表中，来减少单表的数据量，从而提升查询速度。</p><p>一般我们认为，单表行数超过 500 万行或者单表容量超过 2GB之后，才需要考虑做分库分表了，小于这个数据量，遇到性能问题先建议大家通过其他优化来解决。</p><h4 id="什么时候既分库又分表"><a href="#什么时候既分库又分表" class="headerlink" title="什么时候既分库又分表?"></a>什么时候既分库又分表?</h4><p>那么什么时候分库又分表呢，那就是既需要解决并发量大的问题，又需要解决数据量大的问题时候。通常情况下，高并发和数据量大的问题都是同时发生的，所以，我们会经常遇到分库分表需要同时进行的情况。</p><p>所以，当你的数据库链接也不够了，并且单表数据量也很大导致查询比较慢的时候，就需要做既分库又分表了。</p><h3 id="横向拆分和纵向拆分"><a href="#横向拆分和纵向拆分" class="headerlink" title="横向拆分和纵向拆分"></a>横向拆分和纵向拆分</h3><p>谈及到分库分表，那就要涉及到该如何做拆分的问题。</p><p>通常在做拆分的时候有两种分法，分别是横向拆分(水平拆分)和纵向拆分(垂直拆分)。假如我们有一张表，如果把这张表中某一条记录的多个字段，拆分到多张表中，这种就是纵向拆分。那如果把一张表中的不同的记录分别放到不同的表中，这种就是横向拆分。</p><p>横向拆分的结果是数据库表中的数据会分散到多张分表中，使得每一个单表中的数据的条数都有所下降。比如我们可以把不同的用户的订单分表拆分放到不同的表中。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071137184.jpeg" alt="img"></p><p>纵向拆分的结果是数据库表中的数据的字段数会变少，使得每一个单表中的数据的存储有所下降。比如我可以把商品详情信息、价格信息、库存信息等等分别拆分到不同的表中。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071138381.jpeg" alt="img"></p><p>还有我们谈到的针对不同的业务做拆分成多个数据库的这种情况，其实也是纵向拆分的一种。</p><h3 id="分表字段的选择"><a href="#分表字段的选择" class="headerlink" title="分表字段的选择"></a>分表字段的选择</h3><p>在分库分表的过程中，我们需要有一个字段用来进行分表，比如按照用户分表、按照时间分表、按照地区分表。这里面的用户、时间、地区就是所谓的分表字段。</p><p>那么，在选择这个分表字段的时候，一定要注意，要根据实际的业务情况来做慎重的选择。</p><p>比如说我们要对交易订单进行分表的时候，我们可以选择的信息有很多，比如买家Id、卖家Id、订单号、时间、地区等等，具体应该如何选择呢?</p><p>通常，如果有特殊的诉求，比如按照月度汇总、地区汇总等以外，我们通常建议大家按照买家Id进行分表。因为这样可以避免一个关键的问题那就是——数据倾斜(热点数据)。</p><h4 id="买家还是卖家"><a href="#买家还是卖家" class="headerlink" title="买家还是卖家?"></a>买家还是卖家?</h4><p>首先，我们先说为什么不按照卖家分表?</p><p>因为我们知道，电商网站上面是有很多买家和卖家的，但是，一个大的卖家可能会产生很多订单，比如像苏宁易购、当当等这种店铺，他每天在天猫产生的订单量就非常的大。如果按照卖家Id分表的话，那同一个卖家的很多订单都会分到同一张表。</p><p>那就会使得有一些表的数据量非常的大，但是有些表的数据量又很小，这就是发生了数据倾斜。这个卖家的数据就变成了热点数据，随着时间的增长，就会使得这个卖家的所有操作都变得异常缓慢。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071138164.jpeg" alt="img"></p><p>但是，买家ID做分表字段就不会出现这类问题，因为一个不太容易出现一个买家能把数据买倾斜了。</p><p>但是需要注意的是，我们说按照买家Id做分表，保证的是同一个买家的所有订单都在同一张表 ，并不是要给每个买家都单独分配一张表。</p><p>我们在做分表路由的时候，是可以设定一定的规则的，比如我们想要分1024张表，那么我们可以用买家ID或者买家ID的hashcode对1024取模，结果是0000-1023，那么就存储到对应的编号的分表中就行了。</p><h4 id="卖家查询怎么办"><a href="#卖家查询怎么办" class="headerlink" title="卖家查询怎么办?"></a>卖家查询怎么办?</h4><p>如果按照买家Id进行了分表，那卖家的查询怎么办，这不就意味着要跨表查询了吗?</p><p>首先，业务问题我们要建立在业务背景下讨论。电商网站订单查询有几种场景?</p><ul><li>买家查自己的订单</li><li>卖家查自己的订单</li><li>平台的小二查用户的订单。</li></ul><p>首先，我们用买家ID做了分表，那么买家来查询的时候，是一定可以把买家ID带过来的，我们直接去对应的表里面查询就行了。</p><p>那如果是卖家查呢?卖家查询的话，同样可以带卖家id过来，那么，我们可以有一个基于binlog、flink等准实时的同步一张卖家维度的分表，这张表只用来查询，来解决卖家查询的问题。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071138799.jpeg" alt="img"></p><p>本质上就是用空间换时间的做法。</p><p>不知道大家看到这里会不会有这样的疑问：同步一张卖家表，这不又带来了大卖家的热点问题了吗?</p><p>首先，我们说同步一张卖家维度的表来，但是其实所有的写操作还是要写到买家表的，只不过需要准实时同步的方案同步到卖家表中。也就是说，我们的这个卖家表理论上是没有业务的写操作，只有读操作的。</p><p>所以，这个卖家库只需要有高性能的读就行了，那这样的话就可以有很多选择了，比如可以部署到一些配置不用那么高的机器、或者其实可以干脆就不用MYSQL，而是采用HBASE、PolarDB、Lindorm等数据库就可以了。这些数据库都是可以海量数据，并提供高性能查询的。</p><p>还有呢就是，大卖家一般都是可以识别的，提前针对大卖家，把他的订单，再按照一定的规则拆分到多张表中。因为只有读，没有写操作，所以拆分多张表也不用考虑事务的问题。</p><h4 id="按照订单查询怎么办"><a href="#按照订单查询怎么办" class="headerlink" title="按照订单查询怎么办?"></a>按照订单查询怎么办?</h4><p>上面说的都是有买卖家ID的情况，那没有买卖家ID呢?用订单号直接查怎么办呢?</p><p>这种问题的解决方案是，在生成订单号的时候，我们一般会把分表解决编码到订单号中去，因为订单生成的时候是一定可以知道买家ID的，那么我们就把买家ID的路由结果比如1023，作为一段固定的值放到订单号中就行了。这就是所谓的”基因法”</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071138637.jpeg" alt="img"></p><p>这样按照订单号查询的时候，解析出这段数字，直接去对应分表查询就好了。</p><p>至于还有人问其他的查询，没有买卖家ID，也没订单号的，那其实就属于是低频查询或者非核心功能查询了，那就可以用ES等搜索引擎的方案来解决了。就不赘述了。</p><h3 id="分表算法"><a href="#分表算法" class="headerlink" title="分表算法"></a>分表算法</h3><p>选定了分表字段之后，如何基于这个分表字段来准确的把数据分表到某一张表中呢?</p><p>这就是分表算法要做的事情了，但是不管什么算法，我们都需要确保一个前提，那就是同一个分表字段，经过这个算法处理后，得到的结果一定是一致的，不可变的。</p><p>通常情况下，当我们对order表进行分表的时候，比如我们要分成128张表的话，那么得到的128表应该是:order_0000、order_0001、order_0002…..order_0126、order_0127</p><p>通常的分表算法有以下几种：</p><h4 id="直接取模"><a href="#直接取模" class="headerlink" title="直接取模"></a>直接取模</h4><p>在分库分表时，我们是事先可以知道要分成多少个库和多少张表的，所以，比较简单的就是取模的方式。</p><p>比如我们要分成128张表的话，就用一个整数来对128取模就行了，得到的结果如果是0002，那么就把数据放到order_0002这张表中。</p><h4 id="Hash取模"><a href="#Hash取模" class="headerlink" title="Hash取模"></a>Hash取模</h4><p>那如果分表字段不是数字类型，而是字符串类型怎么办呢?有一个办法就是哈希取模，就是先对这个分表字段取Hash，然后在再取模。</p><p>但是需要注意的是，Java中的hash方法得到的结果有可能是负数，需要考虑这种负数的情况。</p><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><p>前面两种取模方式都比较不错，可以使我们的数据比较均匀的分布到多张分表中。但是还是存在一个缺点。</p><p>那就是如果需要扩容二次分表，表的总数量发生变化时，就需要重新计算hash值，就需要涉及到数据迁移了。</p><p>为了解决扩容的问题，我们可以采用一致性哈希的方式来做分表。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071138348.jpeg" alt="img"></p><p>一致性哈希可以按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，形成成一个顺时针首尾相接的闭合的环形。所以当添加一台新的数据库服务器时，只有增加服务器的位置和逆时针方向第一台服务器之间的键会受影响。</p><h3 id="全局ID的生成"><a href="#全局ID的生成" class="headerlink" title="全局ID的生成"></a>全局ID的生成</h3><p>涉及到分库分表，就会引申出分布式系统中唯一主键ID的生成问题，因为在单表中我们可以用数据库主键来做唯一ID，但是如果做了分库分表，多张单表中的自增主键就一定会发生冲突。那就不具备全局唯一性了。</p><p>那么，如何生成一个全局唯一的ID呢?有以下几种方式：</p><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>很多人对UUID都不陌生，它是可以做到全局唯一的，而且生成方式也简单，但是我们通常不推荐使用他做唯一ID，首先UUID太长了，其次字符串的查询效率也比较慢，而且没有业务含义，根本看不懂。</p><p>基于某个单表做自增主键</p><p>多张单表生成的自增主键会冲突，但是如果所有的表中的主键都从同一张表生成是不是就可以了。</p><p>所有的表在需要主键的时候，都到这张表中获取一个自增的ID。</p><p>这样做是可以做到唯一，也能实现自增，但是问题是这个单表就变成整个系统的瓶颈，而且也存在单点问题，一旦他挂了，那整个数据库就都无法写入了。</p><h4 id="基于多个单表-步长做自增主键"><a href="#基于多个单表-步长做自增主键" class="headerlink" title="基于多个单表+步长做自增主键"></a>基于多个单表+步长做自增主键</h4><p>为了解决单个数据库做自曾主键的瓶颈及单点故障问题，我们可以引入多个表来一起生成就行了。</p><p>但是如何保证多张表里面生成的Id不重复呢?如果我们能实现以下的生成方式就行了：</p><p>实例1生成的ID从1000开始，到1999结束。</p><p>实例2生成的ID从2000开始，到2999结束。</p><p>实例3生成的ID从3000开始，到3999结束。</p><p>实例4生成的ID从4000开始，到4999结束。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071138361.jpeg" alt="img"></p><p>这样就能避免ID重复了，那如果第一个实例的ID已经用到1999了怎么办?那就生成一个新的起始值：</p><p>实例1生成的ID从5000开始，到5999结束。实例2生成的ID从6000开始，到6999结束。实例3生成的ID从7000开始，到7999结束。实例4生成的ID从8000开始，到8999结束。</p><p>我们把步长设置为1000，确保每一个单表中的主键起始值都不一样，并且比当前的最大值相差1000就行了。</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法也是比较常用的一种分布式ID的生成方式，它具有全局唯一、递增、高可用的特点。</p><p>雪花算法生成的主键主要由 4 部分组成，1bit符号位、41bit时间戳位、10bit工作进程位以及 12bit 序列号位。</p><p>时间戳占用41bit，精确到毫秒，总共可以容纳约69年的时间。</p><p>工作进程位占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。</p><p>序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p><p>所以，一个雪花算法可以在同一毫秒内最多可以生成1024 X 4096 &#x3D; 4194304个唯一的ID</p><h3 id="分库分表的工具"><a href="#分库分表的工具" class="headerlink" title="分库分表的工具"></a>分库分表的工具</h3><p>在选定了分表字段和分表算法之后，那么，如何把这些功能给实现出来，需要怎么做呢?</p><p>我们如何可以做到像处理单表一样处理分库分表的数据呢?这就需要用到一个分库分表的工具了。</p><p>目前市面上比较不错的分库分表的开源框架主要有三个，分别是sharding-jdbc、TDDL和Mycat</p><h4 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding-JDBC"></a>Sharding-JDBC</h4><p>现在叫ShardingSphere(Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar这3款相互独立的产品组成)。它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><p>开原地址：<a href="https://shardingsphere.apache.org/">https://shardingsphere.apache.org</a></p><h4 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h4><p>TDDL 是淘宝开源的一个用于访问数据库的中间件， 它集成了分库分表， 读写分离，权重调配，动态数据源配置等功能。封装 jdbc 的 DataSource给用户提供统一的基于客户端的使用。</p><p>开源地址：<a href="https://github.com/alibaba/tb_tddl">https://github.com/alibaba/tb_tddl</a></p><h4 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h4><p>Mycat是一款分布式关系型数据库中间件。它支持分布式SQL查询，兼容MySQL通信协议，以Java生态支持多种后端数据库，通过数据分片提高数据查询处理能力。</p><p>开源地址：<a href="https://github.com/MyCATApache/Mycat2">https://github.com/MyCATApache/Mycat2</a></p><h3 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h3><p>分库分表之后，会带来很多问题。</p><p>首先，做了分库分表之后，所有的读和写操作，都需要带着分表字段，这样才能知道具体去哪个库、哪张表中去查询数据。如果不带的话，就得支持全表扫描。</p><p>但是，单表的时候全表扫描比较容易，但是做了分库分表之后，就没办法做扫表的操作了，如果要扫表的话就要把所有的物理表都要扫一遍。</p><p>还有，一旦我们要从多个数据库中查询或者写入数据，就有很多事情都不能做了，比如跨库事务就是不支持的。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306071138922.jpeg" alt="img"></p><p>所以，分库分表之后就会带来因为不支持事务而导致的数据一致性的问题。</p><p>其次，做了分库分表之后，以前单表中很方便的分页查询、排序等等操作就都失效了。因为我们不能跨多表进行分页、排序。</p><p>总之，分库分表虽然能解决一些大数据量、高并发的问题，但是同时也会带来一些新的问题。所以，在做数据库优化的时候，还是建议大家优先选择其他的优化方式，最后再考虑分库分表。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上，本文介绍了分库分表的一些原因，以及如何做分库分表，并且讨论了其中比较关键的分表字段和分表算法的问题。还介绍了几款比较不错的分库分表的相关框架。</p><p>最后，还有一些需要大家注意的就是分库分表会引入一些新的问题，这些问题的解决成本也都不低，所以在做技术选型的时候也要做好这方面的评估。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka自我保护机制开启了但是服务还是被删掉了</title>
      <link href="/2023/03/12/Eureka%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/03/12/Eureka%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Eureka自我保护机制开启了但是服务还是被删掉了"><a href="#Eureka自我保护机制开启了但是服务还是被删掉了" class="headerlink" title="Eureka自我保护机制开启了但是服务还是被删掉了"></a>Eureka自我保护机制开启了但是服务还是被删掉了</h1><h3 id="事件重现："><a href="#事件重现：" class="headerlink" title="事件重现："></a>事件重现：</h3><h4 id="Eureka中80和10000都注册进来了"><a href="#Eureka中80和10000都注册进来了" class="headerlink" title="Eureka中80和10000都注册进来了"></a>Eureka中80和10000都注册进来了</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091059266.png" alt="image-20230409105935095"></p><h4 id="将80服务关闭"><a href="#将80服务关闭" class="headerlink" title="将80服务关闭"></a>将80服务关闭</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091101485.png" alt="image-20230409110137386"></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091102132.png" alt="image-20230409110201073"></p><h4 id="Eureka中就只剩10000了，80服务被删除了"><a href="#Eureka中就只剩10000了，80服务被删除了" class="headerlink" title="Eureka中就只剩10000了，80服务被删除了"></a>Eureka中就只剩10000了，80服务被删除了</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091102808.png" alt="image-20230409110238742"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>图一可以看到，在Eureka中我10000和80服务都已经注册进去了，在图二中我把80关闭了，但是Eureka确把80服务删除了，这不对啊，我Eureka自我保护模式没关啊！根据Eureka的自我保护模式就算服务关闭了，但是注册中心Eureka也不会将这个实例删除才对啊？应该是80,10000都在才符合我的预期啊！</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>因为我关闭80是通过idea关闭,idea让它们正常的走了应用消亡的生命周期,让资源得到了回收，所以我关掉80时，Eureka就将这个实例删除了。</p><p>我要怎么实验下Eureka自我保护模式呢？服务关闭但是Eureka没有将这个服务剔除出去？<br>正确测试方法：<br>用命令查询所有端口：netstat -ano<br>再用 ：taskkill &#x2F;pid pid号 &#x2F;f 强行关闭这个端口</p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册中心 </tag>
            
            <tag> CAP理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat和Spring和servlet和springMVC之间的关系</title>
      <link href="/2023/03/10/spring/"/>
      <url>/2023/03/10/spring/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tomcat和Spring和servlet和springMVC之间的关系"><a href="#Tomcat和Spring和servlet和springMVC之间的关系" class="headerlink" title="Tomcat和Spring和servlet和springMVC之间的关系"></a>Tomcat和Spring和servlet和springMVC之间的关系</h1><h2 id="1、Servlet是什么？"><a href="#1、Servlet是什么？" class="headerlink" title="1、Servlet是什么？"></a>1、<strong>Servlet是</strong>什<strong>么？</strong></h2><p>servlet就是一个Java接口，是JavaEE规范的一种，主要是为了扩展Java作为Web服务的功能。</p><p>由其他内部厂商如tomcat，JBoss内部实现web的功能。</p><p>如一个http请求到来：</p><p>容器将请求封装为servlet中的HttpServletRequest对象，调用init（），service（）等方法输出response,由容器包装为httpresponse返回给客户端的过程。</p><h2 id="2、Spring框架"><a href="#2、Spring框架" class="headerlink" title="2、Spring框架"></a>2、Spring框架</h2><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p><h2 id="3、关系"><a href="#3、关系" class="headerlink" title="3、关系"></a>3、关系</h2><p>1、Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。</p><p>2、Springmvc的核心是一个DispatcherServlet，并且DispatcherServlet继承自 FrameworkServlet继承自HttpServletBean 继承自HttpServlet（也就是你说的servelt） 本质上是一样的东西。其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情，如校验，拦截（AOP思想），后期渲染等等，好让我们专注于业务的开发。</p><p>servlet、filter和listener是javaweb得三大组成部分。</p><p>其中servlet通常是由web.xml统一管理。</p><p>而springmvc核心是disparcherservlet为入口。</p><p>spring可以管理servlet和springmvc中得javabean，这个意思就是说servlet和springmvc是相对独立的两个servlet，</p><p>当你想要在一个继承servlet的实现类中，控制url映射的时候，必须在web.xml配置对应关系，即使你把这个servlet交给spring去管理</p><p>他的映射入口依然是web.xml中你配置的那个路径，跟dispatcherservlet没有关系。这就导致了spring中有一个注入的servlet，并且还有一个独立的servlet（可以说是由web.xml管理的），最终如果你在servlet、filter注入属性的时候不成功。</p><h3 id="servlet工作流程"><a href="#servlet工作流程" class="headerlink" title="servlet工作流程"></a>servlet工作流程</h3><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303262210496.webp" alt="img"></p><h2 id="Tomcat和Spring关系"><a href="#Tomcat和Spring关系" class="headerlink" title="Tomcat和Spring关系"></a>Tomcat和Spring关系</h2><p>​Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。</p><p>​比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器，SpringMVC是处理Servlet请求的应用，<strong>其中DispatcherServlet实现了Servlet接口</strong>，<strong>Tomcat负责加载和调用DispatcherServlet。</strong>同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p><blockquote><p>​如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p></blockquote><blockquote><p>​<strong>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</strong></p></blockquote><h2 id="Spring-MVC与Jsp-x2F-Servlet比较"><a href="#Spring-MVC与Jsp-x2F-Servlet比较" class="headerlink" title="Spring MVC与Jsp&#x2F;Servlet比较"></a>Spring MVC与Jsp&#x2F;Servlet比较</h2><h4 id="1、传统的-Jsp-x2F-Servlet-技术体系弊端"><a href="#1、传统的-Jsp-x2F-Servlet-技术体系弊端" class="headerlink" title="1、传统的 Jsp&#x2F;Servlet 技术体系弊端"></a>1、传统的 Jsp&#x2F;Servlet 技术体系弊端</h4><blockquote><p>Servlet： 是用java编写的服务端应用程序。</p></blockquote><ul><li>作用：主要用于交互式的浏览和修改数据，生成web内容，这个过程为：客户端发送请求到服务器 -&gt; 服务器将请求信息发送至Servlet–&gt;Servlet生成相应内容并将其传给服务器-&gt; 服务器将响应返回给客户端。</li><li>在传统的 Jsp&#x2F;Servlet 技术体系中，如果要开发接口，一个接口对应一个<br>Servlet，每个请求都去在web.xml中配置一个servlet节点。会导致我们开发出许多 Servlet，使用 SpringMVC可以有效的简化这一步骤。</li></ul><h4 id="2、Spring-Web-MVC-特点"><a href="#2、Spring-Web-MVC-特点" class="headerlink" title="2、Spring Web MVC 特点"></a>2、Spring Web MVC 特点</h4><ul><li><p>Spring Web MVC 是一种基于 Java 的实现了 Web MVC 设计模式的请求驱动类型的轻量级 Web 框架，即使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringWeb MVC 也是要简化我们日常 Web 开发的。</p></li><li><p>Spring Web MVC 也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器可以拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View<br>Resolver)进行视图管理；页面控制器&#x2F;动作&#x2F;处理器为 Controller 接口（仅包含 ModelAndView handleRequest(request, response) 方法，也有人称作 Handler）的实现（也可以是任何的 POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。</p></li></ul><h4 id="3、Spring-MVC工作流程"><a href="#3、Spring-MVC工作流程" class="headerlink" title="3、Spring MVC工作流程"></a>3、Spring MVC工作流程</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303262206811.jpg" alt="韩顺平 Java工程师课程-SpringMVC"></p><ul><li><p>1、用户发送请求至前端控制器DispatcherServlet。</p></li><li><p>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p></li><li><p>3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p></li><li><p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p></li><li><p>5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p></li><li><p>6、Controller执行完成返回ModelAndView。</p></li><li><p>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p></li><li><p>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p></li><li><p>9、ViewReslover解析后返回具体View。</p></li><li><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p></li><li><p>11、DispatcherServlet响应用户。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的个人网盘搭建之路</title>
      <link href="/2023/02/26/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/"/>
      <url>/2023/02/26/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前一段时间突然心血来潮，想学大佬搞一个个人网盘，正好有一个微软E5的订阅和A1的订阅，于是便开始着手研究网盘站的搭建。</p><p>下面我会介绍我尝试过的几个网盘搭建程序并进行对比供大家参考。</p><h3 id="OneManager"><a href="#OneManager" class="headerlink" title="OneManager"></a>OneManager</h3><p>源码地址：<a href="https://github.com/qkqpttgf/OneManager-php">OneManager-php</a></p><p>Demo：<a href="https://herooneindex.herokuapp.com/">OneManager Heroku Demo</a></p><p>这是一个PHP开发的OneDrive目录索引程序，也是我目前主要在用的一个。</p><p>OneManager同样支持云函数搭建，如腾讯，阿里云，百度云，华为云等。我目前将OneManager搭建到了<a href="https://console.cloud.tencent.com/scf/list">腾讯云函数</a>，响应速度还算可以。</p><h3 id="OnePoint"><a href="#OnePoint" class="headerlink" title="OnePoint"></a>OnePoint</h3><p>源码地址：<a href="https://github.com/ukuq/onepoint">onepoint</a></p><p>Demo：<a href="https://onepoint.onesrc.workers.dev/">OnePoint Demo</a></p><p>这是一个以Node.js为核心的网盘索引程序。目前支持的网盘有：</p><ul><li>OneDrive</li><li>Google Drive</li><li>coding</li><li>Teambition</li><li>node_fs</li></ul><p>由于Nodejs的核心，它甚至可以部署在<a href="https://workers.cloudflare.com/">CloudFlare Workers</a>上（虽然CloudFlare的速度感人）。</p><p>OnePoint支持文件访问代理，之前一段时间OD的文件下载速度非常玄学，用代理之后会快一点，多线程下载搭配代理使用更佳。不过最近听说OD换了微软Azure的CDN，访问下载速度有可观的改善。</p><p>有一点忘了提了，上面两个的网站界面做的都一般，极大降低用户体验<del>(bushi)</del></p><p>不过这两个程序都是可以自己定义界面主题的，虽然开发起来有些麻烦就是了。</p><p>而下面的这个界面就比较简洁大方了。</p><h3 id="ShareList"><a href="#ShareList" class="headerlink" title="ShareList"></a>ShareList</h3><p>源码地址：<a href="https://github.com/reruin/sharelist">sharelist</a></p><p>Demo：无</p><p>ShareList同样是Nodejs核心，但是与上面两个相比，Sharelist支持的网盘就比较多，有：</p><ul><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/googledrive">Google Drive</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/onedrive">One Drive</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/ctyun">天翼云</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/caiyun">和彩云</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/lanzou">蓝奏云</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/local">本地文件</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/webdav">WebDAV</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/sftp">SFTP</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/teambition">Teambition</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/baidu">Baidu</a></li><li><a href="https://reruin.github.io/sharelist/docs/#/zh-cn/plugins/aliyundrive">Aliyun Drive</a></li></ul><p>而且Sharelist也支持流量中转，不过没有在线上传文件的功能。但对于展示而言，ShareList的功能已经完全够用了。</p><p>不过它也有缺点，由于没有对云函数做专门的适配，目前只能部署在服务器、Heroku、Workers上。</p><h3 id="PyOne"><a href="#PyOne" class="headerlink" title="PyOne"></a>PyOne</h3><p><strong>注意：此项目已停止维护</strong></p><p>源码地址：<a href="https://github.com/abbeyokgo/PyOne">PyOne</a></p><p>Demo：无</p><p>由于改项目以Python为后端核心，暂时没有合适的服务器部署，而且作者貌似不再维护，但我还是把这个项目贴了出来。因为光看文档就能看出来，这是一个相当强大的网盘程序。文档地址：<a href="https://abbeyokgo.github.io/">https://abbeyokgo.github.io/</a></p><p>不过，这么强大的程序却只支持OneDrive，算是美中不足的一点。</p><h3 id="Alist"><a href="#Alist" class="headerlink" title="Alist"></a>Alist</h3><p>源码地址：<a href="https://github.com/Xhofe/alist">alist</a></p><p>Demo：<a href="https://alist.nn.ci/">Alist Demo</a></p><p>这是一个刚诞生不久的网盘索引程序，以性能出众的Go语言为后端核心，<strong>只支持阿里云盘</strong>。</p><p>虽然只支持阿里云盘，但它任然有很多的可圈可点之处。如：前后端分离、后端逻辑清晰、支持文件上传、加密访问等等。</p><p>虽然以Go为核心，但程序的运行方式只有编译好的可执行文件，极大的降低了学习成本。不过可执行文件目前只能运行在服务器上就是了。</p><p>但这并不算缺点，由于前后端分离的特性，里可以把前端运行在任何支持Vue.js的Nodejs环境中，比如云函数、Heroku、Vercel（当然服务器也可以），极大的节省了流量开销。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>由于本人擅长造轮子的性格(bushi)，一直觉得目前的网盘索引程序不是那么完美，既然如此，就想在有生之年开发一个自己的网盘索引程序，打算以Nodejs为核心(毕竟轻量)，希望在有生之年能看到吧~（这不又给自己挖了个新坑）</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired和@Resource的区别</title>
      <link href="/2023/02/25/@Autowired%E5%92%8C@Resource/"/>
      <url>/2023/02/25/@Autowired%E5%92%8C@Resource/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h1><blockquote><p>Spring的一大核心功能就是IOC，它能帮助我们实现自动装配，</p></blockquote><hr><ul><li>@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</li></ul><p>当我们在将一个类上标注@Service或者@Controller或@Component或@Repository注解之后，<em><strong>spring的组件扫描就会自动发现它，并且会将其初始化为spring应用上下文中的bean。</strong></em></p><p>当需要使用这个bean的时候，例如加上@Autowired注解的时候，这个bean就会被创建。而且初始化是根据无参构造函数。</p><p>注释可以直接在属性上使用，因此不需要getter和setter:</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooFormatter</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建FooService时，Spring查找并注入fooFormatter。</p><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p>1、@Resource是JDK原生的注解，@Autowired是Spring2.5 引入的注解</p><p>2、@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>@Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。</p><p><strong>@Autowired</strong></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303252014969.webp" alt="img"></p><p><strong>@Resource</strong></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303252015360.webp" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@Autowired功能虽说非常强大，但是也有些不足之处。比如它跟Spring强耦合了，如果换成了其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。</p><p>除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。</p><p>1、@Autowired默认按byType自动装配，而@Resource默认byName自动装配。</p><p>2、@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。</p><p>3、@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。</p><p>4、@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。</p><p>5、@Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。</p><p>6、二者装配顺序不同</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最简单的编程语言</title>
      <link href="/2022/12/30/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
      <url>/2022/12/30/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="最简单的编程语言"><a href="#最简单的编程语言" class="headerlink" title="最简单的编程语言"></a>最简单的编程语言</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>为了提高工作效率，巨硬公司决定开发一种新型的编程语言。由于是从零开始开发，难度可想而知。不过，即使是当今世界上最强大的编程语言，也不是刚被发明出来就马上拥有强大功能的，它们都是通过慢慢的改进从而逐渐强大起来的。因此公司决定先将该编程语言的最基本部分做出来，以后再渐渐扩充其它功能。该编程语言最基本的部分是计算。作为公司的首席程序设计师，你的任务就是完成该功能。 </p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入由两部分组成：变量定义部分和表达式计算部分。在变量定义部分中，每一行只能定义一个变量，并且一定要赋上一个初值。计算部分则是每一行有一个表达式，表达式由变量和操作符组成，符号和变量之间用一个空格分隔，且符号只能取+、-、*、&#x2F;这四种，变量定义部分和表达式计算机部分之间用%%%进行分隔，下面是一个例子：<br>a &#x3D; 4<br>b &#x3D; 2<br>%%%<br>a + b<br>a - b</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>表达式的结果，每行输入一个结果</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 4</span><br><span class="line">b = 2</span><br><span class="line">c = 1</span><br><span class="line">%%%</span><br><span class="line">a + b + c</span><br><span class="line">a - b - c</span><br><span class="line">a - a</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;%%%&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">            String[] ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">put</span> <span class="operator">=</span> Integer.parseInt(ss[<span class="number">2</span>]);</span><br><span class="line">            hashMap.put(ss[<span class="number">0</span>], put);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] ss1 = s1.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> hashMap.get(ss1[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ss1.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ss1[i].equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    sum += hashMap.get(ss1[i + <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ss1[i].equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    sum -= hashMap.get(ss1[i + <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ss1[i].equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    sum *= hashMap.get(ss1[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2022/12/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-实现多线程"><a href="#1-实现多线程" class="headerlink" title="1.实现多线程"></a>1.实现多线程</h2><h3 id="1-1进程和线程【理解】"><a href="#1-1进程和线程【理解】" class="headerlink" title="1.1进程和线程【理解】"></a>1.1进程和线程【理解】</h3><ul><li><p>进程：是正在运行的程序</p><p> 是系统进行资源分配和调用的独立单位</p><p> 每一个进程都有它自己的内存空间和系统资源</p></li><li><p>线程：是进程中的单个顺序控制流，是一条执行路径</p><p> 单线程：一个进程如果只有一条执行路径，则称为单线程程序</p><p> 多线程：一个进程如果有多条执行路径，则称为多线程程序</p></li></ul><h3 id="1-2实现多线程方式一：继承Thread类【应用】"><a href="#1-2实现多线程方式一：继承Thread类【应用】" class="headerlink" title="1.2实现多线程方式一：继承Thread类【应用】"></a>1.2实现多线程方式一：继承Thread类【应用】</h3><ul><li><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void run()</td><td>在线程开启后，此方法将被调用执行</td></tr><tr><td>void start()</td><td>使此线程开始执行，Java虚拟机会调用run方法()</td></tr></tbody></table></li><li><p>实现步骤</p><ul><li>定义一个类MyThread继承Thread类</li><li>在MyThread类中重写run()方法</li><li>创建MyThread类的对象</li><li>启动线程</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        my1.run();</span></span><br><span class="line"><span class="comment">//        my2.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法</span></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li><li><p>两个小问题</p><ul><li><p>为什么要重写run()方法？</p><p>因为run()是用来封装被线程执行的代码</p></li><li><p>run()方法和start()方法的区别？</p><p>run()：封装线程执行的代码，直接调用，相当于普通方法的调用</p><p>start()：启动线程；然后由JVM调用此线程的run()方法</p></li></ul></li></ul><h3 id="1-3设置和获取线程名称【应用】"><a href="#1-3设置和获取线程名称【应用】" class="headerlink" title="1.3设置和获取线程名称【应用】"></a>1.3设置和获取线程名称【应用】</h3><ul><li><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void setName(String name)</td><td>将此线程的名称更改为等于参数name</td></tr><tr><td>String getName()</td><td>返回此线程的名称</td></tr><tr><td>Thread currentThread()</td><td>返回对当前正在执行的线程对象的引用</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void setName(String name)：将此线程的名称更改为等于参数 name</span></span><br><span class="line">        my1.setName(<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        my2.setName(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread(String name)</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line"></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static Thread currentThread() 返回对当前正在执行的线程对象的引用</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4线程优先级【应用】"><a href="#1-4线程优先级【应用】" class="headerlink" title="1.4线程优先级【应用】"></a>1.4线程优先级【应用】</h3><ul><li><p>线程调度</p><ul><li><p>两种调度方式</p><ul><li>分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li><li>抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些</li></ul></li><li><p>Java使用的是抢占式调度模型</p></li><li><p>随机性</p><p>假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的</p></li></ul></li><li><p>优先级相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>final void setPriority(int newPriority)</td><td>更改此线程的优先级 线程默认优先级是5；线程优先级的范围是：1-10</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPriority</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPriorityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPriority</span> <span class="variable">tp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPriority</span>();</span><br><span class="line">        <span class="type">ThreadPriority</span> <span class="variable">tp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPriority</span>();</span><br><span class="line">        <span class="type">ThreadPriority</span> <span class="variable">tp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPriority</span>();</span><br><span class="line"></span><br><span class="line">        tp1.setName(<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        tp2.setName(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        tp3.setName(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public final int getPriority()：返回此线程的优先级</span></span><br><span class="line">        System.out.println(tp1.getPriority()); <span class="comment">//5</span></span><br><span class="line">        System.out.println(tp2.getPriority()); <span class="comment">//5</span></span><br><span class="line">        System.out.println(tp3.getPriority()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public final void setPriority(int newPriority)：更改此线程的优先级</span></span><br><span class="line"><span class="comment">//        tp1.setPriority(10000); //IllegalArgumentException</span></span><br><span class="line">        System.out.println(Thread.MAX_PRIORITY); <span class="comment">//10</span></span><br><span class="line">        System.out.println(Thread.MIN_PRIORITY); <span class="comment">//1</span></span><br><span class="line">        System.out.println(Thread.NORM_PRIORITY); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置正确的优先级</span></span><br><span class="line">        tp1.setPriority(<span class="number">5</span>);</span><br><span class="line">        tp2.setPriority(<span class="number">10</span>);</span><br><span class="line">        tp3.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        tp1.start();</span><br><span class="line">        tp2.start();</span><br><span class="line">        tp3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5线程控制【应用】"><a href="#1-5线程控制【应用】" class="headerlink" title="1.5线程控制【应用】"></a>1.5线程控制【应用】</h3><ul><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static void sleep(long millis)</td><td>使当前正在执行的线程停留（暂停执行）指定的毫秒数</td></tr><tr><td>void join()</td><td>等待这个线程死亡</td></tr><tr><td>void setDaemon(boolean on)</td><td>将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">sleep演示：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSleep</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSleepDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadSleep</span> <span class="variable">ts1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSleep</span>();</span><br><span class="line">        <span class="type">ThreadSleep</span> <span class="variable">ts2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSleep</span>();</span><br><span class="line">        <span class="type">ThreadSleep</span> <span class="variable">ts3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSleep</span>();</span><br><span class="line"></span><br><span class="line">        ts1.setName(<span class="string">&quot;曹操&quot;</span>);</span><br><span class="line">        ts2.setName(<span class="string">&quot;刘备&quot;</span>);</span><br><span class="line">        ts3.setName(<span class="string">&quot;孙权&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ts1.start();</span><br><span class="line">        ts2.start();</span><br><span class="line">        ts3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Join演示：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadJoin</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadJoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadJoin</span> <span class="variable">tj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadJoin</span>();</span><br><span class="line">        <span class="type">ThreadJoin</span> <span class="variable">tj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadJoin</span>();</span><br><span class="line">        <span class="type">ThreadJoin</span> <span class="variable">tj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadJoin</span>();</span><br><span class="line"></span><br><span class="line">        tj1.setName(<span class="string">&quot;康熙&quot;</span>);</span><br><span class="line">        tj2.setName(<span class="string">&quot;四阿哥&quot;</span>);</span><br><span class="line">        tj3.setName(<span class="string">&quot;八阿哥&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tj1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tj1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        tj2.start();</span><br><span class="line">        tj3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Daemon演示：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDaemon</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDaemonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDaemon</span> <span class="variable">td1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDaemon</span>();</span><br><span class="line">        <span class="type">ThreadDaemon</span> <span class="variable">td2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDaemon</span>();</span><br><span class="line"></span><br><span class="line">        td1.setName(<span class="string">&quot;关羽&quot;</span>);</span><br><span class="line">        td2.setName(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置主线程为刘备</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;刘备&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置守护线程</span></span><br><span class="line">        td1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        td2.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6线程的生命周期【理解】"><a href="#1-6线程的生命周期【理解】" class="headerlink" title="1.6线程的生命周期【理解】"></a>1.6线程的生命周期【理解】</h3><p> 线程一共有五种状态，线程在各种状态之间转换。</p><p><img src="https://javadocs.zkeq.xyz/java-02/img11/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="img"></p><h3 id="1-7实现多线程方式二：实现Runnable接口【应用】"><a href="#1-7实现多线程方式二：实现Runnable接口【应用】" class="headerlink" title="1.7实现多线程方式二：实现Runnable接口【应用】"></a>1.7实现多线程方式二：实现Runnable接口【应用】</h3><ul><li><p>Thread构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Thread(Runnable target)</td><td>分配一个新的Thread对象</td></tr><tr><td>Thread(Runnable target, String name)</td><td>分配一个新的Thread对象</td></tr></tbody></table></li><li><p>实现步骤</p><ul><li>定义一个类MyRunnable实现Runnable接口</li><li>在MyRunnable类中重写run()方法</li><li>创建MyRunnable类的对象</li><li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li><li>启动线程</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建MyRunnable类的对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的对象，把MyRunnable对象作为构造方法的参数</span></span><br><span class="line">        <span class="comment">//Thread(Runnable target)</span></span><br><span class="line"><span class="comment">//        Thread t1 = new Thread(my);</span></span><br><span class="line"><span class="comment">//        Thread t2 = new Thread(my);</span></span><br><span class="line">        <span class="comment">//Thread(Runnable target, String name)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li><li><p>多线程的实现方案有两种</p><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul></li><li><p>相比继承Thread类，实现Runnable接口的好处</p><ul><li>避免了Java单继承的局限性</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li></ul></li></ul><h2 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2.线程同步"></a>2.线程同步</h2><h3 id="2-1卖票【应用】案例需求"><a href="#2-1卖票【应用】案例需求" class="headerlink" title="2.1卖票【应用】案例需求"></a>2.1卖票【应用】案例需求</h3><ul><li><p>某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票</p></li><li><p>实现步骤</p><ul><li>定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets &#x3D; 100;</li><li>在SellTicket类中重写run()方法实现卖票，代码步骤如下</li><li>判断票数大于0，就卖票，并告知是哪个窗口卖的</li><li>卖了票之后，总票数要减1</li><li>票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行</li><li>定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下</li><li>创建SellTicket类的对象</li><li>创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</li><li>启动线程</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//在SellTicket类中重写run()方法实现卖票，代码步骤如下</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建SellTicket类的对象</span></span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li><li><p>执行结果</p></li></ul><h3 id="2-2卖票案例的问题【理解】"><a href="#2-2卖票案例的问题【理解】" class="headerlink" title="2.2卖票案例的问题【理解】"></a>2.2卖票案例的问题【理解】</h3><ul><li><p>卖票出现了问题</p><ul><li>相同的票出现了多次</li><li>出现了负数的票</li></ul></li><li><p>问题产生原因</p><p>线程执行的随机性导致的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//相同的票出现了多次</span></span><br><span class="line"><span class="comment">//        while (true) &#123;</span></span><br><span class="line"><span class="comment">//            //tickets = 100;</span></span><br><span class="line"><span class="comment">//            //t1,t2,t3</span></span><br><span class="line"><span class="comment">//            //假设t1线程抢到CPU的执行权</span></span><br><span class="line"><span class="comment">//            if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//                //通过sleep()方法来模拟出票时间</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//                    //t1线程休息100毫秒</span></span><br><span class="line"><span class="comment">//                    //t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒</span></span><br><span class="line"><span class="comment">//                    //t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                //假设线程按照顺序醒过来</span></span><br><span class="line"><span class="comment">//                //t1抢到CPU的执行权，在控制台输出：窗口1正在出售第100张票</span></span><br><span class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);</span></span><br><span class="line"><span class="comment">//                //t2抢到CPU的执行权，在控制台输出：窗口2正在出售第100张票</span></span><br><span class="line"><span class="comment">//                //t3抢到CPU的执行权，在控制台输出：窗口3正在出售第100张票</span></span><br><span class="line"><span class="comment">//                tickets--;</span></span><br><span class="line"><span class="comment">//                //如果这三个线程还是按照顺序来，这里就执行了3次--的操作，最终票就变成了97</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//出现了负数的票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//tickets = 1;</span></span><br><span class="line">            <span class="comment">//t1,t2,t3</span></span><br><span class="line">            <span class="comment">//假设t1线程抢到CPU的执行权</span></span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//通过sleep()方法来模拟出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">//t1线程休息100毫秒</span></span><br><span class="line">                    <span class="comment">//t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒</span></span><br><span class="line">                    <span class="comment">//t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//假设线程按照顺序醒过来</span></span><br><span class="line">                <span class="comment">//t1抢到了CPU的执行权，在控制台输出：窗口1正在出售第1张票</span></span><br><span class="line">                <span class="comment">//假设t1继续拥有CPU的执行权，就会执行tickets--;操作，tickets = 0;</span></span><br><span class="line">                <span class="comment">//t2抢到了CPU的执行权，在控制台输出：窗口1正在出售第0张票</span></span><br><span class="line">                <span class="comment">//假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -1;</span></span><br><span class="line">                <span class="comment">//t3抢到了CPU的执行权，在控制台输出：窗口3正在出售第-1张票</span></span><br><span class="line">                <span class="comment">//假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -2;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3同步代码块解决数据安全问题【应用】"><a href="#2-3同步代码块解决数据安全问题【应用】" class="headerlink" title="2.3同步代码块解决数据安全问题【应用】"></a>2.3同步代码块解决数据安全问题【应用】</h3><ul><li><p>安全问题出现的条件</p><ul><li>是多线程环境</li><li>有共享数据</li><li>有多条语句操作共享数据</li></ul></li><li><p>如何解决多线程安全问题呢?</p><ul><li>基本思想：让程序没有安全问题的环境</li></ul></li><li><p>怎么实现呢?</p><ul><li>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</li><li>Java提供了同步代码块的方式来解决</li></ul></li><li><p>同步代码块格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象) &#123; </span><br><span class="line">    多条语句操作共享数据的代码 </span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁</p></li><li><p>同步的好处和弊端</p><ul><li>好处：解决了多线程的数据安全问题</li><li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//tickets = 100;</span></span><br><span class="line">            <span class="comment">//t1,t2,t3</span></span><br><span class="line">            <span class="comment">//假设t1抢到了CPU的执行权</span></span><br><span class="line">            <span class="comment">//假设t2抢到了CPU的执行权</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="comment">//t1进来后，就会把这段代码给锁起来</span></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="comment">//t1休息100毫秒</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--; <span class="comment">//tickets = 99;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//t1出来了，这段代码的锁就被释放了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4同步方法解决数据安全问题【应用】"><a href="#2-4同步方法解决数据安全问题【应用】" class="headerlink" title="2.4同步方法解决数据安全问题【应用】"></a>2.4同步方法解决数据安全问题【应用】</h3><ul><li><p>同步方法的格式</p><p>同步方法：就是把synchronized关键字加到方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">    方法体；</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>同步方法的锁对象是什么呢?</p><p> this</p></li><li><p>静态同步方法</p><p>同步静态方法：就是把synchronized关键字加到静态方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">    方法体；</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>同步静态方法的锁对象是什么呢?</p><p> 类名.class</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            sellTicket()；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    同步方法</span></span><br><span class="line"><span class="comment">//    private synchronized void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//        if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);</span></span><br><span class="line"><span class="comment">//            tickets--;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  静态同步方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5线程安全的类【理解】"><a href="#2-5线程安全的类【理解】" class="headerlink" title="2.5线程安全的类【理解】"></a>2.5线程安全的类【理解】</h3><ul><li>StringBuffer<ul><li>线程安全，可变的字符序列</li><li>从版本JDK 5开始，被StringBuilder 替代。 通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步</li></ul></li><li>Vector<ul><li>从Java 2平台v1.2开始，该类改进了List接口，使其成为Java Collections Framework的成员。 与新的集合实现不同， Vector被同步。 如果不需要线程安全的实现，建议使用ArrayList代替Vector</li></ul></li><li>Hashtable<ul><li>该类实现了一个哈希表，它将键映射到值。 任何非null对象都可以用作键或者值</li><li>从Java 2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections Framework的成员。 与新的集合实现不同， Hashtable被同步。 如果不需要线程安全的实现，建议使用HashMap代替Hashtable</li></ul></li></ul><h3 id="2-6Lock锁【应用】"><a href="#2-6Lock锁【应用】" class="headerlink" title="2.6Lock锁【应用】"></a>2.6Lock锁【应用】</h3><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock</p><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</p><ul><li><p>ReentrantLock构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ReentrantLock()</td><td>创建一个ReentrantLock的实例</td></tr></tbody></table></li><li><p>加锁解锁方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>获得锁</td></tr><tr><td>void unlock()</td><td>释放锁</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-生产者消费者"><a href="#3-生产者消费者" class="headerlink" title="3.生产者消费者"></a>3.生产者消费者</h2><h3 id="3-1生产者和消费者模式概述【应用】"><a href="#3-1生产者和消费者模式概述【应用】" class="headerlink" title="3.1生产者和消费者模式概述【应用】"></a>3.1生产者和消费者模式概述【应用】</h3><ul><li><p>概述</p><p>生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。</p><p>所谓生产者消费者问题，实际上主要是包含了两类线程：</p><p> 一类是生产者线程用于生产数据</p><p> 一类是消费者线程用于消费数据</p><p>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库</p><p>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为</p><p>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为</p><p><img src="https://javadocs.zkeq.xyz/java-02/img11/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9.jpg" alt="img"></p></li><li><p>Object类的等待和唤醒方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void wait()</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法</td></tr><tr><td>void notify()</td><td>唤醒正在等待对象监视器的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待对象监视器的所有线程</td></tr></tbody></table></li></ul><h3 id="3-2生产者和消费者案例【应用】"><a href="#3-2生产者和消费者案例【应用】" class="headerlink" title="3.2生产者和消费者案例【应用】"></a>3.2生产者和消费者案例【应用】</h3><ul><li><p>案例需求</p><p>生产者消费者案例中包含的类：</p><p>奶箱类(Box)：定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作</p><p>生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶的操作</p><p>消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶的操作</p><p>测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下</p><p>①创建奶箱对象，这是共享数据区域</p><p>②创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</p><p>③对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</p><p>④创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</p><p>⑤启动线程</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> milk)</span> &#123;</span><br><span class="line">        <span class="comment">//如果有牛奶，等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="built_in">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="built_in">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="built_in">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Box b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Box b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            b.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        <span class="type">Box</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(b);</span><br><span class="line">        <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt 禁用 IPv6</title>
      <link href="/2022/11/26/OpenWrt%20%E7%A6%81%E7%94%A8%20IPv6/"/>
      <url>/2022/11/26/OpenWrt%20%E7%A6%81%E7%94%A8%20IPv6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenWrt-禁用-IPv6"><a href="#OpenWrt-禁用-IPv6" class="headerlink" title="OpenWrt 禁用 IPv6"></a>OpenWrt 禁用 IPv6</h1><p>你是否遇到过这种情况，访问一些网站，时不时出现 connection reset，刷新几下就好了，再刷新就又这样了。</p><p>或者遇到 “网页可能暂时无法连接,或者它已永久性地移动到了新网址”。</p><p>这很可能是 IPv6 引起的，在 IPv4&#x2F;IPv6 双栈网络下，IPv6 的优先级比 IPv4 高，通过 IPv6 访问很可能出现不稳定的情况。</p><p>去 Openwrt -&gt; 网络 -&gt; 接口：</p><ol><li>删除 WAN6 接口</li><li>找到 LAN -&gt; 高级设置，禁用<strong>IPv6分配长度</strong>。</li><li>进入 LAN -&gt; DHCP服务器，把 IPv6设置 的 “<strong>RA服务、DHCPv6服务、NDP代理</strong>” 全部禁用</li><li>找到 WAN -&gt; 高级设置，禁用<strong>获取IPv6地址</strong>和<strong>IPv6分配长度</strong>。</li><li>进入 WAN -&gt; DHCP服务器，把 IPv6设置 的 “<strong>RA服务、DHCPv6服务、NDP代理</strong>” 全部禁用</li><li>保存，可以重启一下</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenWrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器常用操作整理</title>
      <link href="/2022/11/25/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2022/11/25/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>服务器玩的多了之后，各种常用的操作越来越多了，每次用都还得上网搜一下很麻烦，于是打算写一篇文章来总结一下。</p><h3 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h3><p>先介绍一下EPEL源：</p><blockquote><p><strong>EPEL源</strong> (Extra Packages for Enterprise Linux) 是由 Fedora Special Interest Group 为企业 Linux 创建、维护和管理的一个高质量附加包集合适用于但不仅限于 Red Hat Enterprise Linux (RHEL), CentOS, Scientific Linux (SL), Oracle Linux (OL)</p></blockquote><p>配置 EPEL源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum -y update</span><br></pre></td></tr></table></figure><h4 id="Nginx安装及配置"><a href="#Nginx安装及配置" class="headerlink" title="Nginx安装及配置"></a>Nginx安装及配置</h4><p>安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure><p>安装成功后，默认的网站目录为： <code>/usr/share/nginx/html</code></p><p>默认的配置文件为：<code>/etc/nginx/nginx.conf</code></p><p>自定义配置文件目录为: <code>/etc/nginx/conf.d/</code></p><p><strong>监听80端口并跳转443端口：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name xxx.xxx.xxx;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>监听443端口并导入证书：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">server&#123;</span><br><span class="line"># 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块</span><br><span class="line">listen       443 ssl;</span><br><span class="line"># 域名，多个以空格分开</span><br><span class="line">server_name  xxx.xxx.xxx</span><br><span class="line"></span><br><span class="line"># ssl证书地址</span><br><span class="line">ssl_certificate     /usr/local/nginx/cert/ssl.pem;  # pem文件的路径</span><br><span class="line">ssl_certificate_key  /usr/local/nginx/cert/ssl.key; # key文件的路径</span><br><span class="line"></span><br><span class="line"># ssl验证相关配置</span><br><span class="line">ssl_session_timeout  5m;    #缓存有效期</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议</span><br><span class="line">ssl_prefer_server_ciphers on;   #使用服务器端的首选算法</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>端口转发：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_pass http://127.0.0.1:5212/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Node-js-环境安装及配置"><a href="#Node-js-环境安装及配置" class="headerlink" title="Node.js 环境安装及配置"></a>Node.js 环境安装及配置</h4><p><strong>普通安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sudo yum install nodejs</span><br></pre></td></tr></table></figure><p><strong>使用NVM安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>因为我电脑上的node是14.15.1版本，所以服务器上也安装这个版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">nvm install v14.15.1</span><br><span class="line">nvm use v14.15.1</span><br></pre></td></tr></table></figure><h4 id="MySQL安装及配置"><a href="#MySQL安装及配置" class="headerlink" title="MySQL安装及配置"></a>MySQL安装及配置</h4><p><strong>下载并安装MySQL官方的Yum Repository：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>使用上面的命令直接安装Yum Repository：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>安装MySQL服务器：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><p><strong>启动MySQL：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">systemctl start  mysqld.service</span><br></pre></td></tr></table></figure><p>此时MySQL已经开始正常运行，需要找出root的密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>登录MySQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入初始密码，此时不能做任何事情，因为MYSQL默认必须修改密码才能正常使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;;</span><br><span class="line"></span><br><span class="line"># 这里会遇到一个问题，新密码设置过于简单会报错</span><br></pre></td></tr></table></figure><p>MySQL配置文件目录：<code>/etc/my.cnf</code></p><p>另外提一下，MySQL占用内存好像有点高，在我的VPS上占了将近150MB的内存，我总共内存才1G，所以下次考虑使用外置的SQL Server或者干脆用sqlite3吧。</p><h3 id="Linux系统配置"><a href="#Linux系统配置" class="headerlink" title="Linux系统配置"></a>Linux系统配置</h3><h4 id="添加Swap分区"><a href="#添加Swap分区" class="headerlink" title="添加Swap分区"></a>添加Swap分区</h4><p>创建一个swap文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">dd if=/dev/zero of=/swapfile bs=1024 count=1024000</span><br></pre></td></tr></table></figure><p>更改Swap文件的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure><p>使用如下命令告知系统将该文件用于swap：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">mkswap /var/swapfile</span><br></pre></td></tr></table></figure><p>输入如下命令开始使用该swap：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">swapon /var/swapfile</span><br></pre></td></tr></table></figure><p>自动挂载，编辑<code>/etc/fstab</code>，在最后加上一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">/swapfile swap    swap    defaults      0    0</span><br></pre></td></tr></table></figure><h3 id="一键脚本整理"><a href="#一键脚本整理" class="headerlink" title="一键脚本整理"></a>一键脚本整理</h3><h4 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h4><p>Xray脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">wget -N --no-check-certificate -q -O install.sh &quot;https://raw.githubusercontent.com/wulabing/Xray_onekey/main/install.sh&quot; &amp;&amp; chmod +x install.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure><p>配置文件目录为：<code>/usr/local/etc/xray/config.json</code></p><p>Trojan脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">source &lt;(curl -sL https://git.io/trojan-install)</span><br></pre></td></tr></table></figure><p>配置文件目录为：<code>/etc/trojan-go/config.json</code></p><h4 id="软件类"><a href="#软件类" class="headerlink" title="软件类"></a>软件类</h4><p><a href="https://github.com/cloudreve/Cloudreve">Cloudreve</a>部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"># 解压程序包</span><br><span class="line">tar -zxvf cloudreve_VERSION_OS_ARCH.tar.gz</span><br><span class="line"></span><br><span class="line"># 赋予执行权限</span><br><span class="line">chmod +x ./cloudreve</span><br><span class="line"></span><br><span class="line"># 启动 Cloudreve</span><br><span class="line">./cloudreve</span><br></pre></td></tr></table></figure><h3 id="常用命令整理"><a href="#常用命令整理" class="headerlink" title="常用命令整理"></a>常用命令整理</h3><h4 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h4><p>tar命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">tar –xvf file.tar  # 解压 tar包</span><br><span class="line">tar -xzvf file.tar.gz  # 解压tar.gz</span><br><span class="line">tar -xzvf file.tar.gz -C /home/tar  # 解压tar.gz到tar目录</span><br></pre></td></tr></table></figure><p>unrar&#x2F;unzip命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">unzip file.zip</span><br><span class="line">unrar e file.rar</span><br></pre></td></tr></table></figure><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>chmod命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">chmod 777 xxx.tar # 将xxx的权限设置为777</span><br></pre></td></tr></table></figure><p>chown命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">chown root file # 将file的所有者设置为root</span><br><span class="line">chown root:root file # 将file的所有者和用户组设置为root</span><br></pre></td></tr></table></figure><h4 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h4><p>find命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">find /dir -name &#x27;file.so&#x27;</span><br><span class="line"># 在/dir目录下搜索file.so文件</span><br></pre></td></tr></table></figure><h4 id="系统占用"><a href="#系统占用" class="headerlink" title="系统占用"></a>系统占用</h4><p>查看剩余内存：<code>free -h</code></p><p>以占用内存大小为顺序显示后台进程：<code>top -o %MEM</code></p><p>以占用CPU大小为顺序显示后台进程：<code>top -o %CPU</code></p><p>查看分区和磁盘：<code>lsblk</code></p><p>查看空间使用情况：<code>df -h</code></p><p>分区工具查看分区信息：<code>fdisk -l</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 是如何保证数据安全</title>
      <link href="/2022/11/12/HTTPS%20%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
      <url>/2022/11/12/HTTPS%20%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTPS-是如何保证数据安全"><a href="#HTTPS-是如何保证数据安全" class="headerlink" title="HTTPS 是如何保证数据安全"></a>HTTPS 是如何保证数据安全</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文简要介绍HTTPS协议是如何保证数据在传输过程中的安全的。<br>由于是以介绍为主，所以不会涉及细节，而且<strong>肯定会有一些错误</strong>。如果想要详细了解可自行查阅资料。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在HTTPS协议出现前大家用的都是HTTP协议，这种协议传输的都是明文信息，任何人都可以窃取并篡改，毫无安全性可言。</p><p>HTTP协议的简要通信流程如下图：</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724626.webp" alt="img"></p><p><em>HTTP 协议简要通信流程</em></p><p>由于传输的信息都是明文的，所以攻击者就可以窃取并篡改信息，如下图：</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724441.webp" alt="img"></p><p><em>中间人攻击</em></p><hr><p>你可能会想，我们把信息加密不就可以了么，比如像下图一样</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724505.webp" alt="img"></p><p><em>使用对称密钥加密信息</em></p><blockquote><p>对称加密：双方持有同一个对称密钥，任何一方通过对称密钥加密的信息，对方可以通过相同的对称密钥解密出原文。</p></blockquote><p>但是攻击者依然可以通过各种方式获取到对称密钥：</p><ul><li>如果密钥是通过服务器下发给客户端，则直接截取服务器的消息就行了。</li><li>如果对称密钥是提前保存在双方的电脑上，那就可以通过某种手段入侵客户端或者服务器来窃取对称密钥。</li><li>其它方式。</li></ul><p>截取到密钥后攻击者仍然可以进行攻击</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724428.webp" alt="img"></p><p><em>中间人攻击</em></p><hr><p>那么我们就需要对“对称密钥”进行保护了，如下图</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724139.webp" alt="img"></p><p><em>保护对称密钥</em></p><blockquote><p>非对称加密：一方持有私钥，一方持有公钥，使用公钥加密的信息只能被私钥解密。私钥不会用于加密，不过通常会用于加一段签名代表信息是完整，即信息是否丢失了一部分或者因为某种原因而发生的改变。</p></blockquote><p>这次攻击者看似无法通过截取信息来获得对称密钥了，但是攻击者依然有机会发起攻击。</p><p>不过先说明一点，目前公钥都是通过服务器下发的证书获得的，所以更接近下图相对来说更接近真实的通信流程</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724242.webp" alt="img"></p><p><em>服务器下发证书</em></p><p>那么攻击者会怎样攻击呢？如下图（图片如果看不清可以右键图片选择“在新的标签页中打开图像”或类似选项）</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724687.webp" alt="img"></p><p><em>中间人攻击</em></p><hr><p>这时显然不能对公钥再次加密了，因为无法判断客户端得到的证书是真的，还是攻击者伪造的。<br>这时就需要第三方介入了</p><ol><li>合法服务器的证书都是经过审核机构审核的，服务器在下发证书的时候就会下发经过审核的证书</li><li>客户端会存有经过审核的证书的列表。</li><li>客户端收到服务器下发的证书后会验证收到的证书是否经过了审核。</li><li>如果经过了审核则继续通信，反之断开连接或者弹出警告。</li></ol><p>现在的通信流程图下图，也是HTTPS的大致通信流程</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101724434.webp" alt="img"></p><p><em>更接近于 HTTPS 的通信流程</em></p><hr><p>不过HTTPS的一大软肋就是第三方证书审核机构，如果审核不严将攻击者的证书列入了合法证书列表，那么HTTPS所作的努力将全部白费。</p><p>总的来说，HTTPS增加了攻击者的攻击成本，使得数据的传输过程变得更加完全。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 工作区代码临时存储</title>
      <link href="/2022/10/26/Git%20%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%BB%A3%E7%A0%81%E4%B8%B4%E6%97%B6%E5%AD%98%E5%82%A8/"/>
      <url>/2022/10/26/Git%20%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%BB%A3%E7%A0%81%E4%B8%B4%E6%97%B6%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git-工作区代码临时存储"><a href="#Git-工作区代码临时存储" class="headerlink" title="Git 工作区代码临时存储"></a>Git 工作区代码临时存储</h1><p>有时需要提交一次代码，但是有一部分新写上的代码还是半成品，又不舍得删除。或者在切换分支时工作目录和暂存区里那些还没有被提交的修改，它可能会和即将检出的分支产生冲突从而阻止 Git 切换到该分支。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p><code>git stash</code> 可以解决这个问题。贮藏（stash）会处理工作目录的脏的状态，即跟踪文件的修改与暂存的改动，然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。</p><p><code>git stash</code> 或 <code>git stash push</code>：将当前工作区未追踪的文件和已追踪但被修改过的文件，压入贮藏栈。此时可以切换分支，或着干其他的事情了。干完之后，将贮藏的内容恢复出来即可。</p><p><code>git stash list</code>：查看贮藏栈内容。</p><p><code>git stash apply</code>：将贮藏栈中最顶层的，也就是最新加入的数据，恢复出来。也可以恢复指定内容，例如：<code>git stash apply stash@&#123;2&#125;</code>。恢复之后，贮藏的内容并没有被删除，此时可以用 <code>git stash drop stash@&#123;2&#125;</code> 删除它。或者可以在这之前直接使用 <code>git stash pop</code> 应用并删除。</p><h2 id="从贮藏创建一个分支"><a href="#从贮藏创建一个分支" class="headerlink" title="从贮藏创建一个分支"></a>从贮藏创建一个分支</h2><p>如果贮藏了一些工作，过了段时间，重新应用时出问题了，或者说出现冲突了。可以运行 <code>git stash branch &lt;branchname&gt;</code> 以你指定的分支名创建一个新分支，将会检出贮藏工作时所在的提交，并重新在那应用工作，然后在应用成功后丢弃贮藏。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应对明星重大舆情事件的四阶段战略</title>
      <link href="/2022/10/22/%E5%BA%94%E5%AF%B9%E6%98%8E%E6%98%9F%E9%87%8D%E5%A4%A7%E8%88%86%E6%83%85%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%88%98%E7%95%A5/"/>
      <url>/2022/10/22/%E5%BA%94%E5%AF%B9%E6%98%8E%E6%98%9F%E9%87%8D%E5%A4%A7%E8%88%86%E6%83%85%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%88%98%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应对明星重大舆情事件的四阶段战略"><a href="#应对明星重大舆情事件的四阶段战略" class="headerlink" title="应对明星重大舆情事件的四阶段战略"></a>应对明星重大舆情事件的四阶段战略</h1><h2 id="开篇致敬经典"><a href="#开篇致敬经典" class="headerlink" title="开篇致敬经典"></a>开篇致敬经典</h2><blockquote><p>《是的，首相》</p><p>The four-stage strategy<br>四阶段战略</p><p><strong>In stage one, we say nothing is going to happen.</strong><br>第一阶段，我们宣称什么事都没有发生。</p><p><strong>Stage two, we say something may be going to happen, but we should do nothing about it.</strong><br>第二阶段，我们说也许有事发生但我们不该采取行动。</p><p><strong>Stage three, we say that maybe we should do something about it, but there’s nothing we can do.</strong><br>第三阶段，说也许我们应该采取行动，但是我们什么都做不了。</p><p><strong>Stage four, we say there was something we could have done, but it’s too late now.</strong><br>第四阶段，也许当初我们能做点什么，但现在已经太迟了。</p></blockquote><h2 id="战略总结"><a href="#战略总结" class="headerlink" title="战略总结"></a>战略总结</h2><p><strong>这里的舆情特指和下半身有关的舆情。</strong></p><p>这类舆情事件通常是一方主动对某个明星进行攻击，舆情发展中经常会出现攻守互易、矛盾激化和舆论反转等现象，双方各执一词，互相找对方的言语和相关材料的漏洞。</p><p>不过一般来说事件的核心不是 xxx是不是渣男、xxx 被欺骗、xxx 是 o 婊、xxx 又当又立这些问题。核心就是双方到底犯法没有，犯法了就依法处理。没犯法但违反道德的，如果是明星则不配吃艺人饭，如果是另一方则接收舆论的谴责。</p><h2 id="四阶段战略"><a href="#四阶段战略" class="headerlink" title="四阶段战略"></a>四阶段战略</h2><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>当舆情中对立的双方停留在打嘴炮的阶段我们应该视为什么都没发生，毕竟网络水太深，把握不住。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>当舆情中对立的双方放出了一些未经权威机构证明的材料（如截图和录音），说明舆情有极大概率进一步升级，此时我们应该保持理性的心态。如果难以保持理性或者预设了立场，不要参与到舆情中。</p><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>当舆情的进展表示可能有一方或者双方存在违法犯罪的可能通常已经引起了相关方面的注意，这时可以参与到舆情中成为理性的声音，但更要等待权威机构的调查结果。</p><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><p>当权威的调查结果发布后，我们应该反思在此次事件中自己有没有做错什么。如果调查结果证明了自己预设的立场则更要小心，检查自己预设的立场是否有合理的支撑。</p><ul><li>如果涉事明星完全无辜则万事大吉。</li><li>如果涉事明星违反公序良俗但并未违法犯罪则明星不会受到执法机关的处罚，但也不配吃艺人这碗饭。</li><li>如果涉事明星违法甚至犯罪那么依法处理，艺人这碗饭肯定是吃不成了。</li><li>如果攻击明星的一方完全正确则万事大吉。</li><li>如果攻击明星的一方违反公序良俗但并未违法犯罪则接收舆论的谴责。</li><li>如果攻击明星的一方违法犯罪则依法处理。</li><li>如果攻击明星的一方操纵舆论，将道德问题包装为法律事件则是全员恶人。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八卦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt编译与刷写踩坑记录</title>
      <link href="/2022/10/08/OpenWrt%E7%BC%96%E8%AF%91%E4%B8%8E%E5%88%B7%E5%86%99%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/10/08/OpenWrt%E7%BC%96%E8%AF%91%E4%B8%8E%E5%88%B7%E5%86%99%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近整了一台软路由，配置还不错，既然这样那肯定要折腾折腾，首先肯定是要刷个 <a href="https://openwrt.org/">OpenWrt</a> 嘛，但是网上找到的固件都不太合我心意，要么是软件包过于冗杂，要么是太过精简，于是就想自己编译一个固件来用，接下来便是踩坑的开始。</p><p>老规矩，先上一张成果图：</p><p><a href="https://bu.dusays.com/2021/11/11/0842f99a09ee8.png"><img src="https://bu.dusays.com/2021/11/11/0842f99a09ee8.png" alt="img"></a></p><h3 id="编译部分"><a href="#编译部分" class="headerlink" title="编译部分"></a>编译部分</h3><p>编译所使用的源码是 <a href="https://github.com/coolsnowwolf/lede">Lean’s OpenWrt</a>。这套源码在论坛里很有名，编译成功率也高。</p><h4 id="编译方案"><a href="#编译方案" class="headerlink" title="编译方案"></a>编译方案</h4><p>编译有本地和云端两张方式可选，本来是觉得自己电脑CPU性能还可以要不本地编译吧，但了解到编译过程中需要下载Linux内核以及其他的一大堆东西时，还是选择了云端编译方案，最终选用了 <a href="https://github.com/P3TERX/Actions-OpenWrt">P3TERX 的 Github Actions 编译方案</a>。</p><h4 id="编译配置问题"><a href="#编译配置问题" class="headerlink" title="编译配置问题"></a>编译配置问题</h4><p>在配置时碰到了好几个问题，这里记录一下。</p><p><strong>首先是目标镜像的文件系统问题。</strong>一般情况下大部分人选择的都是 SquashFS，这个文件系统的优点是系统分区默认只读，所有的配置都在 <code>/overlay</code> 分区下，这样每次重置时就只需要清除这个分区的内容就可以。但对我来说，我是一个比较喜欢折腾的人，难免会经常对系统分区魔改啥的，而这时 Ext4 文件系统就比较符合我的要求。但是我在网上一些论坛找其他大佬编译的包时，几乎找不到Ext4文件系统的镜像，所以觉得很奇怪。</p><p>后来，当我在一个大佬的群里问起这个的时候，有人告诉我，使用 Ext4 文件系统如果不正常关机的话会造成文件系统只读或损坏的现象。然后我详细去了解了一下，发现这个问题是 Linux 系统共有的问题。不过虽然这样我任然心存一丝侥幸，自己应该不会碰到不正常关机的情况。再后来，我为了验证这个情况，再正常使用时将软路由直接断电，连续进行了三次实验，均没有发现文件系统出问题。于是我就安心的继续用我的Ext4文件系统了。（截止写文章时已经正常运行了两天半）</p><p><strong>然后是软件包的选择编译问题</strong>，这个问题可能比较玄学，具体哪个包跟哪个包会冲突很可能要等到编译失败的时候才知道（一般都是编译两个多小时了才失败），而且网上论坛里也很少有讨论这个的。比如想包括 IPv6 功能时要选择与IPv6有关的包，这时候 odhcpd 和 odhcp-ipv6 这两个包就会冲突，而且这两个包的描述写的都是 IPv6 相关功能的，并且 odhcpd 跟另一个叫 odhcpc 的包名字很像，稍有不慎就会选错。除了这个以外其他的比如luci-samba和luci-amba4也会引起这样的冲突。</p><p>还有一个会引起冲突的就是 luci-base 和 luci-compat 当版本不对应时引起冲突。第一次的我编译的包没有编译 luci-compat，在使用时尝试安装就会装不上。而第二次在编译时就把两个包同时装上就没问题。</p><p>另外，如果你配置时选择的软件比较多，编译时可能会出现 <code>out of space usage </code>的问题，这是因为默认情况下 OpenWrt 的Root分区只有 160 MB 的空间，软件一多自然就装不下了。在编译配置时把 root patition size 调大就行了，我调的是 512MB。</p><p><strong>还有一个内核版本的问题</strong>，Lean’s OpenWrt 的最新源码所采用的Linux内核版本号是 5.4.156 (<a href="https://github.com/coolsnowwolf/lede/blob/master/include/kernel-version.mk#L12">现在又升级到了5.4.158</a>)。在 OpenWrt 的软件源仓库中，有一个叫 <a href="https://downloads.openwrt.org/releases/21.02.1/targets/x86/64/kmods/">kmods</a> (Kernel Modules) 的文件夹。顾名思义，就是Linux内核的附加模块。这个文件夹里又有以内核版本号和哈希值命名的文件夹，在安装这类的包时，会验证系统的内核版本号是否跟这里的一致，如果不一致是装不上的。（也可以强制安装，但大概率会出问题）</p><p>在官方最新的 Release 版本的软件库中，这个版本号是 <code>5.4.154</code>，即使是最新的 <a href="https://downloads.openwrt.org/snapshots/targets/x86/64/kmods/">Snapshot 版本</a>(即不稳定版本)，这个版本号最大也只有 <code>5.4.143</code>，所以使用更高的版本号必然导致内核模块不兼容。如果喜欢在使用时安装其他模块的话，必然会有很多模块装不了。</p><p>在 <a href="https://github.com/P3TERX/Actions-OpenWrt">Actions-OpenWrt</a> 中提供了两个自定义脚本供使用，于是我们可以在<a href="https://github.com/P3TERX/Actions-OpenWrt/blob/main/diy-part2.sh">diy-part2.sh</a>这个脚本里对内核版本进行修改。下面是我使用的命令，仅供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sed -i &#x27;s/LINUX_VERSION-5.4 = .156/LINUX_VERSION-5.4 = .154/&#x27; include/kernel-version.mk</span><br><span class="line">sed -i &#x27;s/LINUX_KERNEL_HASH-5.4.156 = 06fe73e4623fcf1b3c0d0e1983d8286a2ff5b8fffbcb2163f4c01696a1c377fe/LINUX_KERNEL_HASH-5.4.154 = 058994f4666b6b0474a4d5228583e394594e406783b7e93d487c2a66c35f3c06/&#x27; include/kernel-version.mk</span><br></pre></td></tr></table></figure><p>注意，这里我偷懒直接暴力匹配修改了，现在Lean’s OpenWrt源码使用的内核版本是5.4.158，如果需要修改请自行更换命令里的匹配字符串。</p><p>至于该如何选择软件包，<a href="https://www.youtube.com/channel/UCOhkliOps3IS48ly-MgPC2A">esirPG</a>大佬提供了一个说明参考列表，有需求的可以看一下：<a href="https://drive.google.com/file/d/1VHB_CoL5LHLYJ39svjWmzJinbg7_Z-Fu/view?usp=sharing">https://drive.google.com/file/d/1VHB_CoL5LHLYJ39svjWmzJinbg7_Z-Fu/view?usp=sharing</a></p><h3 id="刷写部分"><a href="#刷写部分" class="headerlink" title="刷写部分"></a>刷写部分</h3><p>刷写部分的坑其实不比编译部分要少。</p><p>设想一下，当我们有一台没有装系统的电脑，我们会怎么给他装系统？</p><p>大部分人第一时间想到的是使用WinPE，或者使用启动介质（U盘，DVD等）。没错，软路由也可以这么装，大部分人也都是这么装的。但是，这个方法有着几个不可忽视的问题。</p><h4 id="显示器问题"><a href="#显示器问题" class="headerlink" title="显示器问题"></a>显示器问题</h4><p>现在大部分的软路由都有 VGA 显示器输出接口，我的甚至有 HDMI 输出接口。然而，当我使用HDMI线连接软路由到显示器后，问题出现了：BIOS 界面无输出，进不去 WinPE。只有正常启动系统后才能看到OpenWrt的命令行界面，系统启动前基本都是屏幕闪一下就没输出了。</p><p>我也很快找到了问题所在：BIOS 等界面无法支持 HDMI 信号输出。无奈之下，当时我迅速出去买了一条 VGA 的线，总算能看到熟悉的 BIOS 界面了。</p><h4 id="WinPE问题"><a href="#WinPE问题" class="headerlink" title="WinPE问题"></a>WinPE问题</h4><p>费了九牛二虎之力总算进了 WinPE，然后新的问题来了：写盘软件打不开！大部分都是缺少 xxxx.dll 啥的，毕竟 WinPE 只是精(残)简(废)版的 Windows，缺什么乱七八糟的依赖都正常。</p><p>好不容易换了个PE，写盘软件也能打开了，接着发现分区软件又打不开了！当时不知道什么原因，一打开 DiskGenius 整个PE就会直接黑屏，怎么都救不活。而且毕竟我的软路由才2G内存，这么低的配置WinPE直接卡住我都不觉得奇怪…</p><p>另外在写盘时还会碰到一个问题，就是快要结束的时候突然报错。比如使用 physdiskwrite 写盘的时候，眼看快要成功了，突然来一个 <code>write error after xxx bytes...</code>，特别让人抓狂。但是一番搜寻之后，看到论坛里有人说出现这样的情况仍然能成功进系统。我一试，果不其然，一切正常，系统确实是写进去了。至于为什么报错，那我就不得而知了。</p><h4 id="外置写盘法"><a href="#外置写盘法" class="headerlink" title="外置写盘法"></a>外置写盘法</h4><p>既然用PE写盘这么多问题，那有没有其他方法呢？有！</p><p>你只需要在某宝上花二十多买一个mSATA转USB的转接卡，就可以直接把硬盘取下来，插在自己的电脑上写盘了！就像制作启动U盘一样简单！</p><p>整个过程二十分钟不到，镜像就写完了。不过还有个问题，如果你就这样启动到系统后，你会在磁盘管理里发现硬盘后面还有一大块都没有分配，而OpenWrt只有小小的512M，这样的话再加装其他软件就不够用了。</p><p>解决方法也很简单，在写完镜像之后，立即调整root分区的空间大小，使其撑满整个硬盘空间。但在这里我不推荐用 DiskGenius，因为 DiskGenius 在执行分区扩容时会检查文件系统，如果发现有一丁点的错误就无法扩容。而且DiskGenius是不提供分区修复功能的，何况还是 Ext4 分区。</p><p>如果你电脑上有 Linux 环境，那就好办了。正好前几天<a href="https://blog.revincx.icu/posts/manjaro-exprience/">刚体验了 Manjaro Linux</a>，这不就派上用场了？ Linux 有个叫 <a href="https://gparted.org/">GParted</a> 的软件(默认没有，需要自己装)，这个软件可以很方便的调整 Ext4 甚至 Fat 以及 NTFS 文件系统的大小。只需要在 GParted 里调整 Root 分区，使其撑满硬盘空间就行了。</p><h3 id="组网AP部分"><a href="#组网AP部分" class="headerlink" title="组网AP部分"></a>组网AP部分</h3><p>本来是没有这个部分的，但是这确实是个小问题，而且跟 OpenWrt 有关系，所以还是记录一下吧<del>（凑字数</del></p><p>我的软路由只有两个网口，不过除了软路由之外，我还有一台斐讯K2作为AP使用。所以就要把这个路由器改成交换机+无线AP。</p><p>问题是，我的K2之前也是OpenWrt系统，对于OpenWrt怎么改交换机，在网上找到了不少帖子，似乎每个人方法都有不同点，综合了一下，下面我说一下我的方法吧。</p><ol><li>首先是删除WAN下的所有接口(WAN和WAN6)。</li><li>然后把LAN接口的DHCP关掉（勾选接口设置下面的”忽略此接口”选项，一开始半天没找到）。</li><li>接着在物理设置里把所有接口都勾选上。</li><li>然后修改LAN接口的静态IP地址（也可以干脆把协议改成DHCP，但不推荐这么做）。这个地址有点讲究，比如主路由的网关是 192.168.1.1 ，主路由DHCP地址池的起始地址是192.168.1.100，那么这个静态IP就要设置为这中间的值比较合适。比如192.168.1.2。这样的话就不至于连接到主路由网关的情况下进不去交换机路由器的管理界面。</li><li>修改无线网卡的工作模式为 “接入点AP (WDS)” （好像不改这个也没啥关系，但我还是改了）</li><li>(可选)在交换机设置里有两行VLAN的设置，这里把原本对应wan接口的那一行（也就是WAN选择了untagged的那一行）的WAN口关联改为”关”，接着把原本对应lan接口的那一行的WAN口关联改为untagged，保存。这样一来就可以实现所有接口盲插，全都可以作为交换机接口使用。（如果不设置的话只有LAN网口是能作为交换机使用的。）</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>又写完了一篇折腾文，虽然折腾了这么久但是没有感觉到一点累，这可能就是造轮子的魅力吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 基础使用</title>
      <link href="/2022/09/11/Git%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/09/11/Git%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git-基础使用"><a href="#Git-基础使用" class="headerlink" title="Git 基础使用"></a>Git 基础使用</h1><blockquote><p>一些常用的命令如下，不算全面但是日常对我来说是够用了。</p></blockquote><ul><li><code>git clone url</code> ：克隆项目，如需自定义本地文件夹的名称，在 url 之后加个名称即可。</li><li><code>git add</code> ：这是个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的发生更改的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。</li><li><code>git rm</code> ：要从 Git 中移除某个文件，就必须要从暂存区域移除，然后提交。可以用 <code>git rm</code> 完成，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</li><li><code>git diff</code> ：查看尚未暂存的文件更新了哪些部分。在后面加一个 <code>--staged</code> 参数，将比对已暂存文件与最后一次提交的文件差异。</li><li><code>git status</code> ：查看哪些文件处于什么状态、当前所在分支。</li><li><code>git commit -m &quot;msg&quot;</code> ：提交，<code>-m</code> 参数可将提交信息在后面附上。提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。</li><li><code>git log</code> ：查看提交历史。</li><li><code>git reset</code> ：撤销操作。</li><li><code>git remote</code> ：查看远程仓库，可使用 <code>-v</code> 查看更详细信息。</li><li><code>git fetch &lt;remote&gt;</code> ：从远程仓库拉取数据。</li></ul><h2 id="一、通过SSH方式使用GitLab"><a href="#一、通过SSH方式使用GitLab" class="headerlink" title="一、通过SSH方式使用GitLab"></a>一、通过SSH方式使用GitLab</h2><h3 id="创建SSH私钥和公钥"><a href="#创建SSH私钥和公钥" class="headerlink" title="创建SSH私钥和公钥"></a>创建SSH私钥和公钥</h3><p><code>ssh-keygen -t</code> 生成密钥，-t 参数后面跟着加密类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519</span><br></pre></td></tr></table></figure><p>生成之后，<code>.pub</code> 后缀的文件即是公钥文件，无后缀名的则是私钥文件</p><h3 id="验证身份"><a href="#验证身份" class="headerlink" title="验证身份"></a>验证身份</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-T` 参数为 `不显示终端，只显示连接成功信息</span><br><span class="line">ssh -T git@gitlab.com</span><br></pre></td></tr></table></figure><p>之后就可以使用ssh地址克隆项目了</p><h2 id="二、更改仓库地址"><a href="#二、更改仓库地址" class="headerlink" title="二、更改仓库地址"></a>二、更改仓库地址</h2><p>基本知识：</p><ul><li><code>git remote</code> 查看所有远程仓库，加上 <code>-v</code> 则显示详细信息（包括所有仓库的地址）</li><li><code>git remote get-url origin</code> 查看 origin 的远程仓库地址</li><li><code>git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://xxxxx.git</span><br></pre></td></tr></table></figure><h2 id="三、撤销操作"><a href="#三、撤销操作" class="headerlink" title="三、撤销操作"></a>三、撤销操作</h2><h3 id="修补提交"><a href="#修补提交" class="headerlink" title="修补提交"></a>修补提交</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。可在修改或添加后，add到暂存区，然后使用 <code>git commit --amend</code> 来修正提交。就像下面一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>如果单使用 <code>--amend</code> 参数，会打开 vim 然后在里面修改上次的 commit 消息。如果还使用了 <code>-m</code> 那就在后面直接写上提交消息，然后提交了。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>暂存了多余的文件，如何取消呢，使用 <code>git reset HEAD &lt;file&gt;</code> 来撤销对该文件的暂存。在 VSCode 中可以通过点击 Unstage Changes 实现，而 Discard Changes 实际上是下面要说的 <strong>恢复到上次提交的样子</strong>。</p><h3 id="恢复到上次提交的样子"><a href="#恢复到上次提交的样子" class="headerlink" title="恢复到上次提交的样子"></a>恢复到上次提交的样子</h3><p>对于已追踪但未暂存的文件，比如你改了一堆代码然后发现不满意，想要回到之前的样子(最后一次提交)，使用 <code>git checkout -- &lt;file&gt;</code> 即可。</p><h3 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h3><p>代码提交了但是又后悔了，想要重新编辑一下提交信息，建议使用修补提交的方法，即使用 <code>--amend</code> 参数修补提交一下。</p><p>当然，也可以使用 <code>git reset --soft HEAD^</code> 直接撤销 commit。其中 <code>HEAD</code> 是指针，<code>HEAD^</code> 和 <code>HEAD~1</code> 指向上一次提交，<code>HEAD^^</code> 和 <code>HEAD~2</code> 指向上上次提交。</p><p>reset 的几个参数：</p><ol><li>使用参数–mixed(默认参数)，将撤销提交，撤销暂存，保留工作区改动的代码</li><li>使用参数–soft，将撤销提交，不撤销暂存，保留工作区改动的代码</li><li>使用参数–hard，将撤销提交，撤销暂存，删除工作区改动的代码</li></ol><h2 id="四、远程仓库使用"><a href="#四、远程仓库使用" class="headerlink" title="四、远程仓库使用"></a>四、远程仓库使用</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>如果一份代码，分布到多个git仓库，就可以添加多个仓库。或多人协作时，方便拉取和推送别人的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add cxlab https://gitlab.com/cx_x/meoo-space.git</span><br></pre></td></tr></table></figure><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>将本地的一份代码推送到不同的仓库中，例如将本博客的 main 分支推送到 cxlab 服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push cxlab main</span><br></pre></td></tr></table></figure><h3 id="拉取更新"><a href="#拉取更新" class="headerlink" title="拉取更新"></a>拉取更新</h3><p><code>git fetch</code> + <code>git merge</code> &#x3D; <code>git pull</code>；</p><p>fetch 命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的<strong>引用</strong>，可以随时合并或查看。它并不会自动合并或修改你当前的工作，必须手动合并代码。</p><h3 id="远程仓库重命名和删除"><a href="#远程仓库重命名和删除" class="headerlink" title="远程仓库重命名和删除"></a>远程仓库重命名和删除</h3><p>将 cxlab 重命名为 gtlab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename cxlab gtlab</span><br></pre></td></tr></table></figure><p>将 gtlab 远程仓库从本地删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove gtlab</span><br></pre></td></tr></table></figure><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p><h2 id="五、打标签"><a href="#五、打标签" class="headerlink" title="五、打标签"></a>五、打标签</h2><blockquote><p>可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。</p></blockquote><p>使用 <code>git tag</code> 列出所有标签，按照通配符列出标签需要 -l 或 –list 选项，例如 <code>git tag -l &quot;v1.8.5*&quot;</code>。</p><h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><p>在 GitHub 中 release 一个版本的代码或者安装包的时候，就需要创建或者选择一个 tag。</p><blockquote><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p><p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.4 <span class="comment">#轻量标签</span></span><br><span class="line">git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span> <span class="comment">#附注标签</span></span><br></pre></td></tr></table></figure><p>如果想要给以前的某个提交补打标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment">#输出所有提交</span></span><br><span class="line">git tag -a v1.2 9fceb02 <span class="comment">#对特定的提交补打一个tag</span></span><br></pre></td></tr></table></figure><h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><p><code>git push</code> 并不会把标签推送到远程仓库服务器上，在创建完标签后必须显式地推送到服务器。可以运行 <code>git push origin &lt;tagname&gt;</code>。如果想要一次性推送很多标签，也可以使用 <code>git push --tags</code> 命令，将把所有不在远程仓库服务器上的标签全部推送。</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>同时删除远程分仓库中的该标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h2 id="六、分支操作"><a href="#六、分支操作" class="headerlink" title="六、分支操作"></a>六、分支操作</h2><p><code>git branch</code> 命令不只是可以创建与删除分支。如果不加任何参数运行它，会得到当前所有分支的一个列表。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>创建一个 <code>mybranch</code> 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch mybranch</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。</p><p>切换到 <code>mybranch</code> 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout mybranch</span><br></pre></td></tr></table></figure><p>创建并切换到 <code>newbranch</code> 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newbranch</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>回到 master 分支，将 hotfix 分支合并进来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hotfix <span class="comment">#默认fast-forward</span></span><br></pre></td></tr></table></figure><p>当合并遇到冲突时，可用 <code>git status</code> 查看冲突，手动解决冲突后，使用 <code>git add</code> 命令来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。如果对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。下图为 merge 的三种方式区别。</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101639619.webp" alt="img"></p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当完成一个 hotfix 的合并之后，应该把该分支删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d hotfix</span><br></pre></td></tr></table></figure><h2 id="七、远程分支"><a href="#七、远程分支" class="headerlink" title="七、远程分支"></a>七、远程分支</h2><p><code>git fetch cxlab</code> 可以将远程仓库 cxlab 有而本地没有的数据更新到本地。加上 <code>--all</code> 参数可以抓取所有远程仓库的数据。</p><p>要特别注意的一点是，本地已有 <code>cxlab/master</code> 分支，当抓取到新的远程跟踪分支 <code>cxlab/serverfix</code> 时，本地不会自动生成一份可编辑的副本。换一句话说，不会有一个新的 serverfix 分支——只有一个不可以修改的 <code>cxlab/serverfix</code> 指针。</p><p>可以运行 <code>git merge cxlab/serverfix</code> 将这些工作合并到<strong>当前所在的分支</strong>。如果想要在自己的 sf 分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b sf cxlab/serverfix</span><br></pre></td></tr></table></figure><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支，会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch sf <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure><p><code>git branch -vv</code> 会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后…</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>将 hotfix 分支推送到 cxlab 远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push cxlab hotfix <span class="comment">#如需将推送到服务器上的分支名改为 myhotfix，可这样 hotfix:myhotfix</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>若已经完成了热修复，并且已经合并到主分支，已经用不到 serverfix 分支，则可以从远程仓库删除它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete serverfix</span><br></pre></td></tr></table></figure><p>说的再多都不如看一看文档，实在是细：<a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于『代理』的不完全使用指北</title>
      <link href="/2022/08/25/%E4%BD%A0%E7%9A%84%E6%B5%81%E9%87%8F%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6/"/>
      <url>/2022/08/25/%E4%BD%A0%E7%9A%84%E6%B5%81%E9%87%8F%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是本人对于使用代理过程中的一些经验总结，并不是教程或者技术性文章，所以内容比较不全面很正常（<br>本文不会提供任何软件的下载链接，如有需求请自行查找相关下载源。</p><p>由于日常的开发以及娱乐需求，我们不得不在某些场景下使用代理连接网络。在各种平台都有各种代理软件供我们选择，有时候为了不同的需求我们会选择不同的软件。总体来说，原理都是把自己设备上的流量通过某种方式”转发”到远程设备上，但其中的能使用的具体方法却五花八门。</p><p>在路径上，我们可以把流量经过的地点分为三层：</p><ul><li>第一层：由你的流量发起段到代理软件的接入端，比如你的浏览器到你使用的Clash。</li><li>第二层：由代理软件到远端服务器，比如由你使用的Clash到某香港的服务器。</li><li>第三层：由远端服务器到目标服务器，比如由某香港的服务器到谷歌的服务器。</li></ul><p>本文主要对第一层和第二层做适当的讨论，<del>因为第三层也没啥好说的</del></p><h3 id="你的流量如何接入代理软件"><a href="#你的流量如何接入代理软件" class="headerlink" title="你的流量如何接入代理软件"></a>你的流量如何接入代理软件</h3><p>不管你使用什么代理软件，Clash也好，v2rayNG也好，这些软件都会在本地监听一个端口来作为代理的接入端。比如Clash大多监听7890端口，v2rayNG默认监听10809端口等等。你可以通过某些设置，使你当前某个软件的流量全部指向这个端口上。</p><p>通常情况下，这些监听的端口使用Socks5代理或HTTP代理。因为这两种代理协议都比较“纯粹”，占用的资源也少。区别在于，HTTP代理只能够代理HTTP协议的流量，比如你在浏览器中访问谷歌搜索，使用的就是HTTP(S)协议。而SOCKS5则支持代理几乎所有的TCP和UDP流量。所以在大部分场景下，代理软件监听的SOCKS5端口使用更多一些。</p><h4 id="什么是系统代理"><a href="#什么是系统代理" class="headerlink" title="什么是系统代理"></a>什么是系统代理</h4><p>当你使用电脑上的Clash或者v2ray类软件时，通常有一个选项叫做「系统代理」。当你打开这个选项时，代理软件就会修改系统设置中的代理选项。但是，系统设置中的代理往往只可设置为HTTP代理（如Win10设置中的代理），而且这个HTTP代理只对当前系统上web浏览器有效。</p><p>这也就是为什么明明设置了系统代理，访问GitHub也很快，但在命令行里克隆一个GitHub的仓库却很慢的原因。在命令行下，执行git命令也就是直接执行git的二进制文件，跟你设置的系统代理是没有关系的。</p><p>因为很多人都遇到过这个问题就顺便提一下了。也不是没有解决办法，一个方法是git提供了设置代理的配置选项（git config –global http.proxy xxxx 支持socks5），但是这么一配置就会导致以后所有的克隆都会走这个代理，而问题我们无法保证设置的代理不会改变或者随处可用。另一个方法就是使用一些公共的GitHub镜像了，这种方法对于不懂代理的人比较省事。</p><h4 id="其他软件中的代理设置"><a href="#其他软件中的代理设置" class="headerlink" title="其他软件中的代理设置"></a>其他软件中的代理设置</h4><p>除了使用系统代理选项使浏览器用上代理之外，其他软件大多也提供了代理功能。比如当你登陆QQ的时候，点击右上角的小齿轮，便可以配置http或socks代理选项。那问题来了，我使用的软件确实没有能配置代理的地方，怎么办呢？看下面~</p><h4 id="什么是TAP-x2F-TUN代理"><a href="#什么是TAP-x2F-TUN代理" class="headerlink" title="什么是TAP&#x2F;TUN代理"></a>什么是TAP&#x2F;TUN代理</h4><p>一些老用户可能了解过一款软件：SSTAP。这是很久前一个为了让某些游戏走代理而设计的软件，它的原理也就是TAP模式。所谓TAP模式其实就是在设备上利用技术手段安装一个虚拟的”网卡”，从而使得系统所有的流量都能经过代理软件。</p><p>而TUN模式则和TAP模式异曲同工。与TAP相比，TUN工作在更高的网络层，不需要虚拟的TAP设备，也能实现跟TAP类似的效果。不仅如此，TUN的性能也比TAP要好。目前，Clash系的所有代理软件基本都有TUN功能，比如Windows上的 Clash For Windows 以及 Clash .NET (已停更)等，除此之外还有 tun2socks 等专门具有TUN功能的软件。</p><p>另外，除了使用TAP&#x2F;TUN模式，还有一个比较特殊的东西：Proxifier。它是一款在Windows上实现接管所有系统流量的软件，你可以使用这个软件来使所有系统流量路由到某个Socks5代理上。至于原理，这款软件则是自己实现了一套基于驱动的流量劫持，由于是闭源商业软件，所以具体原理也不是很清楚。但是实测效果跟TAP几乎一样，如果不介意闭源的话也可以选择这款软件。</p><h4 id="什么是透明代理"><a href="#什么是透明代理" class="headerlink" title="什么是透明代理"></a>什么是透明代理</h4><p>所谓透明代理，就是用户可以感知不到自己处于代理环境下。最常见的透明代理也就是搭建在软理由等设备上的代理。由于软路由可以作为一个局域网的网关，局域网内所有接入设备的流量都会指向网关，所以网关就具有了出来这些流量去处的能力。</p><h3 id="代理软件如何处理你的流量"><a href="#代理软件如何处理你的流量" class="headerlink" title="代理软件如何处理你的流量"></a>代理软件如何处理你的流量</h3><p>根据代理软件所使用的路由模式，我们可以暂时先把代理软件分为两种：使用了Clash内核的和没有使用Clash内核的。这两类软件各有优缺，下面会详细说说。</p><p>第一类软件大部分已v2ray(v2fly或xray)为核心，代表性的有Windows平台上的v2rayN,安卓平台上的v2rayNG，Linux平台上的v2rayA等（由于我没有ios设备也没有Mac所以就不提了）这些软件都有一个共同点：独立的路由模式。比如 Win10平台上的 v2rayN 的路由设置需要自己手动配，安卓上的 v2rayNG 干脆不提供自定义，只有绕过大陆和局域网的选项。不过安卓端的 SagerNet 提供的路由设置就比较丰富，但如果手动配置的话也及其麻烦。</p><p>第二类软件则是基于Clash核心的代理软件，Clash 最大的一个特点就是配置文件了。与v2ray系的软件相比，Clash 的配置文件不仅有节点信息，还有完整的路由规则及策略组。换句话说，使用v2ray系的软件每次只能选择一个节点作为代理，而使用Clash则实现了节点分流，针对不同的网站走不同的节点，就像是再同时使用多个节点一样。</p><p>不过 Clash 的缺点也很明显，由于完全使用自己的内核，所以也就意味着暂时只能支持一部分代理协议(ss,ssr,vmess,trojan)，如果是比较冷门的代理协议(brook,tunnel等)就没法用clash了。而相比较，安卓端的 SagerNet 可以通过插件支持任何类型的代理协议，桌面平台上的 Qv2ray (已停更)也是可以安装插件来支持其他协议。</p><h4 id="如何对流量进行分流"><a href="#如何对流量进行分流" class="headerlink" title="如何对流量进行分流"></a>如何对流量进行分流</h4><p>我们只有在访问特定网站时才需要经过代理服务器，大部分情况都是直连就可以的，所以便出现了路由模式。</p><p>对于v2ray系的软件来说，一般都会有这几种路由模式：GFWList，大陆白名单，全局。</p><ol><li><p>GFWList，顾名思义，就是一个被墙封锁的网站名单。这个名单由民间开发者共同维护，不定时更新。当你的流量经过代理软件时，代理软件会先判断你要访问的网站在不在这个名单里，如果在的话则交给代理服务器来处理了。</p><p>不过问题是，并不是所有的网站都在GFWList里面，有些网站即使没被屏蔽，但由于ISP的一些原因访问就是特别慢，这种情况下就需要也走代理了。</p></li><li><p>大陆白名单，这种路由模式比较常用。首先一般我们会有 geoip 和 geosite 这两样东西，第一个 geoip 记录的是大陆的所有IP段，第二个则记录了大陆大部分常用的网站域名。它们与GFWList一样，也是由人们自行维护。当代理软件检测到你的流量是去往大陆内地的时候，则不走代理。</p><p>不过这种方式也不是没有问题，代理服务器是需要成本的，我们访问的大部分不位于大陆的网站速度都还可以，如果所有境外网站都走代理的话就造成了浪费。有时候如果目标网站离我们本来就很近(比如ISP在香港)，这时候再走代理可能速度就会被原来更慢了。</p></li><li><p>全局模式，就是所有流量都走代理咯，没啥具体要说明的。</p></li></ol><p>而对于 Clash 内核的软件，分流就特别的灵活了。Clash 的规则支持不仅域名匹配，IP匹配，甚至支持IP段，域名关键字匹配。Clash 对所有节点分成不同的组，每条匹配规则都对应着一个策略组。如果对现有的配置文件不满意，完全可以DIY属于自己的分流规则。</p><p>举个例子，我们可以把带原生IP的节点分到一个组，然后写一条规则，让流媒体网站(如Netflix等)的流量全部走这个组里的节点。我们还可以把所有的台湾节点分到一个组，让所有动画疯(一个台湾的看番网站)的流量全部走这个组。只要你有相应的需求，就可以DIY自己的规则！</p><p>如果比较懒的话，大部分机场都提供现成的Clash规则，GitHub上也有不少写好的模板可以参考，基本是不需要动太多手就可以实现想要的效果。</p><h4 id="进阶-使用Fake-IP"><a href="#进阶-使用Fake-IP" class="headerlink" title="进阶: 使用Fake-IP"></a>进阶: 使用Fake-IP</h4><p>防火墙不仅对某些特定的IP进行了阻断，还对相当一部分域名采取了DNS污染。简单来说，就是通过域名解析到的IP是错误的，所以我们还需要对DNS请求进行代理。但每次请求都先判断，再请求远程服务器DNS，再返回解析结果，客户端再请求，再代理，这样一来二去就极大浪费了时间。于是，Fake-IP 技术出现了。</p><p>所谓 Fake-IP，也就是虚假的IP。客户端进行的每次DNS请求，都会直接被代理软件劫持，然后代理软件不会先判断，而是立即返回一个假的IP。于此同时，代理软件再去判断并请求真实的IP，保存到自己的表中。而客户端向这个虚假的IP进行连接时，都会由代理软件直接从表中取出结果，然后对流量进行进一步处理。这样以来就节省了大约一半的时间。如果对更多技术细节感兴趣的话，可以去看参考文章2。</p><p>目前只有Clash内核支持Fake-IP模式，如果想使用的话可以在相关配置里把<code>fake-ip</code>设置为<code>true</code>，等待本地DNS刷新就可以正常使用了。</p><p>但是这种方式也不是没有缺点，不论是任何系统，都有着DNS缓存机制。假如某一天由于某些原因突然需要把代理软件关掉，这样一来客户端再去请求这个虚假的IP，就得不到任何响应了。这时需要手动刷新系统DNS缓存才能解决。</p><p>Fake-IP 比较常见的场景是在软路由上，毕竟软路由大部分时间都是24小时运行的，代理软件不会关，所以一般不会出现问题。目前软路由上支持Fake-IP的代理软件也只有OpenClash了。</p><h3 id="附加章节-代理线路与相关方案如何选择"><a href="#附加章节-代理线路与相关方案如何选择" class="headerlink" title="附加章节: 代理线路与相关方案如何选择"></a>附加章节: 代理线路与相关方案如何选择</h3><p>这一部分会粗略的说一下代理服务器相关的选择。不过大部分人的手里应该都是别人建好的节点，能自己搭建的应该很少。</p><p>目前比较流行的代理方案大概有下面几种: vmess+ws直连，vmess+ws+国内中转&#x2F;隧道，ss+隧道。其他的像IEPL啥的大部分都是ss了，这里就不说了。</p><p>如果仅仅是自用的话，选择vmess+ws直连就能满足大部分的需求了，如果想尝鲜，也可以考虑其他冷门协议或者混搭。之前笔者就使用了大半年的brook直连没有出现过问题。</p><h4 id="不同协议间的区别"><a href="#不同协议间的区别" class="headerlink" title="不同协议间的区别"></a>不同协议间的区别</h4><p>仅仅对于稳定而言，不同协议间的最大区别就是流量特征了。在很久之前ss直连都没有问题，但是由于ss自身的一些缺陷导致流量特征暴露，从而后来可以被精准屏蔽。</p><p>对于现在比较流行的vmess+ws或者再套一层tls，则是采取了流量伪装的办法，将代理流量伪装成websocket流量(也就是浏览网站的流量)以绕过检测。但是流量还可以分析行为特征，比如记录一段时间内的数据包量并建立模型等。这种检测手段对大型的机场节点往往比较有效。但是毕竟记录这个需要消耗很多资源，所以一般情况下防火墙很少用。</p><p>对于其他的一些冷门协议，大部分就是无特征协议，也就是说检测不出来你在干嘛。但是仍然可以通过一定的行为特征来实施封锁。由于没有更多详细的资料就不赘述了。</p><h4 id="什么是隧道"><a href="#什么是隧道" class="headerlink" title="什么是隧道"></a>什么是隧道</h4><p>隧道是当前很流行的一种代理方案，如果说中转是直接把流量转发到境外代理服务器，隧道则是把流量又装在了一个套子里转发给代理服务器。那么这样做有什么优点呢？与直接的中转相比，这样做往往能取得更低的延迟与更优秀的链接体验。由于流量已经被套了一层，所以接入层就可以使用有特征的ss协议。为什么非要用ss呢？因为ss与其他的现代协议相比，运行时消耗的资源要更小，性能也更好，所以也就有着更好的连接体验了。</p><p>目前实现隧道的方法主要有 Gost 和 WireGuard 等，经过这些隧道包裹的流量都是无特征的，从而就是不容易被防火墙检测。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不知不觉写了这么多，但其实内容还是很乱，希望能对看到的人有点帮助吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何绕过校园网验证，在宿舍免费上办公区的网，享受不拥挤的网络</title>
      <link href="/2022/08/25/%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%9C%A8%E5%AE%BF%E8%88%8D%E5%85%8D%E8%B4%B9%E4%B8%8A%E5%8A%9E%E5%85%AC%E5%8C%BA%E7%9A%84%E7%BD%91%EF%BC%8C%E4%BA%AB%E5%8F%97%E4%B8%8D%E6%8B%A5%E6%8C%A4%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/08/25/%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%9C%A8%E5%AE%BF%E8%88%8D%E5%85%8D%E8%B4%B9%E4%B8%8A%E5%8A%9E%E5%85%AC%E5%8C%BA%E7%9A%84%E7%BD%91%EF%BC%8C%E4%BA%AB%E5%8F%97%E4%B8%8D%E6%8B%A5%E6%8C%A4%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何绕过校园网验证，在宿舍免费上办公区的网，享受不拥挤的网络"><a href="#如何绕过校园网验证，在宿舍免费上办公区的网，享受不拥挤的网络" class="headerlink" title="如何绕过校园网验证，在宿舍免费上办公区的网，享受不拥挤的网络"></a>如何绕过校园网验证，在宿舍免费上办公区的网，享受不拥挤的网络</h1><p><strong>如何绕过校园网验证，在宿舍免费用办公区的网</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>上了大学后发现上网成了难题，流量太贵买不起，流量卡又限速而且电脑上网也不方便，想办校园单宽，可是那网络体验根本配不上付的钱，除非去校园营业厅办移动或者联通的卡开通校园网套餐，可，我，不愿向垄断的运营商和学校低头！</p></blockquote><p>既然办公区网速比宿舍区快，能上网，那就利用办公区电脑，在宿舍就可以连了！</p><p><strong>需求</strong>：一台办公区的电脑</p><h2 id="利用Softether改造办公区电脑"><a href="#利用Softether改造办公区电脑" class="headerlink" title="利用Softether改造办公区电脑"></a>利用Softether改造办公区电脑</h2><p>在办公区的电脑上下载Softether<a href="https://www.softether-download.com/cn.aspx?product=softether">点击下载</a>，选择适合你的版本，在这里我选择如下的版本：<img src="https://img-blog.csdnimg.cn/20191231214354250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20191108235602493.png" alt="下载这个"></p><p>下载完成后安装，安装时选择<strong>SoftEther *</strong> Server**，这里我们是把电脑当作服务器的，所以要安装服务器端的软件部分。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装完成后打开：</p><p><img src="https://img-blog.csdnimg.cn/2019110900035036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="打开界面"></p><p>双击<strong>本地主机</strong>这一行：</p><p><img src="https://img-blog.csdnimg.cn/20191109000637942.png" alt="双击"></p><p>会让你设置一个管理密码，设置完之后就可以开始配置了。</p><p><strong>端口号</strong>要选择<strong>5555</strong></p><p>下图为开始配置界面：</p><p><img src="https://img-blog.csdnimg.cn/20191109000748392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="开始配置"></p><p>点击<strong>管理虚拟HUB</strong>，进入此界面：</p><p><img src="https://img-blog.csdnimg.cn/2019110900100024.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 启用<strong>虚拟NAT和虚拟DHCP服务器</strong>：<img src="https://img-blog.csdnimg.cn/20191109001127308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>关闭，然后可以点击<strong>管理用户</strong>，<strong>新建</strong>，添加账号密码等</p><p><img src="https://img-blog.csdnimg.cn/20191109001400608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20191109001454592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>回到最开始的界面，点击<strong>IPsec&#x2F;L2TP设置</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20191109001642235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>启用L2TP功能</strong>，并设置<strong>预共享密钥</strong>，随便设置一个就行。</p><p>完成！</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在手机或者其他想上网的电脑上新建VPN连接，</p><p><img src="https://img-blog.csdnimg.cn/20191109142622641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MTgyNjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后连上就可以了，记得要<strong>先连上校园网WiFi或者接上网线</strong>，不用登录校园网账号了，直接“连接到工作区域”。 只要在办公区那台电脑上连上网并且可以正常上网，其他设备连上它就可以正常使用，就可以在<strong>宿舍连上办公区</strong>的网了。</p><p>配置连接时，<strong>服务器地址</strong>填刚刚配置Softether的那台电脑的IP，可以在那台电脑上用cmd命令ipconfig得到。</p><p>终于，可以愉快地上网了。开森~</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + 腾讯云搭建图床</title>
      <link href="/2022/07/12/PicGo%20+%20%E8%85%BE%E8%AE%AF%E4%BA%91%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/07/12/PicGo%20+%20%E8%85%BE%E8%AE%AF%E4%BA%91%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PicGo-腾讯云搭建图床"><a href="#PicGo-腾讯云搭建图床" class="headerlink" title="PicGo + 腾讯云搭建图床"></a>PicGo + 腾讯云搭建图床</h1><p>著作权归JohnsonXin所有。 链接：<a href="https://reday.asia/blogs/useBlog/02PicGo+%E8%85%BE%E8%AE%AF%E4%BA%91%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A.html">https://reday.asia/blogs/useBlog/02PicGo+腾讯云搭建图床.html</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管在搭建博客或者说在写博客的时候，我们都希望有图片展示在我们的博客当中，这样不仅清晰明了，更能让读者明白我们表达的意思。 但是如果我们在每次需要图片资源的时候去网上寻找，并将找到的图片的链接贴在我们的博客当中就会产生一下几个问题：</p><ul><li>作者设置了<a href="https://www.jianshu.com/p/0a1338db6cab">防盗链 </a></li><li>作者换了图片资源链接</li><li>将图片放在我们的项目&#x2F;博客中就会导致包体积过大，加载速度过慢</li></ul><p>以上的问题都能导致贴在我们的图片失效，所以就有了<strong>图床</strong>解决以上的痛点</p><h2 id="图床"><a href="#图床" class="headerlink" title="# 图床"></a><a href="#%E5%9B%BE%E5%BA%8A">#</a> 图床</h2><p>有伙伴就问了：图床是什么？是用来做什么的？</p><p>简单来说，图床就是专门用来存放图片，同时允许我们把图片对外连接的网上空间，不少图床都是免费的。</p><p>以上就是来自百度百科关于图床的的解释。</p><p>总而言之，图床就是存图片的，类似于网盘，不过可以生成专门的链接用于访问</p><p>图床的制作有多种方法，不过我们既然都是学生，在没有能力支撑起费用之前还是乖乖选择白嫖吧，毕竟谁不喜欢白嫖~</p><p>下面列举几个白嫖方案：</p><ul><li>GitHub + jsdelivr 加速</li><li><a href="https://www.qiniu.com/">七牛云  (opens new window)</a></li><li><a href="https://cloud.tencent.com/product/cdn">腾讯云  (opens new window)</a></li></ul><p>以上就是我了解并使用过的几个白嫖方案，我依次来说明一下各个白嫖方案吧</p><ul><li><p>Github：仓库容量最大不能超过 1G 且单个文件不能超过 100M，相信这个对于大多数伙伴来说已经够用了</p><ul><li>但是由于GitHub服务器是在外网，很多时候需要挂梯子才能访问所以我们的图片很多使用不一定能够访问成功。</li><li>这就衍生出了使用<code>jsdelivr</code>加速访问，但是近期被ban过，所以加速效果不尽人意…</li></ul></li><li><p>七牛云：很多博主都很推荐，原因主要是它家注册就有<strong>对象存储</strong>10GB&#x2F;月永久使用，<strong>CDN</strong>10GB流量&#x2F;月，在使用阿里云搭建之前，我一直都是用的它家</p><ul><li><p>如果使用到<code>https</code>请求服务的话，它家并没有免费额度，只有<code>http</code>有免费额度</p></li><li><p>有伙伴有会问到：既然有免费额度的话就为什么不用<code>http</code>，其实大家也是可以用这个的，我放弃使用这个的原因主要是因为<code>http</code>服务不安全(就是网站左边显示的警告)</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101706896.png" alt="img"></p></li></ul></li><li><p>腾讯云：新人可以免费使用100GB不过只有6个月的有效期，但属实够用，后面续费的话且续费也只要20！并且&#96;&#96;https&#96;每个月也有免费请求次数~</p><ul><li>它家的对象存储使用也一开始送50GB存储容量&#x2F;6个月有效期</li></ul></li></ul><p>综上，我果断选择腾讯云—主要是白嫖~哈哈哈</p><h2 id="准备"><a href="#准备" class="headerlink" title="# 准备"></a><a href="#%E5%87%86%E5%A4%87">#</a> 准备</h2><p>做一个自己的图床需要用到：</p><ul><li>picGo—图片上传器</li><li>域名—用于访问图片</li><li>cdn—与对象存储相关联</li><li>对象存储—存储图片资源的对象</li></ul><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="# 开始搭建"></a><a href="#%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA">#</a> 开始搭建</h2><p>准备好上面的内容我们就开始搭建我们的图床吧~</p><h3 id="腾讯云CDN配置"><a href="#腾讯云CDN配置" class="headerlink" title="# 腾讯云CDN配置"></a><a href="#%E8%85%BE%E8%AE%AF%E4%BA%91cdn%E9%85%8D%E7%BD%AE">#</a> 腾讯云CDN配置</h3><p>腾讯云这边主要是对象存储配置和CDN配置</p><h4 id="对象存储"><a href="#对象存储" class="headerlink" title="# 对象存储"></a><a href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8">#</a> 对象存储</h4><p>我们腾讯云进入控制台面板，选择对象存储，进入对象存储面板，点击存储桶列表，点击创建存储桶</p><p>配置好你的个人需求后，进入下一步—配置高级可选配置，如果你没有什么想要配置的话就直接下一步就好了</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101706988.png" alt="img"></p><h4 id="CDN"><a href="#CDN" class="headerlink" title="# CDN"></a><a href="#cdn">#</a> CDN</h4><p>进入CDN面板后点击域名管理，而后添加域名然后进行配置</p><p>域名配置就按照你自己的需求进行配置，前提是得要自己个人域名的一个二级域名申请，这样到时候可以用这个域名访相应的图片</p><p>源站地址就选择刚才你创建的地址，然后点击确认添加后等待几分钟等它自己配置好就算完成了</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101706267.png" alt="749b0e532b7c9a3445bbb18c7dcfd0d"></p><h3 id="搭建PicGo"><a href="#搭建PicGo" class="headerlink" title="# 搭建PicGo"></a><a href="#%E6%90%AD%E5%BB%BApicgo">#</a> 搭建PicGo</h3><p>接下来就是搭建图床的最后一步了。在<a href="https://molunerfinn.com/PicGo/">官网  (opens new window)</a>下载该软件，下载后打开界面如下</p><p>打开设置建议开启时间戳命名，主要避免重命名</p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101706190.png" alt="img"></p><p>打开图床设置—&gt;找到腾讯云COS—&gt;打开腾讯面板—&gt;进入访问密钥</p><ul><li>Bucket就是对象存储的名称</li><li>SecretId、SecretKey  和 AppID 都能在访问密钥面板找到</li><li>存储区域在存储桶概览中的基本信息可以找到：在所属区域—例如：ap-shanghai</li><li>自定义域名就是CDN域名</li></ul><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202306101706671.jpeg" alt="img"></p><p>完成以上内容，我们的搭建图床就算完成了</p><h2 id="bug建议"><a href="#bug建议" class="headerlink" title="# bug建议"></a><a href="#bug%E5%BB%BA%E8%AE%AE">#</a> bug建议</h2><p>如果你发现你的 PicGo 上传的照片无法查看可以试着重启一下，如果重启无用就重新下载配置一下</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arp 攻击</title>
      <link href="/2022/05/12/Arp%20%E6%94%BB%E5%87%BB/"/>
      <url>/2022/05/12/Arp%20%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Arp-攻击"><a href="#Arp-攻击" class="headerlink" title="Arp 攻击"></a>Arp 攻击</h1><blockquote><p>本篇内容仅用于学习和测试，本人遵纪守法。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>arpspoof 是 dsniff 包里的一个程序，可用于arp攻击。Manjaro 中执行以下命令安装这个软件包就可以使用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S dsniff</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>arpspoof - 截获交换局域网中的数据包。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">      arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="line"></span><br><span class="line">描述</span><br><span class="line">      arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。</span><br><span class="line">      内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。</span><br></pre></td></tr></table></figure><h2 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h2><ol><li>断网攻击，不开启流量转发，使用我的无线网卡 <code>wlp8s0</code>，攻击网关</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo arpspoof -i wlp8s0 -t 192.168.1.1</span><br></pre></td></tr></table></figure><ol start="2"><li>中间人攻击，截获用户和网关之间的流量</li></ol><p>开启流量转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>欺骗双方，充当中间人</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo arpspoof -i wlp8s0 -t 192.168.1.1 192.168.1.106</span><br><span class="line">sudo arpspoof -i wlp8s0 -t 192.168.1.106 192.168.1.1</span><br></pre></td></tr></table></figure><p>此时网关以为我是106，而106以为我是网关。双方的流量都将经过这里，使用 WireShark 即可对经过网卡的流量进行分析。</p><ol start="3"><li>重定向攻击</li></ol><p>使局域网所有设备访问的 80 端口，重定向到我这里的 8080 端口，需要开启流量转发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo arpspoof -i wlp8s0 192.168.1.1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何白嫖微软Azure12个月及避坑指南</title>
      <link href="/2022/05/10/%5B%E5%A6%82%E4%BD%95%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFAzure12%E4%B8%AA%E6%9C%88%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%5D/"/>
      <url>/2022/05/10/%5B%E5%A6%82%E4%BD%95%E7%99%BD%E5%AB%96%E5%BE%AE%E8%BD%AFAzure12%E4%B8%AA%E6%9C%88%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%5D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何白嫖微软Azure12个月及避坑指南"><a href="#如何白嫖微软Azure12个月及避坑指南" class="headerlink" title="[如何白嫖微软Azure12个月及避坑指南]"></a>[如何白嫖微软Azure12个月及避坑指南]</h1><p>Azure是微软提供的一个云服务平台。是全球除了AWS外最大的云服务提供商。Azure是微软除了windows之外另外一个王牌，微软错过了移动端，还好抓住了云服务。这里的Azure是Azure国际不是Azure中国哈。Azure为全球提供服务，最近Azure推出了免费试用12个月的活动（也不算最近，这个活动应该好久了，只是我最近才发现），咱赶紧去白嫖一下。</p><h2 id="申请Azure试用"><a href="#申请Azure试用" class="headerlink" title="申请Azure试用"></a>申请Azure试用</h2><p>申请Azure请提前准备一部手机，一个Microsoft账号，一张双币信用卡。</p><h3 id="申请地址"><a href="#申请地址" class="headerlink" title="申请地址"></a>申请地址</h3><p><a href="https://azure.microsoft.com/zh-cn/free/">https://azure.microsoft.com/zh-cn/free/</a></p><h3 id="填写试用信息"><a href="#填写试用信息" class="headerlink" title="填写试用信息"></a>填写试用信息</h3><p><a href="https://s1.ax1x.com/2020/07/06/UCHBUH.png"><img src="https://s1.ax1x.com/2020/07/06/UCHBUH.png" alt="UCHBUH.png"></a></p><h3 id="验证手机"><a href="#验证手机" class="headerlink" title="验证手机"></a>验证手机</h3><p><a href="https://s1.ax1x.com/2020/07/06/UCqCkQ.png"><img src="https://s1.ax1x.com/2020/07/06/UCqCkQ.png" alt="UCqCkQ.png"></a></p><h3 id="填写信用卡信息"><a href="#填写信用卡信息" class="headerlink" title="填写信用卡信息"></a>填写信用卡信息</h3><p><a href="https://s1.ax1x.com/2020/07/06/UCqD1I.png"><img src="https://s1.ax1x.com/2020/07/06/UCqD1I.png" alt="UCqD1I.png"></a><br>只验证信息不会收取费用。第三步协议直接同意。</p><h3 id="登录Azure-Portal"><a href="#登录Azure-Portal" class="headerlink" title="登录Azure Portal"></a>登录Azure Portal</h3><p>注册成功后访问<a href="https://portal.azure.com/%E4%BD%BF%E7%94%A8%E5%88%9A%E6%89%8D%E6%B3%A8%E5%86%8C%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E5%88%B0Azure">https://portal.azure.com/使用刚才注册账号登录到Azure</a> Portal控制台。可以看到账号里已经有200刀的额度。<br><a href="https://s1.ax1x.com/2020/07/06/UCLcx1.png"><img src="https://s1.ax1x.com/2020/07/06/UCLcx1.png" alt="UCLcx1.png"></a></p><blockquote><p>注意：注册成功后获得一个月的免费试用及200刀的免费额度。一个月后只有升级为即用即付订阅才能真正享受12个月的免费政策。升级后需要格外注意试用的服务是否免费，或者免费的条件，比如虚拟机服务，只有B1s型号，并且要搭配64G高级SSD才是真正免费的，不然会收到账单哦，当然也不用太害怕，因为还有200刀的免费额度嘛。如果被扣费了还能联系客服申请退费，据说可以退一部分费用。实在不行就只有永久免费服务，Azure提供了很多永久免费服务。</p></blockquote><p><a href="https://s1.ax1x.com/2020/07/02/NbzG3F.png"><img src="https://s1.ax1x.com/2020/07/02/NbzG3F.png" alt="NbzG3F.png"></a></p><h2 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h2><p>有了账号咱就新建一个虚拟机玩玩，注意这里有个巨坑。<br>找到虚拟机控制台点新建，免费账号可以建2个免费虚拟机，一个linux，一个windows的。这里我们新建一个linux的。</p><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p><a href="https://s1.ax1x.com/2020/07/06/UCjOqx.png"><img src="https://s1.ax1x.com/2020/07/06/UCjOqx.png" alt="UCjOqx.png"></a><br>区域选日本或者香港，反正离你越近就越快。</p><blockquote><p>注意：大小选B1s !!!</p></blockquote><h3 id="选择磁盘"><a href="#选择磁盘" class="headerlink" title="选择磁盘"></a>选择磁盘</h3><p><a href="https://s1.ax1x.com/2020/07/06/UCvWSH.png"><img src="https://s1.ax1x.com/2020/07/06/UCvWSH.png" alt="UCvWSH.png"></a></p><blockquote><p>注意：磁盘选高级SSD</p></blockquote><h3 id="选择网络"><a href="#选择网络" class="headerlink" title="选择网络"></a>选择网络</h3><p><a href="https://s1.ax1x.com/2020/07/02/NbzE9S.png"><img src="https://s1.ax1x.com/2020/07/02/NbzE9S.png" alt="NbzE9S.png"></a><br>第一次新建需要新建一个虚拟网络，然后选择它</p><h3 id="管理选项"><a href="#管理选项" class="headerlink" title="管理选项"></a>管理选项</h3><p><a href="https://s1.ax1x.com/2020/07/02/NbzC7t.png"><img src="https://s1.ax1x.com/2020/07/02/NbzC7t.png" alt="NbzC7t.png"></a><br>为防止收费，全部选关闭<br><a href="https://s1.ax1x.com/2020/07/02/NbziAP.png"><img src="https://s1.ax1x.com/2020/07/02/NbziAP.png" alt="NbziAP.png"></a></p><h3 id="部署成功"><a href="#部署成功" class="headerlink" title="部署成功"></a>部署成功</h3><p>后面一路点下一步最后点提交，等待部署成功。<br><a href="https://s1.ax1x.com/2020/07/02/NbzV1g.png"><img src="https://s1.ax1x.com/2020/07/02/NbzV1g.png" alt="NbzV1g.png"></a><br>到虚拟机列表查看新建的虚机。<br><a href="https://s1.ax1x.com/2020/07/02/NbzZcQ.png"><img src="https://s1.ax1x.com/2020/07/02/NbzZcQ.png" alt="NbzZcQ.png"></a></p><h3 id="调整磁盘大小（必看）"><a href="#调整磁盘大小（必看）" class="headerlink" title="调整磁盘大小（必看）"></a>调整磁盘大小（必看）</h3><p><a href="https://s1.ax1x.com/2020/07/02/Nbznns.png"><img src="https://s1.ax1x.com/2020/07/02/Nbznns.png" alt="Nbznns.png"></a><br>磁盘默认是30G，是要收费的。接下来我们把它改成64G。<br><a href="https://s1.ax1x.com/2020/07/02/NbzeXj.png"><img src="https://s1.ax1x.com/2020/07/02/NbzeXj.png" alt="NbzeXj.png"></a><br>停止虚机<br><a href="https://s1.ax1x.com/2020/07/02/NbzuBn.png"><img src="https://s1.ax1x.com/2020/07/02/NbzuBn.png" alt="NbzuBn.png"></a><br>找到磁盘配置修改大小为64G<br><a href="https://s1.ax1x.com/2020/07/02/NbzlNV.png"><img src="https://s1.ax1x.com/2020/07/02/NbzlNV.png" alt="NbzlNV.png"></a><br>再次回到磁盘管理界面确认依据修改为64G。</p><h2 id="试用虚拟机"><a href="#试用虚拟机" class="headerlink" title="试用虚拟机"></a>试用虚拟机</h2><p>修改磁盘后重新运行虚拟机<br><a href="https://s1.ax1x.com/2020/07/02/Nbz1hT.png"><img src="https://s1.ax1x.com/2020/07/02/Nbz1hT.png" alt="Nbz1hT.png"></a><br>启动后通过ssh安装一个nginx</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install nginx</span><br></pre></td></tr></table></figure><p>安装完nginx后这个时候还是访问不通服务器80口的，因为默认是关闭的，需要打开它。<br><a href="https://s1.ax1x.com/2020/07/06/UP94d1.png"><img src="https://s1.ax1x.com/2020/07/06/UP94d1.png" alt="UP94d1.png"></a><br>在网络管理界面新建入站规则把80口打开<br><a href="https://s1.ax1x.com/2020/07/02/Nbz89U.png"><img src="https://s1.ax1x.com/2020/07/02/Nbz89U.png" alt="Nbz89U.png"></a><br>通过公网ip访问一下看到nginx的默认页面表示我们的虚机已经正常工作了，速度杠杠滴。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校教务系统的漏洞分析</title>
      <link href="/2022/03/15/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/15/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>本来是想着用Python写一个抢课的脚本，没想到在研究教务系统的网页时发现了我们教务系统漏洞还挺多。</p><p>学校教务系统搭建在IIS上，这个方正教务系统用的是ASP .NET,系统版本还是2017年的，据我们学长说以前也被人搞过，但仍然很长一段时间都没有升级系统。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/footer.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/footer.png" alt="教务系统底部"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里我已经提前知道了我们选课的那个页面对应xsxk.aspx，但教务系统首页现在的导航栏你活动报名一栏没有开放学生选课的入口，于是我们尝试把地址栏中的xs_main.aspx改为xsxk.aspx。一开始服务器返回了302，页面显示：<code>Object moved to here</code>，没事我们直接点进去，然后会有一个alert弹出，直接忽略就能进去了。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert.png" alt="img"></a><br><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk.png" alt="img"></a></p><p>点一下查看课表就可以把隐藏的按钮显示出来。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk2.png" alt="img"></a></p><p>点选修课程，然后会有一个窗口弹出，这里可能会被chrome拦截，点地址栏的允许弹出窗口就行了。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/window.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/window.png" alt="img"></a></p><p>随便选一个项目，然后点选定，这时主窗口的课程列表就会更新。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/lesson-list.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/lesson-list.png" alt="img"></a></p><p>随便点一个课程然后又会有一个弹出窗口，同时会有不允许选课的alert弹出。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert2.png" alt="img"></a></p><p>这时我们不要点确定，否则窗口就会被关闭。复制这个窗口地址栏的网址，新建一个标签页打开。弹出alert后就可以直接点确定，不出意外的话这个标签页应该不会被关闭。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs.png" alt="img"></a></p><p>但是这个页面仍然不允许选课，没事，依照刚才的思路，一定是有东西被隐藏了。我们通过开发人员工具可以发现，关闭按钮前面还有两个button的样式都被设为了<code>DISPLAY:NONE</code>。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools.png" alt="img"></a></p><p>把这两个button的DISPLAY属性都取消掉，关闭按钮前面就会出现两个空白的按钮。尝试点第一个按钮，就会弹出如下提示。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs2.png" alt="img"></a></p><p>同时我们想要的选课界面就出来了。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs3.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs3.png" alt="img"></a></p><p>选中单选框并选中不预定教材，然后点点选定按钮提交，就会用保存成功的提示。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/save-succeed.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/save-succeed.png" alt="img"></a></p><p>我们回到之前的页面查看我们的已选课程：</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/choosed-lesson.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/choosed-lesson.png" alt="img"></a></p><p>已选课程里面已经有了我们刚才选的课。</p><h3 id="更大胆的想法"><a href="#更大胆的想法" class="headerlink" title="更大胆的想法"></a>更大胆的想法</h3><p>教务系统网页提交信息时都会同时提交ViewState，虽然没有学过ASP，但通过查询资料，我觉得这个地方大有文章可做。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools2.png" alt="img"></a></p><p>尝试进行base64解码，结果里面出现了明文，说明没有经过加密。</p><p>资料：</p><blockquote><p>当 ASP .NET 中的表单被提交时，表单会随所有表单值一同重新出现。如何做到的呢？这是由于 ASP .NET 维持了您的 ViewState。ViewState 会在页面被提交到服务器时指示其状态。通过在每张页面中的一个 <code>&lt;form runat=&quot;server&quot;&gt;</code>控件中放置一个隐藏域，我们就可以定义页面的状态了。</p></blockquote><p>之后我专门查了关于这个VIEWSTATE里面的猫腻，发现了这个ViewState里面有不少可以利用的漏洞。</p><blockquote><p>其实ViewState 真正的问题在与其潜在的反序列化漏洞风险。ViewState 使用ObjectStateFormatter 进行反序列化，虽然ViewState 采取了加密和签名的安全措施。但是一旦泄露web.config，获取其加密和签名所用的密钥和算法，我们就可以将ObjectStateFormatte 的反序列化payload 进行同样的加密与签名，然后再发给服务器。这样ASP.NET在进行反序列化时，正常解密和校验，然后把payload交给ObjectStateFormatter 进行反序列化，触发其反序列化漏洞，实现RCE。</p></blockquote><p>由此，我们就可以在ViewState里进行XSS注入以实现跨站脚本攻击，从而在服务器上运行任意代码（我是这么理解的）。即使服务端开启了安全验证，我们仍然可以使用其他手段获取签名密钥以实现注入。</p><p>不过目前因为知识范围有限，暂时还没有进行相关的实验，以后有机会可以在教务系统上实验一下。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅的用VS Code写C++作业？</title>
      <link href="/2022/01/26/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%94%A8VS%20Code%E5%86%99C++%E4%BD%9C%E4%B8%9A%EF%BC%9F/"/>
      <url>/2022/01/26/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%94%A8VS%20Code%E5%86%99C++%E4%BD%9C%E4%B8%9A%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然有很多成熟的IDE可用，但只是写个作业还是没必要去用那些又大又慢的东西的。VS Code作为万能编辑器，可以用mingW配置C++的编译环境，但可惜会存在一些小问题，本着折腾的精神，总结一下互联网上的一下解决方法，并贴出我自己的方案。</p><h2 id="基础的配置"><a href="#基础的配置" class="headerlink" title="基础的配置"></a>基础的配置</h2><p>不再赘述，网上一查一大把。需要注意的是一定要选择一个文件夹作为代码的存放地点。在完成了配置后，你的<code>.vscode</code>文件夹下应该有数个<code>json</code>文件。</p><h2 id="编码问题与多文件引用问题"><a href="#编码问题与多文件引用问题" class="headerlink" title="编码问题与多文件引用问题"></a>编码问题与多文件引用问题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>如果你习惯在写代码的时候分成多个文件，最后在主函数里引用头文件调用，那在你编译运行的时候一定会遇到找不到定义的问题。</p><p>如果在代码中使用中文，便不得不处理中文的编码问题，网上的解决方案有很多，但要更改系统的默认设置或对其他功能造成影响。</p><p>以上两个问题通过更改Code Runner的默认编译指令解决。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>请保证开启了<code>Run in Terminal</code>选项。文件编码依然采用<code>utf8</code>格式，在<code>.vscode</code>文件夹下新建<code>settings.json</code>(或者在用户的<code>settings.json</code>中操作)，在最外部的一对大括号添加(若无，先自己加一对大括号)：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;code-runner.executorMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd $dir &amp;&amp; gcc *.c -fexec-charset=gb2312 -o $fileNameWithoutExt.exe &amp;&amp; $dir$fileNameWithoutExt.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cpp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd $dir &amp;&amp; g++ *.cpp -fexec-charset=gb2312 -o $fileNameWithoutExt.exe &amp;&amp; $dir$fileNameWithoutExt.exe&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>使用<code>-fexec-charset</code>参数指定输出编码，避免了需要更改文件或控制台默认编码的文件；使用通配符指定文件夹内所有cpp文件为需要编译的文件，修正了引用的问题。如果需要更加精细的设置，可以自己修改。</p><h2 id="Debug问题"><a href="#Debug问题" class="headerlink" title="Debug问题"></a>Debug问题</h2><p>直接贴配置了，不多说。</p><p>tasks.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Compile&quot;</span><span class="punctuation">,</span><span class="comment">//可以随意更改，保证与launch.json的preLaunchTask相同</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\*.cpp&quot;</span><span class="punctuation">,</span><span class="comment">//编译所有文件，根据自己需要更改</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span><span class="comment">//一定要加这个参数，不然没法加断点</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Project/mingw64/bin&quot;</span><span class="comment">//自己的编译器路径，自行修改</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;编译器: C:/Project/mingw64/bin/g++.exe&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>launch.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Project/mingw64/bin&quot;</span><span class="punctuation">,</span><span class="comment">//自己的编译器路径，自行修改</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Project\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span><span class="comment">//自己的gdb路径，自行修改</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Compile&quot;</span><span class="comment">//可以随意更改，保证与tasks.json的label相同</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>如果你的文件不是<code>utf8</code>编码，那在调试的时候中文会变成乱码，这也是前文要求保持<code>utf8</code>编码的原因。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turbo ACC 网络加速模块</title>
      <link href="/2021/12/26/Turbo%20ACC%20%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F%E6%A8%A1%E5%9D%97/"/>
      <url>/2021/12/26/Turbo%20ACC%20%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Turbo-ACC-网络加速模块"><a href="#Turbo-ACC-网络加速模块" class="headerlink" title="Turbo ACC 网络加速模块"></a>Turbo ACC 网络加速模块</h1><p>Turbo ACC 模块本身是一个插件合集，使用它能够对网络进行优化和加速。</p><p>它提供的功能有：</p><ol><li>Flow Offloading 转发加速，来自高通开源的 Shortcut FE 转发加速引擎 (Fast Path)，一种纯软件算法上的优化。可以针对openwrt所有型号的路由器。</li><li>HWNAT加速。一般只针对 MT762x 芯片型号的路由器可以开启。</li><li>BBR加速。谷歌弄出来的一个内核级别的 TCP 协议的优化，可以提高网络连接的能力(争抢带宽能力)，这是linux内核 4.9 以后都可以用的一个东西，内核大于 4.9 的所有型号Openwrt路由器都能用。</li><li>DNS 加速。主要是利用 pdnsd 做本地缓存，提高DNS解析速度，所有型号路由器都能用。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下载编译好的 luci-app-flowoffload 插件，运行 <code>opkg install luci-app-flowoffload.ipk</code> 进行安装。</p><p>安装完成后可在 luci 后台 <strong>Network-&gt;Turbo ACC Center</strong> 中进行管理，视路由器情况而开启加速功能。Flow Offloading 在 <strong>Network-&gt;Firewall</strong> 中进行管理。</p><p>DNS 解析就不开了，别处已经用到了🤐</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt 第三方软件源 &amp; opkg</title>
      <link href="/2021/12/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%BA%90%20&amp;%20opkg/"/>
      <url>/2021/12/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%BA%90%20&amp;%20opkg/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenWrt-第三方软件源-amp-opkg"><a href="#OpenWrt-第三方软件源-amp-opkg" class="headerlink" title="OpenWrt 第三方软件源 &amp; opkg"></a>OpenWrt 第三方软件源 &amp; opkg</h1><p>可直接访问手动下载的软件库： <a href="https://op.supes.top/">https://op.supes.top</a></p><p>其实在 GitHub 有很多第三方的软件源的，里面的安装包都非常丰富，里面的插件也非常的全。不能写出来，得自己去发现。</p><p>各种软件源的下载方式（官方英文）：</p><table><thead><tr><th>方式</th><th>描述</th></tr></thead><tbody><tr><td>src-bzr</td><td>Data is downloaded from the source path&#x2F;URL using bzr</td></tr><tr><td>src-cpy</td><td>Data is copied from the source path. The path can be specified as either relative to OpenWrt repository root or absolute.</td></tr><tr><td>src-darcs</td><td>Data is downloaded from the source path&#x2F;URL using darcs</td></tr><tr><td>src-git</td><td>Data is downloaded from the source path&#x2F;URL using git as a shallow (depth of 1) clone</td></tr><tr><td>src-git-full</td><td>Data is downloaded from the source path&#x2F;URL using git as a full clone</td></tr><tr><td>src-gitsvn</td><td>Bidirectional operation between a Subversion repository and git</td></tr><tr><td>src-hg</td><td>Data is downloaded from the source path&#x2F;URL using hg</td></tr><tr><td>src-link</td><td>A symlink to the source path is created. The path must be absolute.</td></tr><tr><td>src-svn</td><td>Data is downloaded from the source path&#x2F;URL using svn</td></tr></tbody></table><h2 id="修改官方源"><a href="#修改官方源" class="headerlink" title="修改官方源"></a>修改官方源</h2><p>打开默认的源配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/opkg/distfeeds.conf</span><br></pre></td></tr></table></figure><p>修改为清华软件源</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/gz openwrt_base https://mirror.sjtu.edu.cn/openwrt/releases/packages-21.02/mipsel_24kc/base</span><br><span class="line">src/gz openwrt_luci https://mirror.sjtu.edu.cn/openwrt/releases/packages-21.02/mipsel_24kc/luci</span><br><span class="line">src/gz openwrt_packages https://mirror.sjtu.edu.cn/openwrt/releases/packages-21.02/mipsel_24kc/packages</span><br><span class="line">src/gz openwrt_routing https://mirror.sjtu.edu.cn/openwrt/releases/packages-21.02/mipsel_24kc/routing</span><br></pre></td></tr></table></figure><h2 id="添加自定义源"><a href="#添加自定义源" class="headerlink" title="添加自定义源"></a>添加自定义源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/opkg/customfeeds.conf</span><br></pre></td></tr></table></figure><p>在此文件中添加自定义源</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/gz kuoruan_packages http://openwrt.kuoruan.net/packages/releases/mipsel_24kc</span><br><span class="line">src/gz kuoruan_universal http://openwrt.kuoruan.net/packages/releases/all</span><br><span class="line">src/gz openwrt_kiddin9 https://op.supes.top/packages/mipsel_24kc</span><br></pre></td></tr></table></figure><h2 id="关闭签名检查"><a href="#关闭签名检查" class="headerlink" title="关闭签名检查"></a>关闭签名检查</h2><p>如果添加自定义的源时，不添加密钥就需要关闭签名检查。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/opkg.conf</span><br></pre></td></tr></table></figure><p>将 <code>option check_signature</code> 行使用 # 注释掉。</p><p>对软件源配置文件进行完修改后，更新软件列表 <code>opkg update</code></p><h2 id="opkg-的基本使用"><a href="#opkg-的基本使用" class="headerlink" title="opkg 的基本使用"></a>opkg 的基本使用</h2><p>下面的例子应该可以比较直观地看出来，一些基本的使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">opkg update <span class="comment">#更新可用软件包列表</span></span><br><span class="line">opkg upgrade 软件包名1 软件包名2 <span class="comment">#升级软件包</span></span><br><span class="line">opkg install dnsmasq <span class="comment">#安装软件</span></span><br><span class="line">opkg install http://downloads.openwrt.org/snapshots/trunk/ar71xx/packages/hiawatha_7.7-2_ar71xx.ipk <span class="comment"># 安装软件</span></span><br><span class="line">opkg install /tmp/hiawatha_7.7-2_ar71xx.ipk <span class="comment">#安装软件</span></span><br><span class="line">opkg remove 软件包名 <span class="comment">#删除软件</span></span><br><span class="line">opkg list <span class="comment">#列出可用软件包</span></span><br><span class="line">opkg list-installed <span class="comment">#列出已安装软件包</span></span><br><span class="line">opkg list-upgradable <span class="comment">#列出可升级的已安装软件包</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenWrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在2021年年底的一些废话</title>
      <link href="/2021/12/26/%E8%B4%9F%E8%83%BD%E9%87%8F%E8%AD%A6%E5%91%8A%EF%BC%81/"/>
      <url>/2021/12/26/%E8%B4%9F%E8%83%BD%E9%87%8F%E8%AD%A6%E5%91%8A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>负能量警告！</p><p>很早就有写点什么的想法了，关于这篇博客的主题也不知道该怎么起，思绪也很乱，也不知道从哪里开头，算了，想到什么就写什么吧，反正也没人看</p><p>不知不觉就要到2021年了，大学过的感觉大部分都是比较麻木，对时间流逝的感知也变淡了。虽然已经想不起高考是什么感觉，但每每梦见我回去复读，醒来都有一种十分说不清的无力感与自责感。</p><hr><p>到了大学，接触了新环境和新的人，虽然心态更平和了一些，但偶尔跟室友聊起高考，还是会对当年的败笔念念不忘。</p><p>偶尔安慰自己，普通一本也挺好的，已经是现实了，咬牙切齿也没用，谁让自己不争气呢。</p><p>后来，又有了转专业的想法，那时候听说转到好专业很难，一直不敢想，也犹豫不决到底要不要转。</p><p>大一的一年过的还算顺利，虽然是不喜欢的专业，但凭着不知道哪里来的耐心，我以一个还算可以的结果结束了大一生活。</p><p>噩梦开始了。</p><hr><p>大一暑假，通过小道消息得知转专业名额增加，于是对这条路又有了点希望。虽然不断关注这些，该做的也都做了，但好像自己被一股无形了力量控制了一般。</p><p>填写转专业志愿时来回修改了三次，期待，害怕，希望与压迫感并存。</p><p>是逃离，还是下赌注</p><p>我最后选择了逃离。</p><hr><p>无论是选择的代价，还是结果的被刺，都让我痛苦了好长一阵子</p><p>从一个专业到另一个，就像梦一般，麻木无力</p><p>开始准备上新专业课了，我却一点也听不进去。</p><p>用现在流行的话说，就是摆烂，摆大烂</p><hr><p>那天晚上，和室友聊起了人生与未来</p><p>很早也就在想，以后到底要从事什么</p><p>然而到现在还没有定下来</p><p>什么都学的稀里糊涂，没有专业擅长的领域是很可怕的事</p><p>更可怕的是，学校教的也擅长不了</p><hr><p>终究过成了自己讨厌的样子</p><p>整天上课浑浑噩噩，不知道自己在干什么</p><p>课下就只会忙着自己的事情，好像学业不存在一样</p><p>渐渐学会了抄作业，自己不会也不想学</p><hr><p>曾经有过梦想，在很遥远很遥远的地方</p><p>而如今，梦想却越来越模糊了</p><p>到底该怎么办呢</p><hr><p>内卷在我身上的体现并不严重</p><p>可能除了期末会卷一卷吧</p><p>对于自己喜欢的学科领域，仅仅浮在喜欢之上罢了</p><p>正儿八经学起来谁知道自己会不会烦呢…</p><hr><p>本来也想着写个所谓的 2021 年终总结</p><p>或者又是诸如 2022 人生规划</p><p>想想还是算了吧，没啥意义，反正我也做不到</p><hr><p>这写的都是啥啊，算了反正也没人看</p><p>有人看到的话就当我是在胡言乱语吧</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 废话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宗教答题直接满分的方法</title>
      <link href="/2021/12/25/%E5%AE%97%E6%95%99%E7%AD%94%E9%A2%98%E7%9B%B4%E6%8E%A5%E6%BB%A1%E5%88%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/12/25/%E5%AE%97%E6%95%99%E7%AD%94%E9%A2%98%E7%9B%B4%E6%8E%A5%E6%BB%A1%E5%88%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="电脑端"><a href="#电脑端" class="headerlink" title="电脑端"></a>电脑端</h3><p>打开答题页面，然后按F12打开开发者工具，点击上方的Console(或控制台)，粘贴下面的代码，回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">var topicid=topicJsonArray[0][&quot;TOPICID&quot;];</span><br><span class="line">    for(var i=0;i&lt;topicJsonArray.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        topicJsonArray[i][&quot;TOPICID&quot;]=topicid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意会返回一串数字，如果没有就是复制的有问题。<br> <br>然后在题库里搜索第一题的答案，把第一题的正确选项选上，直接点提交即可。</p><h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>下载并安装<a href="https://www.coolapk.com/apk/mark.via">Via浏览器</a><br>用这个浏览器打开答题页面，然后点开上方的标题栏，输入下面的代码并回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">javascript:var kzt=document.createElement(&quot;script&quot;); kzt.src=&quot;//cdnjs.cloudflare.com/ajax/libs/vConsole/3.3.4/vconsole.min.js&quot;; kzt.onload=function()&#123;new VConsole();&#125;; document.body.appendChild(kzt);</span><br></pre></td></tr></table></figure><p>然后界面会多出来一个vConsole按钮，点开，在Console栏下面的Command输入框内输入下面的代码并回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">var topicid=topicJsonArray[0][&quot;TOPICID&quot;];</span><br><span class="line">    for(var i=0;i&lt;topicJsonArray.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        topicJsonArray[i][&quot;TOPICID&quot;]=topicid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后点一下上面的部分返回答题界面，同样是把第一题答对提交即可。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>复制代码的时候不要把左边的行号复制上。<br>输完代码回车后不要刷新页面，否则需要重新输一次。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/28/hello-world/"/>
      <url>/2021/07/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
