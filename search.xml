<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Eureka自我保护机制开启了但是服务还是被删掉了</title>
      <link href="/2023/03/15/Eureka%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/03/15/Eureka%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Eureka自我保护机制开启了但是服务还是被删掉了"><a href="#Eureka自我保护机制开启了但是服务还是被删掉了" class="headerlink" title="Eureka自我保护机制开启了但是服务还是被删掉了"></a>Eureka自我保护机制开启了但是服务还是被删掉了</h1><h3 id="事件重现："><a href="#事件重现：" class="headerlink" title="事件重现："></a>事件重现：</h3><h4 id="Eureka中80和10000都注册进来了"><a href="#Eureka中80和10000都注册进来了" class="headerlink" title="Eureka中80和10000都注册进来了"></a>Eureka中80和10000都注册进来了</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091059266.png" alt="image-20230409105935095"></p><h4 id="将80服务关闭"><a href="#将80服务关闭" class="headerlink" title="将80服务关闭"></a>将80服务关闭</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091101485.png" alt="image-20230409110137386"></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091102132.png" alt="image-20230409110201073"></p><h4 id="Eureka中就只剩10000了，80服务被删除了"><a href="#Eureka中就只剩10000了，80服务被删除了" class="headerlink" title="Eureka中就只剩10000了，80服务被删除了"></a>Eureka中就只剩10000了，80服务被删除了</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091102808.png" alt="image-20230409110238742"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>图一可以看到，在Eureka中我10000和80服务都已经注册进去了，在图二中我把80关闭了，但是Eureka确把80服务删除了，这不对啊，我Eureka自我保护模式没关啊！根据Eureka的自我保护模式就算服务关闭了，但是注册中心Eureka也不会将这个实例删除才对啊？应该是80,10000都在才符合我的预期啊！</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>因为我关闭80是通过idea关闭,idea让它们正常的走了应用消亡的生命周期,让资源得到了回收，所以我关掉80时，Eureka就将这个实例删除了。</p><p>我要怎么实验下Eureka自我保护模式呢？服务关闭但是Eureka没有将这个服务剔除出去？<br>正确测试方法：<br>用命令查询所有端口：netstat -ano<br>再用 ：taskkill &#x2F;pid pid号 &#x2F;f 强行关闭这个端口</p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册中心 </tag>
            
            <tag> CAP理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat和Spring和servlet和springMVC之间的关系</title>
      <link href="/2023/03/10/spring/"/>
      <url>/2023/03/10/spring/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tomcat和Spring和servlet和springMVC之间的关系"><a href="#Tomcat和Spring和servlet和springMVC之间的关系" class="headerlink" title="Tomcat和Spring和servlet和springMVC之间的关系"></a>Tomcat和Spring和servlet和springMVC之间的关系</h1><h2 id="1、Servlet是什么？"><a href="#1、Servlet是什么？" class="headerlink" title="1、Servlet是什么？"></a>1、<strong>Servlet是</strong>什<strong>么？</strong></h2><p>servlet就是一个Java接口，是JavaEE规范的一种，主要是为了扩展Java作为Web服务的功能。</p><p>由其他内部厂商如tomcat，JBoss内部实现web的功能。</p><p>如一个http请求到来：</p><p>容器将请求封装为servlet中的HttpServletRequest对象，调用init（），service（）等方法输出response,由容器包装为httpresponse返回给客户端的过程。</p><h2 id="2、Spring框架"><a href="#2、Spring框架" class="headerlink" title="2、Spring框架"></a>2、Spring框架</h2><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p><h2 id="3、关系"><a href="#3、关系" class="headerlink" title="3、关系"></a>3、关系</h2><p>1、Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。</p><p>2、Springmvc的核心是一个DispatcherServlet，并且DispatcherServlet继承自 FrameworkServlet继承自HttpServletBean 继承自HttpServlet（也就是你说的servelt） 本质上是一样的东西。其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情，如校验，拦截（AOP思想），后期渲染等等，好让我们专注于业务的开发。</p><p>servlet、filter和listener是javaweb得三大组成部分。</p><p>其中servlet通常是由web.xml统一管理。</p><p>而springmvc核心是disparcherservlet为入口。</p><p>spring可以管理servlet和springmvc中得javabean，这个意思就是说servlet和springmvc是相对独立的两个servlet，</p><p>当你想要在一个继承servlet的实现类中，控制url映射的时候，必须在web.xml配置对应关系，即使你把这个servlet交给spring去管理</p><p>他的映射入口依然是web.xml中你配置的那个路径，跟dispatcherservlet没有关系。这就导致了spring中有一个注入的servlet，并且还有一个独立的servlet（可以说是由web.xml管理的），最终如果你在servlet、filter注入属性的时候不成功。</p><h3 id="servlet工作流程"><a href="#servlet工作流程" class="headerlink" title="servlet工作流程"></a>servlet工作流程</h3><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303262210496.webp" alt="img"></p><h2 id="Tomcat和Spring关系"><a href="#Tomcat和Spring关系" class="headerlink" title="Tomcat和Spring关系"></a>Tomcat和Spring关系</h2><p>​Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。</p><p>​比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器，SpringMVC是处理Servlet请求的应用，<strong>其中DispatcherServlet实现了Servlet接口</strong>，<strong>Tomcat负责加载和调用DispatcherServlet。</strong>同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p><blockquote><p>​如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p></blockquote><blockquote><p>​<strong>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</strong></p></blockquote><h2 id="Spring-MVC与Jsp-x2F-Servlet比较"><a href="#Spring-MVC与Jsp-x2F-Servlet比较" class="headerlink" title="Spring MVC与Jsp&#x2F;Servlet比较"></a>Spring MVC与Jsp&#x2F;Servlet比较</h2><h4 id="1、传统的-Jsp-x2F-Servlet-技术体系弊端"><a href="#1、传统的-Jsp-x2F-Servlet-技术体系弊端" class="headerlink" title="1、传统的 Jsp&#x2F;Servlet 技术体系弊端"></a>1、传统的 Jsp&#x2F;Servlet 技术体系弊端</h4><blockquote><p>Servlet： 是用java编写的服务端应用程序。</p></blockquote><ul><li>作用：主要用于交互式的浏览和修改数据，生成web内容，这个过程为：客户端发送请求到服务器 -&gt; 服务器将请求信息发送至Servlet–&gt;Servlet生成相应内容并将其传给服务器-&gt; 服务器将响应返回给客户端。</li><li>在传统的 Jsp&#x2F;Servlet 技术体系中，如果要开发接口，一个接口对应一个<br>Servlet，每个请求都去在web.xml中配置一个servlet节点。会导致我们开发出许多 Servlet，使用 SpringMVC可以有效的简化这一步骤。</li></ul><h4 id="2、Spring-Web-MVC-特点"><a href="#2、Spring-Web-MVC-特点" class="headerlink" title="2、Spring Web MVC 特点"></a>2、Spring Web MVC 特点</h4><ul><li><p>Spring Web MVC 是一种基于 Java 的实现了 Web MVC 设计模式的请求驱动类型的轻量级 Web 框架，即使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringWeb MVC 也是要简化我们日常 Web 开发的。</p></li><li><p>Spring Web MVC 也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器可以拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View<br>Resolver)进行视图管理；页面控制器&#x2F;动作&#x2F;处理器为 Controller 接口（仅包含 ModelAndView handleRequest(request, response) 方法，也有人称作 Handler）的实现（也可以是任何的 POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。</p></li></ul><h4 id="3、Spring-MVC工作流程"><a href="#3、Spring-MVC工作流程" class="headerlink" title="3、Spring MVC工作流程"></a>3、Spring MVC工作流程</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303262206811.jpg" alt="韩顺平 Java工程师课程-SpringMVC"></p><ul><li><p>1、用户发送请求至前端控制器DispatcherServlet。</p></li><li><p>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p></li><li><p>3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p></li><li><p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p></li><li><p>5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p></li><li><p>6、Controller执行完成返回ModelAndView。</p></li><li><p>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p></li><li><p>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p></li><li><p>9、ViewReslover解析后返回具体View。</p></li><li><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p></li><li><p>11、DispatcherServlet响应用户。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired和@Resource的区别</title>
      <link href="/2023/02/25/@Autowired%E5%92%8C@Resource/"/>
      <url>/2023/02/25/@Autowired%E5%92%8C@Resource/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h1><blockquote><p>Spring的一大核心功能就是IOC，它能帮助我们实现自动装配，</p></blockquote><hr><ul><li>@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</li></ul><p>当我们在将一个类上标注@Service或者@Controller或@Component或@Repository注解之后，<em><strong>spring的组件扫描就会自动发现它，并且会将其初始化为spring应用上下文中的bean。</strong></em></p><p>当需要使用这个bean的时候，例如加上@Autowired注解的时候，这个bean就会被创建。而且初始化是根据无参构造函数。</p><p>注释可以直接在属性上使用，因此不需要getter和setter:</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooFormatter</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建FooService时，Spring查找并注入fooFormatter。</p><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p>1、@Resource是JDK原生的注解，@Autowired是Spring2.5 引入的注解</p><p>2、@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>@Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。</p><p><strong>@Autowired</strong></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303252014969.webp" alt="img"></p><p><strong>@Resource</strong></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303252015360.webp" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@Autowired功能虽说非常强大，但是也有些不足之处。比如它跟Spring强耦合了，如果换成了其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。</p><p>除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。</p><p>1、@Autowired默认按byType自动装配，而@Resource默认byName自动装配。</p><p>2、@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。</p><p>3、@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。</p><p>4、@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。</p><p>5、@Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。</p><p>6、二者装配顺序不同</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器常用操作整理</title>
      <link href="/2022/11/25/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2022/11/25/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>服务器玩的多了之后，各种常用的操作越来越多了，每次用都还得上网搜一下很麻烦，于是打算写一篇文章来总结一下。</p><h3 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h3><p>先介绍一下EPEL源：</p><blockquote><p><strong>EPEL源</strong> (Extra Packages for Enterprise Linux) 是由 Fedora Special Interest Group 为企业 Linux 创建、维护和管理的一个高质量附加包集合适用于但不仅限于 Red Hat Enterprise Linux (RHEL), CentOS, Scientific Linux (SL), Oracle Linux (OL)</p></blockquote><p>配置 EPEL源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum -y update</span><br></pre></td></tr></table></figure><h4 id="Nginx安装及配置"><a href="#Nginx安装及配置" class="headerlink" title="Nginx安装及配置"></a>Nginx安装及配置</h4><p>安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure><p>安装成功后，默认的网站目录为： <code>/usr/share/nginx/html</code></p><p>默认的配置文件为：<code>/etc/nginx/nginx.conf</code></p><p>自定义配置文件目录为: <code>/etc/nginx/conf.d/</code></p><p><strong>监听80端口并跳转443端口：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name xxx.xxx.xxx;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>监听443端口并导入证书：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">server&#123;</span><br><span class="line"># 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块</span><br><span class="line">listen       443 ssl;</span><br><span class="line"># 域名，多个以空格分开</span><br><span class="line">server_name  xxx.xxx.xxx</span><br><span class="line"></span><br><span class="line"># ssl证书地址</span><br><span class="line">ssl_certificate     /usr/local/nginx/cert/ssl.pem;  # pem文件的路径</span><br><span class="line">ssl_certificate_key  /usr/local/nginx/cert/ssl.key; # key文件的路径</span><br><span class="line"></span><br><span class="line"># ssl验证相关配置</span><br><span class="line">ssl_session_timeout  5m;    #缓存有效期</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议</span><br><span class="line">ssl_prefer_server_ciphers on;   #使用服务器端的首选算法</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>端口转发：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_pass http://127.0.0.1:5212/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Node-js-环境安装及配置"><a href="#Node-js-环境安装及配置" class="headerlink" title="Node.js 环境安装及配置"></a>Node.js 环境安装及配置</h4><p><strong>普通安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sudo yum install nodejs</span><br></pre></td></tr></table></figure><p><strong>使用NVM安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>因为我电脑上的node是14.15.1版本，所以服务器上也安装这个版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">nvm install v14.15.1</span><br><span class="line">nvm use v14.15.1</span><br></pre></td></tr></table></figure><h4 id="MySQL安装及配置"><a href="#MySQL安装及配置" class="headerlink" title="MySQL安装及配置"></a>MySQL安装及配置</h4><p><strong>下载并安装MySQL官方的Yum Repository：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>使用上面的命令直接安装Yum Repository：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong>安装MySQL服务器：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><p><strong>启动MySQL：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">systemctl start  mysqld.service</span><br></pre></td></tr></table></figure><p>此时MySQL已经开始正常运行，需要找出root的密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>登录MySQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入初始密码，此时不能做任何事情，因为MYSQL默认必须修改密码才能正常使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;;</span><br><span class="line"></span><br><span class="line"># 这里会遇到一个问题，新密码设置过于简单会报错</span><br></pre></td></tr></table></figure><p>MySQL配置文件目录：<code>/etc/my.cnf</code></p><p>另外提一下，MySQL占用内存好像有点高，在我的VPS上占了将近150MB的内存，我总共内存才1G，所以下次考虑使用外置的SQL Server或者干脆用sqlite3吧。</p><h3 id="Linux系统配置"><a href="#Linux系统配置" class="headerlink" title="Linux系统配置"></a>Linux系统配置</h3><h4 id="添加Swap分区"><a href="#添加Swap分区" class="headerlink" title="添加Swap分区"></a>添加Swap分区</h4><p>创建一个swap文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">dd if=/dev/zero of=/swapfile bs=1024 count=1024000</span><br></pre></td></tr></table></figure><p>更改Swap文件的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure><p>使用如下命令告知系统将该文件用于swap：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">mkswap /var/swapfile</span><br></pre></td></tr></table></figure><p>输入如下命令开始使用该swap：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">swapon /var/swapfile</span><br></pre></td></tr></table></figure><p>自动挂载，编辑<code>/etc/fstab</code>，在最后加上一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">/swapfile swap    swap    defaults      0    0</span><br></pre></td></tr></table></figure><h3 id="一键脚本整理"><a href="#一键脚本整理" class="headerlink" title="一键脚本整理"></a>一键脚本整理</h3><h4 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h4><p>Xray脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">wget -N --no-check-certificate -q -O install.sh &quot;https://raw.githubusercontent.com/wulabing/Xray_onekey/main/install.sh&quot; &amp;&amp; chmod +x install.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure><p>配置文件目录为：<code>/usr/local/etc/xray/config.json</code></p><p>Trojan脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">source &lt;(curl -sL https://git.io/trojan-install)</span><br></pre></td></tr></table></figure><p>配置文件目录为：<code>/etc/trojan-go/config.json</code></p><h4 id="软件类"><a href="#软件类" class="headerlink" title="软件类"></a>软件类</h4><p><a href="https://github.com/cloudreve/Cloudreve">Cloudreve</a>部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"># 解压程序包</span><br><span class="line">tar -zxvf cloudreve_VERSION_OS_ARCH.tar.gz</span><br><span class="line"></span><br><span class="line"># 赋予执行权限</span><br><span class="line">chmod +x ./cloudreve</span><br><span class="line"></span><br><span class="line"># 启动 Cloudreve</span><br><span class="line">./cloudreve</span><br></pre></td></tr></table></figure><h3 id="常用命令整理"><a href="#常用命令整理" class="headerlink" title="常用命令整理"></a>常用命令整理</h3><h4 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h4><p>tar命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">tar –xvf file.tar  # 解压 tar包</span><br><span class="line">tar -xzvf file.tar.gz  # 解压tar.gz</span><br><span class="line">tar -xzvf file.tar.gz -C /home/tar  # 解压tar.gz到tar目录</span><br></pre></td></tr></table></figure><p>unrar&#x2F;unzip命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">unzip file.zip</span><br><span class="line">unrar e file.rar</span><br></pre></td></tr></table></figure><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>chmod命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">chmod 777 xxx.tar # 将xxx的权限设置为777</span><br></pre></td></tr></table></figure><p>chown命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">chown root file # 将file的所有者设置为root</span><br><span class="line">chown root:root file # 将file的所有者和用户组设置为root</span><br></pre></td></tr></table></figure><h4 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h4><p>find命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">find /dir -name &#x27;file.so&#x27;</span><br><span class="line"># 在/dir目录下搜索file.so文件</span><br></pre></td></tr></table></figure><h4 id="系统占用"><a href="#系统占用" class="headerlink" title="系统占用"></a>系统占用</h4><p>查看剩余内存：<code>free -h</code></p><p>以占用内存大小为顺序显示后台进程：<code>top -o %MEM</code></p><p>以占用CPU大小为顺序显示后台进程：<code>top -o %CPU</code></p><p>查看分区和磁盘：<code>lsblk</code></p><p>查看空间使用情况：<code>df -h</code></p><p>分区工具查看分区信息：<code>fdisk -l</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt编译与刷写踩坑记录</title>
      <link href="/2022/10/08/OpenWrt%E7%BC%96%E8%AF%91%E4%B8%8E%E5%88%B7%E5%86%99%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/10/08/OpenWrt%E7%BC%96%E8%AF%91%E4%B8%8E%E5%88%B7%E5%86%99%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近整了一台软路由，配置还不错，既然这样那肯定要折腾折腾，首先肯定是要刷个 <a href="https://openwrt.org/">OpenWrt</a> 嘛，但是网上找到的固件都不太合我心意，要么是软件包过于冗杂，要么是太过精简，于是就想自己编译一个固件来用，接下来便是踩坑的开始。</p><p>老规矩，先上一张成果图：</p><p><a href="https://bu.dusays.com/2021/11/11/0842f99a09ee8.png"><img src="https://bu.dusays.com/2021/11/11/0842f99a09ee8.png" alt="img"></a></p><h3 id="编译部分"><a href="#编译部分" class="headerlink" title="编译部分"></a>编译部分</h3><p>编译所使用的源码是 <a href="https://github.com/coolsnowwolf/lede">Lean’s OpenWrt</a>。这套源码在论坛里很有名，编译成功率也高。</p><h4 id="编译方案"><a href="#编译方案" class="headerlink" title="编译方案"></a>编译方案</h4><p>编译有本地和云端两张方式可选，本来是觉得自己电脑CPU性能还可以要不本地编译吧，但了解到编译过程中需要下载Linux内核以及其他的一大堆东西时，还是选择了云端编译方案，最终选用了 <a href="https://github.com/P3TERX/Actions-OpenWrt">P3TERX 的 Github Actions 编译方案</a>。</p><h4 id="编译配置问题"><a href="#编译配置问题" class="headerlink" title="编译配置问题"></a>编译配置问题</h4><p>在配置时碰到了好几个问题，这里记录一下。</p><p><strong>首先是目标镜像的文件系统问题。</strong>一般情况下大部分人选择的都是 SquashFS，这个文件系统的优点是系统分区默认只读，所有的配置都在 <code>/overlay</code> 分区下，这样每次重置时就只需要清除这个分区的内容就可以。但对我来说，我是一个比较喜欢折腾的人，难免会经常对系统分区魔改啥的，而这时 Ext4 文件系统就比较符合我的要求。但是我在网上一些论坛找其他大佬编译的包时，几乎找不到Ext4文件系统的镜像，所以觉得很奇怪。</p><p>后来，当我在一个大佬的群里问起这个的时候，有人告诉我，使用 Ext4 文件系统如果不正常关机的话会造成文件系统只读或损坏的现象。然后我详细去了解了一下，发现这个问题是 Linux 系统共有的问题。不过虽然这样我任然心存一丝侥幸，自己应该不会碰到不正常关机的情况。再后来，我为了验证这个情况，再正常使用时将软路由直接断电，连续进行了三次实验，均没有发现文件系统出问题。于是我就安心的继续用我的Ext4文件系统了。（截止写文章时已经正常运行了两天半）</p><p><strong>然后是软件包的选择编译问题</strong>，这个问题可能比较玄学，具体哪个包跟哪个包会冲突很可能要等到编译失败的时候才知道（一般都是编译两个多小时了才失败），而且网上论坛里也很少有讨论这个的。比如想包括 IPv6 功能时要选择与IPv6有关的包，这时候 odhcpd 和 odhcp-ipv6 这两个包就会冲突，而且这两个包的描述写的都是 IPv6 相关功能的，并且 odhcpd 跟另一个叫 odhcpc 的包名字很像，稍有不慎就会选错。除了这个以外其他的比如luci-samba和luci-amba4也会引起这样的冲突。</p><p>还有一个会引起冲突的就是 luci-base 和 luci-compat 当版本不对应时引起冲突。第一次的我编译的包没有编译 luci-compat，在使用时尝试安装就会装不上。而第二次在编译时就把两个包同时装上就没问题。</p><p>另外，如果你配置时选择的软件比较多，编译时可能会出现 <code>out of space usage </code>的问题，这是因为默认情况下 OpenWrt 的Root分区只有 160 MB 的空间，软件一多自然就装不下了。在编译配置时把 root patition size 调大就行了，我调的是 512MB。</p><p><strong>还有一个内核版本的问题</strong>，Lean’s OpenWrt 的最新源码所采用的Linux内核版本号是 5.4.156 (<a href="https://github.com/coolsnowwolf/lede/blob/master/include/kernel-version.mk#L12">现在又升级到了5.4.158</a>)。在 OpenWrt 的软件源仓库中，有一个叫 <a href="https://downloads.openwrt.org/releases/21.02.1/targets/x86/64/kmods/">kmods</a> (Kernel Modules) 的文件夹。顾名思义，就是Linux内核的附加模块。这个文件夹里又有以内核版本号和哈希值命名的文件夹，在安装这类的包时，会验证系统的内核版本号是否跟这里的一致，如果不一致是装不上的。（也可以强制安装，但大概率会出问题）</p><p>在官方最新的 Release 版本的软件库中，这个版本号是 <code>5.4.154</code>，即使是最新的 <a href="https://downloads.openwrt.org/snapshots/targets/x86/64/kmods/">Snapshot 版本</a>(即不稳定版本)，这个版本号最大也只有 <code>5.4.143</code>，所以使用更高的版本号必然导致内核模块不兼容。如果喜欢在使用时安装其他模块的话，必然会有很多模块装不了。</p><p>在 <a href="https://github.com/P3TERX/Actions-OpenWrt">Actions-OpenWrt</a> 中提供了两个自定义脚本供使用，于是我们可以在<a href="https://github.com/P3TERX/Actions-OpenWrt/blob/main/diy-part2.sh">diy-part2.sh</a>这个脚本里对内核版本进行修改。下面是我使用的命令，仅供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">sed -i &#x27;s/LINUX_VERSION-5.4 = .156/LINUX_VERSION-5.4 = .154/&#x27; include/kernel-version.mk</span><br><span class="line">sed -i &#x27;s/LINUX_KERNEL_HASH-5.4.156 = 06fe73e4623fcf1b3c0d0e1983d8286a2ff5b8fffbcb2163f4c01696a1c377fe/LINUX_KERNEL_HASH-5.4.154 = 058994f4666b6b0474a4d5228583e394594e406783b7e93d487c2a66c35f3c06/&#x27; include/kernel-version.mk</span><br></pre></td></tr></table></figure><p>注意，这里我偷懒直接暴力匹配修改了，现在Lean’s OpenWrt源码使用的内核版本是5.4.158，如果需要修改请自行更换命令里的匹配字符串。</p><p>至于该如何选择软件包，<a href="https://www.youtube.com/channel/UCOhkliOps3IS48ly-MgPC2A">esirPG</a>大佬提供了一个说明参考列表，有需求的可以看一下：<a href="https://drive.google.com/file/d/1VHB_CoL5LHLYJ39svjWmzJinbg7_Z-Fu/view?usp=sharing">https://drive.google.com/file/d/1VHB_CoL5LHLYJ39svjWmzJinbg7_Z-Fu/view?usp=sharing</a></p><h3 id="刷写部分"><a href="#刷写部分" class="headerlink" title="刷写部分"></a>刷写部分</h3><p>刷写部分的坑其实不比编译部分要少。</p><p>设想一下，当我们有一台没有装系统的电脑，我们会怎么给他装系统？</p><p>大部分人第一时间想到的是使用WinPE，或者使用启动介质（U盘，DVD等）。没错，软路由也可以这么装，大部分人也都是这么装的。但是，这个方法有着几个不可忽视的问题。</p><h4 id="显示器问题"><a href="#显示器问题" class="headerlink" title="显示器问题"></a>显示器问题</h4><p>现在大部分的软路由都有 VGA 显示器输出接口，我的甚至有 HDMI 输出接口。然而，当我使用HDMI线连接软路由到显示器后，问题出现了：BIOS 界面无输出，进不去 WinPE。只有正常启动系统后才能看到OpenWrt的命令行界面，系统启动前基本都是屏幕闪一下就没输出了。</p><p>我也很快找到了问题所在：BIOS 等界面无法支持 HDMI 信号输出。无奈之下，当时我迅速出去买了一条 VGA 的线，总算能看到熟悉的 BIOS 界面了。</p><h4 id="WinPE问题"><a href="#WinPE问题" class="headerlink" title="WinPE问题"></a>WinPE问题</h4><p>费了九牛二虎之力总算进了 WinPE，然后新的问题来了：写盘软件打不开！大部分都是缺少 xxxx.dll 啥的，毕竟 WinPE 只是精(残)简(废)版的 Windows，缺什么乱七八糟的依赖都正常。</p><p>好不容易换了个PE，写盘软件也能打开了，接着发现分区软件又打不开了！当时不知道什么原因，一打开 DiskGenius 整个PE就会直接黑屏，怎么都救不活。而且毕竟我的软路由才2G内存，这么低的配置WinPE直接卡住我都不觉得奇怪…</p><p>另外在写盘时还会碰到一个问题，就是快要结束的时候突然报错。比如使用 physdiskwrite 写盘的时候，眼看快要成功了，突然来一个 <code>write error after xxx bytes...</code>，特别让人抓狂。但是一番搜寻之后，看到论坛里有人说出现这样的情况仍然能成功进系统。我一试，果不其然，一切正常，系统确实是写进去了。至于为什么报错，那我就不得而知了。</p><h4 id="外置写盘法"><a href="#外置写盘法" class="headerlink" title="外置写盘法"></a>外置写盘法</h4><p>既然用PE写盘这么多问题，那有没有其他方法呢？有！</p><p>你只需要在某宝上花二十多买一个mSATA转USB的转接卡，就可以直接把硬盘取下来，插在自己的电脑上写盘了！就像制作启动U盘一样简单！</p><p>整个过程二十分钟不到，镜像就写完了。不过还有个问题，如果你就这样启动到系统后，你会在磁盘管理里发现硬盘后面还有一大块都没有分配，而OpenWrt只有小小的512M，这样的话再加装其他软件就不够用了。</p><p>解决方法也很简单，在写完镜像之后，立即调整root分区的空间大小，使其撑满整个硬盘空间。但在这里我不推荐用 DiskGenius，因为 DiskGenius 在执行分区扩容时会检查文件系统，如果发现有一丁点的错误就无法扩容。而且DiskGenius是不提供分区修复功能的，何况还是 Ext4 分区。</p><p>如果你电脑上有 Linux 环境，那就好办了。正好前几天<a href="https://blog.revincx.icu/posts/manjaro-exprience/">刚体验了 Manjaro Linux</a>，这不就派上用场了？ Linux 有个叫 <a href="https://gparted.org/">GParted</a> 的软件(默认没有，需要自己装)，这个软件可以很方便的调整 Ext4 甚至 Fat 以及 NTFS 文件系统的大小。只需要在 GParted 里调整 Root 分区，使其撑满硬盘空间就行了。</p><h3 id="组网AP部分"><a href="#组网AP部分" class="headerlink" title="组网AP部分"></a>组网AP部分</h3><p>本来是没有这个部分的，但是这确实是个小问题，而且跟 OpenWrt 有关系，所以还是记录一下吧<del>（凑字数</del></p><p>我的软路由只有两个网口，不过除了软路由之外，我还有一台斐讯K2作为AP使用。所以就要把这个路由器改成交换机+无线AP。</p><p>问题是，我的K2之前也是OpenWrt系统，对于OpenWrt怎么改交换机，在网上找到了不少帖子，似乎每个人方法都有不同点，综合了一下，下面我说一下我的方法吧。</p><ol><li>首先是删除WAN下的所有接口(WAN和WAN6)。</li><li>然后把LAN接口的DHCP关掉（勾选接口设置下面的”忽略此接口”选项，一开始半天没找到）。</li><li>接着在物理设置里把所有接口都勾选上。</li><li>然后修改LAN接口的静态IP地址（也可以干脆把协议改成DHCP，但不推荐这么做）。这个地址有点讲究，比如主路由的网关是 192.168.1.1 ，主路由DHCP地址池的起始地址是192.168.1.100，那么这个静态IP就要设置为这中间的值比较合适。比如192.168.1.2。这样的话就不至于连接到主路由网关的情况下进不去交换机路由器的管理界面。</li><li>修改无线网卡的工作模式为 “接入点AP (WDS)” （好像不改这个也没啥关系，但我还是改了）</li><li>(可选)在交换机设置里有两行VLAN的设置，这里把原本对应wan接口的那一行（也就是WAN选择了untagged的那一行）的WAN口关联改为”关”，接着把原本对应lan接口的那一行的WAN口关联改为untagged，保存。这样一来就可以实现所有接口盲插，全都可以作为交换机接口使用。（如果不设置的话只有LAN网口是能作为交换机使用的。）</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>又写完了一篇折腾文，虽然折腾了这么久但是没有感觉到一点累，这可能就是造轮子的魅力吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于『代理』的不完全使用指北</title>
      <link href="/2022/08/25/%E4%BD%A0%E7%9A%84%E6%B5%81%E9%87%8F%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6/"/>
      <url>/2022/08/25/%E4%BD%A0%E7%9A%84%E6%B5%81%E9%87%8F%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文是本人对于使用代理过程中的一些经验总结，并不是教程或者技术性文章，所以内容比较不全面很正常（<br>本文不会提供任何软件的下载链接，如有需求请自行查找相关下载源。</p><p>由于日常的开发以及娱乐需求，我们不得不在某些场景下使用代理连接网络。在各种平台都有各种代理软件供我们选择，有时候为了不同的需求我们会选择不同的软件。总体来说，原理都是把自己设备上的流量通过某种方式”转发”到远程设备上，但其中的能使用的具体方法却五花八门。</p><p>在路径上，我们可以把流量经过的地点分为三层：</p><ul><li>第一层：由你的流量发起段到代理软件的接入端，比如你的浏览器到你使用的Clash。</li><li>第二层：由代理软件到远端服务器，比如由你使用的Clash到某香港的服务器。</li><li>第三层：由远端服务器到目标服务器，比如由某香港的服务器到谷歌的服务器。</li></ul><p>本文主要对第一层和第二层做适当的讨论，<del>因为第三层也没啥好说的</del></p><h3 id="你的流量如何接入代理软件"><a href="#你的流量如何接入代理软件" class="headerlink" title="你的流量如何接入代理软件"></a>你的流量如何接入代理软件</h3><p>不管你使用什么代理软件，Clash也好，v2rayNG也好，这些软件都会在本地监听一个端口来作为代理的接入端。比如Clash大多监听7890端口，v2rayNG默认监听10809端口等等。你可以通过某些设置，使你当前某个软件的流量全部指向这个端口上。</p><p>通常情况下，这些监听的端口使用Socks5代理或HTTP代理。因为这两种代理协议都比较“纯粹”，占用的资源也少。区别在于，HTTP代理只能够代理HTTP协议的流量，比如你在浏览器中访问谷歌搜索，使用的就是HTTP(S)协议。而SOCKS5则支持代理几乎所有的TCP和UDP流量。所以在大部分场景下，代理软件监听的SOCKS5端口使用更多一些。</p><h4 id="什么是系统代理"><a href="#什么是系统代理" class="headerlink" title="什么是系统代理"></a>什么是系统代理</h4><p>当你使用电脑上的Clash或者v2ray类软件时，通常有一个选项叫做「系统代理」。当你打开这个选项时，代理软件就会修改系统设置中的代理选项。但是，系统设置中的代理往往只可设置为HTTP代理（如Win10设置中的代理），而且这个HTTP代理只对当前系统上web浏览器有效。</p><p>这也就是为什么明明设置了系统代理，访问GitHub也很快，但在命令行里克隆一个GitHub的仓库却很慢的原因。在命令行下，执行git命令也就是直接执行git的二进制文件，跟你设置的系统代理是没有关系的。</p><p>因为很多人都遇到过这个问题就顺便提一下了。也不是没有解决办法，一个方法是git提供了设置代理的配置选项（git config –global http.proxy xxxx 支持socks5），但是这么一配置就会导致以后所有的克隆都会走这个代理，而问题我们无法保证设置的代理不会改变或者随处可用。另一个方法就是使用一些公共的GitHub镜像了，这种方法对于不懂代理的人比较省事。</p><h4 id="其他软件中的代理设置"><a href="#其他软件中的代理设置" class="headerlink" title="其他软件中的代理设置"></a>其他软件中的代理设置</h4><p>除了使用系统代理选项使浏览器用上代理之外，其他软件大多也提供了代理功能。比如当你登陆QQ的时候，点击右上角的小齿轮，便可以配置http或socks代理选项。那问题来了，我使用的软件确实没有能配置代理的地方，怎么办呢？看下面~</p><h4 id="什么是TAP-x2F-TUN代理"><a href="#什么是TAP-x2F-TUN代理" class="headerlink" title="什么是TAP&#x2F;TUN代理"></a>什么是TAP&#x2F;TUN代理</h4><p>一些老用户可能了解过一款软件：SSTAP。这是很久前一个为了让某些游戏走代理而设计的软件，它的原理也就是TAP模式。所谓TAP模式其实就是在设备上利用技术手段安装一个虚拟的”网卡”，从而使得系统所有的流量都能经过代理软件。</p><p>而TUN模式则和TAP模式异曲同工。与TAP相比，TUN工作在更高的网络层，不需要虚拟的TAP设备，也能实现跟TAP类似的效果。不仅如此，TUN的性能也比TAP要好。目前，Clash系的所有代理软件基本都有TUN功能，比如Windows上的 Clash For Windows 以及 Clash .NET (已停更)等，除此之外还有 tun2socks 等专门具有TUN功能的软件。</p><p>另外，除了使用TAP&#x2F;TUN模式，还有一个比较特殊的东西：Proxifier。它是一款在Windows上实现接管所有系统流量的软件，你可以使用这个软件来使所有系统流量路由到某个Socks5代理上。至于原理，这款软件则是自己实现了一套基于驱动的流量劫持，由于是闭源商业软件，所以具体原理也不是很清楚。但是实测效果跟TAP几乎一样，如果不介意闭源的话也可以选择这款软件。</p><h4 id="什么是透明代理"><a href="#什么是透明代理" class="headerlink" title="什么是透明代理"></a>什么是透明代理</h4><p>所谓透明代理，就是用户可以感知不到自己处于代理环境下。最常见的透明代理也就是搭建在软理由等设备上的代理。由于软路由可以作为一个局域网的网关，局域网内所有接入设备的流量都会指向网关，所以网关就具有了出来这些流量去处的能力。</p><h3 id="代理软件如何处理你的流量"><a href="#代理软件如何处理你的流量" class="headerlink" title="代理软件如何处理你的流量"></a>代理软件如何处理你的流量</h3><p>根据代理软件所使用的路由模式，我们可以暂时先把代理软件分为两种：使用了Clash内核的和没有使用Clash内核的。这两类软件各有优缺，下面会详细说说。</p><p>第一类软件大部分已v2ray(v2fly或xray)为核心，代表性的有Windows平台上的v2rayN,安卓平台上的v2rayNG，Linux平台上的v2rayA等（由于我没有ios设备也没有Mac所以就不提了）这些软件都有一个共同点：独立的路由模式。比如 Win10平台上的 v2rayN 的路由设置需要自己手动配，安卓上的 v2rayNG 干脆不提供自定义，只有绕过大陆和局域网的选项。不过安卓端的 SagerNet 提供的路由设置就比较丰富，但如果手动配置的话也及其麻烦。</p><p>第二类软件则是基于Clash核心的代理软件，Clash 最大的一个特点就是配置文件了。与v2ray系的软件相比，Clash 的配置文件不仅有节点信息，还有完整的路由规则及策略组。换句话说，使用v2ray系的软件每次只能选择一个节点作为代理，而使用Clash则实现了节点分流，针对不同的网站走不同的节点，就像是再同时使用多个节点一样。</p><p>不过 Clash 的缺点也很明显，由于完全使用自己的内核，所以也就意味着暂时只能支持一部分代理协议(ss,ssr,vmess,trojan)，如果是比较冷门的代理协议(brook,tunnel等)就没法用clash了。而相比较，安卓端的 SagerNet 可以通过插件支持任何类型的代理协议，桌面平台上的 Qv2ray (已停更)也是可以安装插件来支持其他协议。</p><h4 id="如何对流量进行分流"><a href="#如何对流量进行分流" class="headerlink" title="如何对流量进行分流"></a>如何对流量进行分流</h4><p>我们只有在访问特定网站时才需要经过代理服务器，大部分情况都是直连就可以的，所以便出现了路由模式。</p><p>对于v2ray系的软件来说，一般都会有这几种路由模式：GFWList，大陆白名单，全局。</p><ol><li><p>GFWList，顾名思义，就是一个被墙封锁的网站名单。这个名单由民间开发者共同维护，不定时更新。当你的流量经过代理软件时，代理软件会先判断你要访问的网站在不在这个名单里，如果在的话则交给代理服务器来处理了。</p><p>不过问题是，并不是所有的网站都在GFWList里面，有些网站即使没被屏蔽，但由于ISP的一些原因访问就是特别慢，这种情况下就需要也走代理了。</p></li><li><p>大陆白名单，这种路由模式比较常用。首先一般我们会有 geoip 和 geosite 这两样东西，第一个 geoip 记录的是大陆的所有IP段，第二个则记录了大陆大部分常用的网站域名。它们与GFWList一样，也是由人们自行维护。当代理软件检测到你的流量是去往大陆内地的时候，则不走代理。</p><p>不过这种方式也不是没有问题，代理服务器是需要成本的，我们访问的大部分不位于大陆的网站速度都还可以，如果所有境外网站都走代理的话就造成了浪费。有时候如果目标网站离我们本来就很近(比如ISP在香港)，这时候再走代理可能速度就会被原来更慢了。</p></li><li><p>全局模式，就是所有流量都走代理咯，没啥具体要说明的。</p></li></ol><p>而对于 Clash 内核的软件，分流就特别的灵活了。Clash 的规则支持不仅域名匹配，IP匹配，甚至支持IP段，域名关键字匹配。Clash 对所有节点分成不同的组，每条匹配规则都对应着一个策略组。如果对现有的配置文件不满意，完全可以DIY属于自己的分流规则。</p><p>举个例子，我们可以把带原生IP的节点分到一个组，然后写一条规则，让流媒体网站(如Netflix等)的流量全部走这个组里的节点。我们还可以把所有的台湾节点分到一个组，让所有动画疯(一个台湾的看番网站)的流量全部走这个组。只要你有相应的需求，就可以DIY自己的规则！</p><p>如果比较懒的话，大部分机场都提供现成的Clash规则，GitHub上也有不少写好的模板可以参考，基本是不需要动太多手就可以实现想要的效果。</p><h4 id="进阶-使用Fake-IP"><a href="#进阶-使用Fake-IP" class="headerlink" title="进阶: 使用Fake-IP"></a>进阶: 使用Fake-IP</h4><p>防火墙不仅对某些特定的IP进行了阻断，还对相当一部分域名采取了DNS污染。简单来说，就是通过域名解析到的IP是错误的，所以我们还需要对DNS请求进行代理。但每次请求都先判断，再请求远程服务器DNS，再返回解析结果，客户端再请求，再代理，这样一来二去就极大浪费了时间。于是，Fake-IP 技术出现了。</p><p>所谓 Fake-IP，也就是虚假的IP。客户端进行的每次DNS请求，都会直接被代理软件劫持，然后代理软件不会先判断，而是立即返回一个假的IP。于此同时，代理软件再去判断并请求真实的IP，保存到自己的表中。而客户端向这个虚假的IP进行连接时，都会由代理软件直接从表中取出结果，然后对流量进行进一步处理。这样以来就节省了大约一半的时间。如果对更多技术细节感兴趣的话，可以去看参考文章2。</p><p>目前只有Clash内核支持Fake-IP模式，如果想使用的话可以在相关配置里把<code>fake-ip</code>设置为<code>true</code>，等待本地DNS刷新就可以正常使用了。</p><p>但是这种方式也不是没有缺点，不论是任何系统，都有着DNS缓存机制。假如某一天由于某些原因突然需要把代理软件关掉，这样一来客户端再去请求这个虚假的IP，就得不到任何响应了。这时需要手动刷新系统DNS缓存才能解决。</p><p>Fake-IP 比较常见的场景是在软路由上，毕竟软路由大部分时间都是24小时运行的，代理软件不会关，所以一般不会出现问题。目前软路由上支持Fake-IP的代理软件也只有OpenClash了。</p><h3 id="附加章节-代理线路与相关方案如何选择"><a href="#附加章节-代理线路与相关方案如何选择" class="headerlink" title="附加章节: 代理线路与相关方案如何选择"></a>附加章节: 代理线路与相关方案如何选择</h3><p>这一部分会粗略的说一下代理服务器相关的选择。不过大部分人的手里应该都是别人建好的节点，能自己搭建的应该很少。</p><p>目前比较流行的代理方案大概有下面几种: vmess+ws直连，vmess+ws+国内中转&#x2F;隧道，ss+隧道。其他的像IEPL啥的大部分都是ss了，这里就不说了。</p><p>如果仅仅是自用的话，选择vmess+ws直连就能满足大部分的需求了，如果想尝鲜，也可以考虑其他冷门协议或者混搭。之前笔者就使用了大半年的brook直连没有出现过问题。</p><h4 id="不同协议间的区别"><a href="#不同协议间的区别" class="headerlink" title="不同协议间的区别"></a>不同协议间的区别</h4><p>仅仅对于稳定而言，不同协议间的最大区别就是流量特征了。在很久之前ss直连都没有问题，但是由于ss自身的一些缺陷导致流量特征暴露，从而后来可以被精准屏蔽。</p><p>对于现在比较流行的vmess+ws或者再套一层tls，则是采取了流量伪装的办法，将代理流量伪装成websocket流量(也就是浏览网站的流量)以绕过检测。但是流量还可以分析行为特征，比如记录一段时间内的数据包量并建立模型等。这种检测手段对大型的机场节点往往比较有效。但是毕竟记录这个需要消耗很多资源，所以一般情况下防火墙很少用。</p><p>对于其他的一些冷门协议，大部分就是无特征协议，也就是说检测不出来你在干嘛。但是仍然可以通过一定的行为特征来实施封锁。由于没有更多详细的资料就不赘述了。</p><h4 id="什么是隧道"><a href="#什么是隧道" class="headerlink" title="什么是隧道"></a>什么是隧道</h4><p>隧道是当前很流行的一种代理方案，如果说中转是直接把流量转发到境外代理服务器，隧道则是把流量又装在了一个套子里转发给代理服务器。那么这样做有什么优点呢？与直接的中转相比，这样做往往能取得更低的延迟与更优秀的链接体验。由于流量已经被套了一层，所以接入层就可以使用有特征的ss协议。为什么非要用ss呢？因为ss与其他的现代协议相比，运行时消耗的资源要更小，性能也更好，所以也就有着更好的连接体验了。</p><p>目前实现隧道的方法主要有 Gost 和 WireGuard 等，经过这些隧道包裹的流量都是无特征的，从而就是不容易被防火墙检测。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不知不觉写了这么多，但其实内容还是很乱，希望能对看到的人有点帮助吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校教务系统的漏洞分析</title>
      <link href="/2022/03/15/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/15/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>本来是想着用Python写一个抢课的脚本，没想到在研究教务系统的网页时发现了我们教务系统漏洞还挺多。</p><p>学校教务系统搭建在IIS上，这个方正教务系统用的是ASP .NET,系统版本还是2017年的，据我们学长说以前也被人搞过，但仍然很长一段时间都没有升级系统。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/footer.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/footer.png" alt="教务系统底部"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里我已经提前知道了我们选课的那个页面对应xsxk.aspx，但教务系统首页现在的导航栏你活动报名一栏没有开放学生选课的入口，于是我们尝试把地址栏中的xs_main.aspx改为xsxk.aspx。一开始服务器返回了302，页面显示：<code>Object moved to here</code>，没事我们直接点进去，然后会有一个alert弹出，直接忽略就能进去了。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert.png" alt="img"></a><br><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk.png" alt="img"></a></p><p>点一下查看课表就可以把隐藏的按钮显示出来。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxk2.png" alt="img"></a></p><p>点选修课程，然后会有一个窗口弹出，这里可能会被chrome拦截，点地址栏的允许弹出窗口就行了。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/window.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/window.png" alt="img"></a></p><p>随便选一个项目，然后点选定，这时主窗口的课程列表就会更新。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/lesson-list.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/lesson-list.png" alt="img"></a></p><p>随便点一个课程然后又会有一个弹出窗口，同时会有不允许选课的alert弹出。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/alert2.png" alt="img"></a></p><p>这时我们不要点确定，否则窗口就会被关闭。复制这个窗口地址栏的网址，新建一个标签页打开。弹出alert后就可以直接点确定，不出意外的话这个标签页应该不会被关闭。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs.png" alt="img"></a></p><p>但是这个页面仍然不允许选课，没事，依照刚才的思路，一定是有东西被隐藏了。我们通过开发人员工具可以发现，关闭按钮前面还有两个button的样式都被设为了<code>DISPLAY:NONE</code>。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools.png" alt="img"></a></p><p>把这两个button的DISPLAY属性都取消掉，关闭按钮前面就会出现两个空白的按钮。尝试点第一个按钮，就会弹出如下提示。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs2.png" alt="img"></a></p><p>同时我们想要的选课界面就出来了。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs3.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/xsxjs3.png" alt="img"></a></p><p>选中单选框并选中不预定教材，然后点点选定按钮提交，就会用保存成功的提示。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/save-succeed.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/save-succeed.png" alt="img"></a></p><p>我们回到之前的页面查看我们的已选课程：</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/choosed-lesson.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/choosed-lesson.png" alt="img"></a></p><p>已选课程里面已经有了我们刚才选的课。</p><h3 id="更大胆的想法"><a href="#更大胆的想法" class="headerlink" title="更大胆的想法"></a>更大胆的想法</h3><p>教务系统网页提交信息时都会同时提交ViewState，虽然没有学过ASP，但通过查询资料，我觉得这个地方大有文章可做。</p><p><a href="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools2.png"><img src="https://cdn.jsdelivr.net/gh/Revincx/blog-assets@master/images/jiaowu-system-analysis/devtools2.png" alt="img"></a></p><p>尝试进行base64解码，结果里面出现了明文，说明没有经过加密。</p><p>资料：</p><blockquote><p>当 ASP .NET 中的表单被提交时，表单会随所有表单值一同重新出现。如何做到的呢？这是由于 ASP .NET 维持了您的 ViewState。ViewState 会在页面被提交到服务器时指示其状态。通过在每张页面中的一个 <code>&lt;form runat=&quot;server&quot;&gt;</code>控件中放置一个隐藏域，我们就可以定义页面的状态了。</p></blockquote><p>之后我专门查了关于这个VIEWSTATE里面的猫腻，发现了这个ViewState里面有不少可以利用的漏洞。</p><blockquote><p>其实ViewState 真正的问题在与其潜在的反序列化漏洞风险。ViewState 使用ObjectStateFormatter 进行反序列化，虽然ViewState 采取了加密和签名的安全措施。但是一旦泄露web.config，获取其加密和签名所用的密钥和算法，我们就可以将ObjectStateFormatte 的反序列化payload 进行同样的加密与签名，然后再发给服务器。这样ASP.NET在进行反序列化时，正常解密和校验，然后把payload交给ObjectStateFormatter 进行反序列化，触发其反序列化漏洞，实现RCE。</p></blockquote><p>由此，我们就可以在ViewState里进行XSS注入以实现跨站脚本攻击，从而在服务器上运行任意代码（我是这么理解的）。即使服务端开启了安全验证，我们仍然可以使用其他手段获取签名密钥以实现注入。</p><p>不过目前因为知识范围有限，暂时还没有进行相关的实验，以后有机会可以在教务系统上实验一下。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宗教答题直接满分的方法</title>
      <link href="/2021/12/25/%E5%AE%97%E6%95%99%E7%AD%94%E9%A2%98%E7%9B%B4%E6%8E%A5%E6%BB%A1%E5%88%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/12/25/%E5%AE%97%E6%95%99%E7%AD%94%E9%A2%98%E7%9B%B4%E6%8E%A5%E6%BB%A1%E5%88%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="电脑端"><a href="#电脑端" class="headerlink" title="电脑端"></a>电脑端</h3><p>打开答题页面，然后按F12打开开发者工具，点击上方的Console(或控制台)，粘贴下面的代码，回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">var topicid=topicJsonArray[0][&quot;TOPICID&quot;];</span><br><span class="line">    for(var i=0;i&lt;topicJsonArray.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        topicJsonArray[i][&quot;TOPICID&quot;]=topicid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意会返回一串数字，如果没有就是复制的有问题。<br> <br>然后在题库里搜索第一题的答案，把第一题的正确选项选上，直接点提交即可。</p><h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>下载并安装<a href="https://www.coolapk.com/apk/mark.via">Via浏览器</a><br>用这个浏览器打开答题页面，然后点开上方的标题栏，输入下面的代码并回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">javascript:var kzt=document.createElement(&quot;script&quot;); kzt.src=&quot;//cdnjs.cloudflare.com/ajax/libs/vConsole/3.3.4/vconsole.min.js&quot;; kzt.onload=function()&#123;new VConsole();&#125;; document.body.appendChild(kzt);</span><br></pre></td></tr></table></figure><p>然后界面会多出来一个vConsole按钮，点开，在Console栏下面的Command输入框内输入下面的代码并回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">var topicid=topicJsonArray[0][&quot;TOPICID&quot;];</span><br><span class="line">    for(var i=0;i&lt;topicJsonArray.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        topicJsonArray[i][&quot;TOPICID&quot;]=topicid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后点一下上面的部分返回答题界面，同样是把第一题答对提交即可。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>复制代码的时候不要把左边的行号复制上。<br>输完代码回车后不要刷新页面，否则需要重新输一次。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/28/hello-world/"/>
      <url>/2021/10/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
