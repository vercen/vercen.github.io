<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Eureka自我保护机制开启了但是服务还是被删掉了</title>
      <link href="/2023/03/15/Eureka%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/03/15/Eureka%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Eureka自我保护机制开启了但是服务还是被删掉了"><a href="#Eureka自我保护机制开启了但是服务还是被删掉了" class="headerlink" title="Eureka自我保护机制开启了但是服务还是被删掉了"></a>Eureka自我保护机制开启了但是服务还是被删掉了</h1><h3 id="事件重现："><a href="#事件重现：" class="headerlink" title="事件重现："></a>事件重现：</h3><h4 id="Eureka中80和10000都注册进来了"><a href="#Eureka中80和10000都注册进来了" class="headerlink" title="Eureka中80和10000都注册进来了"></a>Eureka中80和10000都注册进来了</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091059266.png" alt="image-20230409105935095"></p><h4 id="将80服务关闭"><a href="#将80服务关闭" class="headerlink" title="将80服务关闭"></a>将80服务关闭</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091101485.png" alt="image-20230409110137386"></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091102132.png" alt="image-20230409110201073"></p><h4 id="Eureka中就只剩10000了，80服务被删除了"><a href="#Eureka中就只剩10000了，80服务被删除了" class="headerlink" title="Eureka中就只剩10000了，80服务被删除了"></a>Eureka中就只剩10000了，80服务被删除了</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202304091102808.png" alt="image-20230409110238742"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>图一可以看到，在Eureka中我10000和80服务都已经注册进去了，在图二中我把80关闭了，但是Eureka确把80服务删除了，这不对啊，我Eureka自我保护模式没关啊！根据Eureka的自我保护模式就算服务关闭了，但是注册中心Eureka也不会将这个实例删除才对啊？应该是80,10000都在才符合我的预期啊！</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>因为我关闭80是通过idea关闭,idea让它们正常的走了应用消亡的生命周期,让资源得到了回收，所以我关掉80时，Eureka就将这个实例删除了。</p><p>我要怎么实验下Eureka自我保护模式呢？服务关闭但是Eureka没有将这个服务剔除出去？<br>正确测试方法：<br>用命令查询所有端口：netstat -ano<br>再用 ：taskkill &#x2F;pid pid号 &#x2F;f 强行关闭这个端口</p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册中心 </tag>
            
            <tag> CAP理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat和Spring和servlet和springMVC之间的关系</title>
      <link href="/2023/03/10/spring/"/>
      <url>/2023/03/10/spring/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tomcat和Spring和servlet和springMVC之间的关系"><a href="#Tomcat和Spring和servlet和springMVC之间的关系" class="headerlink" title="Tomcat和Spring和servlet和springMVC之间的关系"></a>Tomcat和Spring和servlet和springMVC之间的关系</h1><h2 id="1、Servlet是什么？"><a href="#1、Servlet是什么？" class="headerlink" title="1、Servlet是什么？"></a>1、<strong>Servlet是</strong>什<strong>么？</strong></h2><p>servlet就是一个Java接口，是JavaEE规范的一种，主要是为了扩展Java作为Web服务的功能。</p><p>由其他内部厂商如tomcat，JBoss内部实现web的功能。</p><p>如一个http请求到来：</p><p>容器将请求封装为servlet中的HttpServletRequest对象，调用init（），service（）等方法输出response,由容器包装为httpresponse返回给客户端的过程。</p><h2 id="2、Spring框架"><a href="#2、Spring框架" class="headerlink" title="2、Spring框架"></a>2、Spring框架</h2><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p><h2 id="3、关系"><a href="#3、关系" class="headerlink" title="3、关系"></a>3、关系</h2><p>1、Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。</p><p>2、Springmvc的核心是一个DispatcherServlet，并且DispatcherServlet继承自 FrameworkServlet继承自HttpServletBean 继承自HttpServlet（也就是你说的servelt） 本质上是一样的东西。其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情，如校验，拦截（AOP思想），后期渲染等等，好让我们专注于业务的开发。</p><p>servlet、filter和listener是javaweb得三大组成部分。</p><p>其中servlet通常是由web.xml统一管理。</p><p>而springmvc核心是disparcherservlet为入口。</p><p>spring可以管理servlet和springmvc中得javabean，这个意思就是说servlet和springmvc是相对独立的两个servlet，</p><p>当你想要在一个继承servlet的实现类中，控制url映射的时候，必须在web.xml配置对应关系，即使你把这个servlet交给spring去管理</p><p>他的映射入口依然是web.xml中你配置的那个路径，跟dispatcherservlet没有关系。这就导致了spring中有一个注入的servlet，并且还有一个独立的servlet（可以说是由web.xml管理的），最终如果你在servlet、filter注入属性的时候不成功。</p><h3 id="servlet工作流程"><a href="#servlet工作流程" class="headerlink" title="servlet工作流程"></a>servlet工作流程</h3><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303262210496.webp" alt="img"></p><h2 id="Tomcat和Spring关系"><a href="#Tomcat和Spring关系" class="headerlink" title="Tomcat和Spring关系"></a>Tomcat和Spring关系</h2><p>​Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。</p><p>​比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器，SpringMVC是处理Servlet请求的应用，<strong>其中DispatcherServlet实现了Servlet接口</strong>，<strong>Tomcat负责加载和调用DispatcherServlet。</strong>同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p><blockquote><p>​如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p></blockquote><blockquote><p>​<strong>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</strong></p></blockquote><h2 id="Spring-MVC与Jsp-x2F-Servlet比较"><a href="#Spring-MVC与Jsp-x2F-Servlet比较" class="headerlink" title="Spring MVC与Jsp&#x2F;Servlet比较"></a>Spring MVC与Jsp&#x2F;Servlet比较</h2><h4 id="1、传统的-Jsp-x2F-Servlet-技术体系弊端"><a href="#1、传统的-Jsp-x2F-Servlet-技术体系弊端" class="headerlink" title="1、传统的 Jsp&#x2F;Servlet 技术体系弊端"></a>1、传统的 Jsp&#x2F;Servlet 技术体系弊端</h4><blockquote><p>Servlet： 是用java编写的服务端应用程序。</p></blockquote><ul><li>作用：主要用于交互式的浏览和修改数据，生成web内容，这个过程为：客户端发送请求到服务器 -&gt; 服务器将请求信息发送至Servlet–&gt;Servlet生成相应内容并将其传给服务器-&gt; 服务器将响应返回给客户端。</li><li>在传统的 Jsp&#x2F;Servlet 技术体系中，如果要开发接口，一个接口对应一个<br>Servlet，每个请求都去在web.xml中配置一个servlet节点。会导致我们开发出许多 Servlet，使用 SpringMVC可以有效的简化这一步骤。</li></ul><h4 id="2、Spring-Web-MVC-特点"><a href="#2、Spring-Web-MVC-特点" class="headerlink" title="2、Spring Web MVC 特点"></a>2、Spring Web MVC 特点</h4><ul><li><p>Spring Web MVC 是一种基于 Java 的实现了 Web MVC 设计模式的请求驱动类型的轻量级 Web 框架，即使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringWeb MVC 也是要简化我们日常 Web 开发的。</p></li><li><p>Spring Web MVC 也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器可以拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View<br>Resolver)进行视图管理；页面控制器&#x2F;动作&#x2F;处理器为 Controller 接口（仅包含 ModelAndView handleRequest(request, response) 方法，也有人称作 Handler）的实现（也可以是任何的 POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。</p></li></ul><h4 id="3、Spring-MVC工作流程"><a href="#3、Spring-MVC工作流程" class="headerlink" title="3、Spring MVC工作流程"></a>3、Spring MVC工作流程</h4><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303262206811.jpg" alt="韩顺平 Java工程师课程-SpringMVC"></p><ul><li><p>1、用户发送请求至前端控制器DispatcherServlet。</p></li><li><p>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p></li><li><p>3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p></li><li><p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p></li><li><p>5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p></li><li><p>6、Controller执行完成返回ModelAndView。</p></li><li><p>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p></li><li><p>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p></li><li><p>9、ViewReslover解析后返回具体View。</p></li><li><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p></li><li><p>11、DispatcherServlet响应用户。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired和@Resource的区别</title>
      <link href="/2023/02/25/@Autowired%E5%92%8C@Resource/"/>
      <url>/2023/02/25/@Autowired%E5%92%8C@Resource/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h1><blockquote><p>Spring的一大核心功能就是IOC，它能帮助我们实现自动装配，</p></blockquote><hr><ul><li>@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</li></ul><p>当我们在将一个类上标注@Service或者@Controller或@Component或@Repository注解之后，<em><strong>spring的组件扫描就会自动发现它，并且会将其初始化为spring应用上下文中的bean。</strong></em></p><p>当需要使用这个bean的时候，例如加上@Autowired注解的时候，这个bean就会被创建。而且初始化是根据无参构造函数。</p><p>注释可以直接在属性上使用，因此不需要getter和setter:</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooFormatter</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建FooService时，Spring查找并注入fooFormatter。</p><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p>1、@Resource是JDK原生的注解，@Autowired是Spring2.5 引入的注解</p><p>2、@Resource有两个属性name和type。Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>@Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。</p><p><strong>@Autowired</strong></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303252014969.webp" alt="img"></p><p><strong>@Resource</strong></p><p><img src="https://img-1259413572.cos.ap-shanghai.myqcloud.com/img/202303252015360.webp" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@Autowired功能虽说非常强大，但是也有些不足之处。比如它跟Spring强耦合了，如果换成了其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。</p><p>除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。</p><p>1、@Autowired默认按byType自动装配，而@Resource默认byName自动装配。</p><p>2、@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。</p><p>3、@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。</p><p>4、@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。</p><p>5、@Autowired是Spring定义的注解，而@Resource是JSR-250定义的注解。</p><p>6、二者装配顺序不同</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/28/hello-world/"/>
      <url>/2023/01/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
